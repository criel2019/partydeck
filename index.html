<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>파티덱 - P2P 미니게임</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#0a0a12">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Noto+Sans+KR:wght@400;700;900&display=swap" rel="stylesheet">
<style>
:root {
  --bg-dark: #0a0a12;
  --bg-card: #14142a;
  --bg-surface: #1c1c3a;
  --accent: #ff6b35;
  --accent2: #00e5ff;
  --accent3: #ff2d78;
  --gold: #ffd700;
  --text: #e8e8f0;
  --text-dim: #7a7a9a;
  --success: #00e676;
  --danger: #ff1744;
  --radius: 16px;
  --radius-sm: 10px;
}

* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  font-family: 'Noto Sans KR', sans-serif;
  background: var(--bg-dark);
  color: var(--text);
}

body {
  background: 
    radial-gradient(ellipse at 20% 80%, rgba(255,107,53,0.08) 0%, transparent 50%),
    radial-gradient(ellipse at 80% 20%, rgba(0,229,255,0.06) 0%, transparent 50%),
    radial-gradient(ellipse at 50% 50%, rgba(255,45,120,0.04) 0%, transparent 60%),
    var(--bg-dark);
}

.screen { display: none; width: 100%; height: 100%; position: absolute; top: 0; left: 0; }
.screen.active { display: flex; flex-direction: column; }

/* ===== LOADING ===== */
#loadingScreen {
  align-items: center;
  justify-content: center;
  gap: 16px;
}
#loadingScreen .logo-icon { font-size: 64px; animation: float 3s ease-in-out infinite; }
#loadingScreen .logo-title {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 48px;
  background: linear-gradient(135deg, var(--accent), var(--accent3), var(--accent2));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}
.loading-text { color: var(--text-dim); font-size: 14px; }
.loading-bar { width: 200px; height: 4px; background: var(--bg-surface); border-radius: 2px; overflow: hidden; }
.loading-bar-inner { width: 0%; height: 100%; background: var(--accent); border-radius: 2px; transition: width 0.3s; }

/* ===== MAIN MENU ===== */
#mainMenu {
  align-items: center;
  justify-content: center;
  padding: 24px;
  gap: 20px;
  overflow-y: auto;
}

.logo-area { text-align: center; margin-bottom: 12px; }
.logo-icon { font-size: 64px; animation: float 3s ease-in-out infinite; }

@keyframes float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}

.logo-title {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 48px;
  background: linear-gradient(135deg, var(--accent), var(--accent3), var(--accent2));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  letter-spacing: -2px;
}

.logo-sub { color: var(--text-dim); font-size: 14px; margin-top: 4px; }

.menu-card {
  background: var(--bg-card);
  border: 1px solid rgba(255,255,255,0.06);
  border-radius: var(--radius);
  padding: 20px;
  width: 100%;
  max-width: 380px;
}

.profile-section { display: flex; align-items: center; gap: 14px; }

.avatar {
  width: 56px; height: 56px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--accent), var(--accent3));
  display: flex; align-items: center; justify-content: center;
  font-size: 28px; flex-shrink: 0; cursor: pointer;
  transition: transform 0.2s;
}
.avatar:active { transform: scale(0.92); }

.profile-info { flex: 1; }
.profile-name { font-weight: 900; font-size: 18px; }
.profile-stats { color: var(--text-dim); font-size: 12px; margin-top: 2px; }

.input-field {
  width: 100%;
  padding: 14px 16px;
  background: var(--bg-surface);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: var(--radius-sm);
  color: var(--text);
  font-size: 16px;
  font-family: inherit;
  outline: none;
  transition: border-color 0.2s;
}
.input-field:focus { border-color: var(--accent); }
.input-field::placeholder { color: var(--text-dim); }

.btn {
  width: 100%;
  padding: 16px;
  border: none;
  border-radius: var(--radius-sm);
  font-family: 'Black Han Sans', sans-serif;
  font-size: 18px;
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  letter-spacing: 1px;
  max-width: 380px;
}
.btn:active { transform: scale(0.97); }

.btn-primary {
  background: linear-gradient(135deg, var(--accent), #ff8f5a);
  color: white;
  box-shadow: 0 4px 20px rgba(255,107,53,0.3);
}

.btn-secondary {
  background: var(--bg-surface);
  color: var(--text);
  border: 1px solid rgba(255,255,255,0.1);
}

.btn-accent2 {
  background: linear-gradient(135deg, var(--accent2), #00b8d4);
  color: var(--bg-dark);
  box-shadow: 0 4px 20px rgba(0,229,255,0.3);
}

.btn-small { padding: 10px 16px; font-size: 14px; width: auto; }

.join-row {
  display: flex; gap: 8px; width: 100%; max-width: 380px;
}

/* ===== LOBBY ===== */
#lobby { padding: 20px; gap: 16px; }

.lobby-header { display: flex; align-items: center; justify-content: space-between; }

.back-btn {
  background: none; border: none; color: var(--text);
  font-size: 24px; cursor: pointer; padding: 8px;
}

.room-code-display {
  text-align: center; padding: 20px;
  background: var(--bg-card); border-radius: var(--radius);
  border: 1px solid rgba(255,255,255,0.06);
}
.room-code-label { font-size: 13px; color: var(--text-dim); margin-bottom: 6px; }
.room-code {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 40px; letter-spacing: 8px; color: var(--accent2); cursor: pointer;
}
.room-code-hint { font-size: 11px; color: var(--text-dim); margin-top: 6px; }

.share-btn-row { display: flex; gap: 8px; margin-top: 10px; justify-content: center; }
.share-btn {
  padding: 8px 16px; background: var(--bg-surface);
  border: 1px solid rgba(255,255,255,0.1); border-radius: var(--radius-sm);
  color: var(--text); font-size: 13px; font-weight: 700;
  cursor: pointer; font-family: inherit;
}
.share-btn:active { transform: scale(0.95); }

.players-section { flex: 1; overflow-y: auto; }
.players-title { font-size: 14px; color: var(--text-dim); margin-bottom: 10px; font-weight: 700; }
.player-list { display: flex; flex-direction: column; gap: 8px; }

.player-item {
  display: flex; align-items: center; gap: 12px;
  padding: 14px 16px; background: var(--bg-card);
  border-radius: var(--radius-sm);
  border: 1px solid rgba(255,255,255,0.04);
  animation: slideIn 0.3s ease;
}

@keyframes slideIn {
  from { opacity: 0; transform: translateX(-20px); }
  to { opacity: 1; transform: translateX(0); }
}

.player-avatar-sm {
  width: 40px; height: 40px; border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
  font-size: 20px; flex-shrink: 0;
}
.player-name { font-weight: 700; font-size: 15px; flex: 1; }
.host-badge {
  background: var(--gold); color: var(--bg-dark);
  font-size: 10px; font-weight: 900; padding: 3px 8px; border-radius: 20px;
}

.game-select {
  padding: 16px; background: var(--bg-card); border-radius: var(--radius);
  border: 1px solid rgba(255,255,255,0.06);
}
.game-select-title { font-size: 14px; color: var(--text-dim); margin-bottom: 10px; font-weight: 700; }
.game-options { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; max-height: 240px; overflow-y: auto; padding-right: 4px; }

.game-option {
  padding: 12px 8px; background: var(--bg-surface);
  border: 2px solid transparent; border-radius: var(--radius-sm);
  text-align: center; cursor: pointer; transition: all 0.2s;
  font-size: 13px; font-weight: 700;
}
.game-option:active { transform: scale(0.95); }
.game-option.selected { border-color: var(--accent); background: rgba(255,107,53,0.15); }
.game-option .game-emoji { font-size: 28px; display: block; margin-bottom: 4px; }
.game-option.disabled { opacity: 0.4; pointer-events: none; }

/* ===== POKER TABLE ===== */
#pokerGame { padding: 12px; gap: 6px; position: relative; overflow: hidden; }

.poker-top-bar {
  display: flex; justify-content: space-between; align-items: center;
  padding: 8px 12px; background: var(--bg-card); border-radius: var(--radius-sm); z-index: 10;
}
.pot-display {
  display: flex; align-items: center; gap: 6px;
  font-family: 'Black Han Sans', sans-serif; font-size: 20px; color: var(--gold);
}
.round-display { font-size: 12px; color: var(--text-dim); font-weight: 700; }

.table-area {
  flex: 1; position: relative; display: flex;
  flex-direction: column; align-items: center; justify-content: center; min-height: 0;
}

.community-cards { display: flex; gap: 6px; margin: 8px 0; justify-content: center; flex-wrap: wrap; }

.card {
  width: 48px; height: 70px; border-radius: 8px;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  font-weight: 900; font-size: 16px; line-height: 1.2;
  transition: all 0.3s; position: relative;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

.card-face { background: white; color: #1a1a2e; border: 2px solid #ddd; }
.card-face.red { color: #d32f2f; border-color: #ffcdd2; }
.card-face.black { color: #1a1a2e; border-color: #ccc; }

.card-back {
  background: linear-gradient(135deg, #1a237e, #283593);
  border: 2px solid #3949ab;
}

.card-rank { font-size: 16px; line-height: 1; }
.card-suit { font-size: 13px; line-height: 1; }
.card-placeholder { background: rgba(255,255,255,0.05); border: 2px dashed rgba(255,255,255,0.15); }

.opponents-area {
  display: flex; justify-content: center; gap: 10px;
  flex-wrap: wrap; width: 100%; padding: 0 4px;
}

.opponent-slot {
  display: flex; flex-direction: column; align-items: center;
  gap: 3px; min-width: 65px;
}

.opponent-avatar {
  width: 42px; height: 42px; border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
  font-size: 20px; position: relative; transition: all 0.3s;
}
.opponent-avatar.active-turn {
  box-shadow: 0 0 0 3px var(--accent), 0 0 20px rgba(255,107,53,0.4);
  animation: pulse-ring 1.5s ease infinite;
}

@keyframes pulse-ring {
  0%, 100% { box-shadow: 0 0 0 3px var(--accent), 0 0 20px rgba(255,107,53,0.4); }
  50% { box-shadow: 0 0 0 5px var(--accent), 0 0 30px rgba(255,107,53,0.6); }
}

.opponent-name { font-size: 11px; font-weight: 700; max-width: 65px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; text-align: center; }
.opponent-chips { font-size: 10px; color: var(--gold); font-weight: 700; }
.opponent-bet { font-size: 10px; color: var(--accent); font-weight: 700; min-height: 14px; }
.opponent-cards { display: flex; gap: 2px; }
.opponent-cards .card { width: 28px; height: 40px; font-size: 9px; }
.opponent-cards .card .card-rank { font-size: 10px; }
.opponent-cards .card .card-suit { font-size: 8px; }
.fold-overlay { opacity: 0.35; }

.my-hand-area {
  width: 100%; padding: 10px 16px;
  background: var(--bg-card); border-radius: var(--radius);
  border: 1px solid rgba(255,255,255,0.06);
}
.my-info-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
.my-chips { font-family: 'Black Han Sans', sans-serif; font-size: 18px; color: var(--gold); }
.my-hand-label { font-size: 12px; color: var(--text-dim); font-weight: 700; }

.my-cards { display: flex; justify-content: center; gap: 10px; margin-bottom: 6px; }
.my-cards .card { width: 60px; height: 86px; }
.my-cards .card .card-rank { font-size: 20px; }
.my-cards .card .card-suit { font-size: 16px; }

.hand-rank-display { text-align: center; font-size: 13px; color: var(--accent2); font-weight: 700; min-height: 18px; }

.action-bar { display: flex; gap: 6px; width: 100%; padding: 0 4px; }

.action-btn {
  flex: 1; padding: 13px 6px; border: none; border-radius: var(--radius-sm);
  font-family: 'Black Han Sans', sans-serif; font-size: 14px;
  cursor: pointer; transition: all 0.15s; letter-spacing: 0.5px;
}
.action-btn:active { transform: scale(0.95); }
.action-btn:disabled { opacity: 0.3; cursor: not-allowed; }

.btn-fold { background: var(--bg-surface); color: var(--text-dim); border: 1px solid rgba(255,255,255,0.1); }
.btn-check { background: var(--bg-surface); color: var(--accent2); border: 1px solid rgba(0,229,255,0.3); }
.btn-call { background: rgba(0,229,255,0.15); color: var(--accent2); border: 1px solid rgba(0,229,255,0.3); }
.btn-raise { background: linear-gradient(135deg, var(--accent), #ff8f5a); color: white; }
.btn-allin { background: linear-gradient(135deg, var(--accent3), #ff6090); color: white; }

.raise-slider-area { display: none; width: 100%; padding: 8px 4px; align-items: center; gap: 8px; }
.raise-slider-area.visible { display: flex; }
.raise-slider {
  flex: 1; -webkit-appearance: none; height: 6px;
  border-radius: 3px; background: var(--bg-surface); outline: none;
}
.raise-slider::-webkit-slider-thumb {
  -webkit-appearance: none; width: 28px; height: 28px;
  border-radius: 50%; background: var(--accent); cursor: pointer;
}
.raise-amount { font-family: 'Black Han Sans', sans-serif; font-size: 16px; color: var(--accent); min-width: 50px; text-align: right; }
.raise-confirm {
  padding: 8px 16px; background: var(--accent); color: white;
  border: none; border-radius: var(--radius-sm);
  font-family: 'Black Han Sans', sans-serif; font-size: 14px; cursor: pointer;
}

/* ===== MAFIA FULL VERSION ===== */
#mafiaGame {
  padding: 0;
  gap: 0;
  overflow: hidden;
  background:
    radial-gradient(ellipse at 30% 80%, rgba(139,0,0,0.06) 0%, transparent 50%),
    radial-gradient(ellipse at 70% 20%, rgba(26,31,58,0.08) 0%, transparent 50%),
    var(--bg-dark);
}

/* --- Top Bar --- */
.mf-topbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 14px;
  background: linear-gradient(180deg, rgba(20,20,42,0.98) 0%, rgba(20,20,42,0.85) 100%);
  border-bottom: 1px solid rgba(255,255,255,0.06);
  flex-shrink: 0;
  z-index: 20;
}
.mf-topbar-left { display: flex; align-items: center; gap: 10px; }
.mf-back-btn {
  width: 36px; height: 36px;
  display: flex; align-items: center; justify-content: center;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 10px;
  color: var(--text);
  font-size: 18px;
  cursor: pointer;
}
.mf-phase-badge {
  display: flex; align-items: center; gap: 6px;
  padding: 6px 14px;
  border-radius: 20px;
  font-family: 'Black Han Sans', sans-serif;
  font-size: 16px;
  letter-spacing: 0.5px;
}
.mf-phase-badge.day {
  background: linear-gradient(135deg, rgba(255,200,50,0.2), rgba(255,150,30,0.1));
  color: #ffd700;
  border: 1px solid rgba(255,215,0,0.3);
}
.mf-phase-badge.night {
  background: linear-gradient(135deg, rgba(70,90,160,0.25), rgba(40,50,100,0.15));
  color: #87a6d9;
  border: 1px solid rgba(135,166,217,0.3);
}
.mf-phase-badge.vote {
  background: linear-gradient(135deg, rgba(255,45,120,0.2), rgba(200,30,80,0.1));
  color: #ff6b9d;
  border: 1px solid rgba(255,45,120,0.3);
}
.mf-phase-badge.result {
  background: linear-gradient(135deg, rgba(0,230,118,0.2), rgba(0,180,90,0.1));
  color: #69f0ae;
  border: 1px solid rgba(0,230,118,0.3);
}
.mf-timer-box {
  display: flex; align-items: center; gap: 5px;
  padding: 6px 12px;
  background: rgba(255,107,53,0.15);
  border: 1px solid rgba(255,107,53,0.3);
  border-radius: 20px;
  font-family: 'Black Han Sans', sans-serif;
  font-size: 18px;
  color: var(--accent);
}
.mf-timer-box.urgent {
  animation: mf-timer-pulse 0.5s ease-in-out infinite;
  color: #ff1744;
  border-color: rgba(255,23,68,0.5);
  background: rgba(255,23,68,0.15);
}
@keyframes mf-timer-pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.08); }
}
.mf-day-counter {
  font-size: 11px;
  color: var(--text-dim);
  text-align: center;
  padding: 2px 0;
  font-weight: 700;
  letter-spacing: 1px;
}

/* --- Role Banner --- */
.mf-role-banner {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 16px;
  margin: 8px 14px 4px;
  border-radius: var(--radius-sm);
  flex-shrink: 0;
}
.mf-role-banner.team-mafia {
  background: linear-gradient(135deg, rgba(139,0,0,0.25), rgba(80,0,0,0.15));
  border: 1px solid rgba(139,0,0,0.4);
}
.mf-role-banner.team-citizen {
  background: linear-gradient(135deg, rgba(0,150,255,0.15), rgba(0,100,200,0.08));
  border: 1px solid rgba(0,150,255,0.25);
}
.mf-role-emoji { font-size: 36px; flex-shrink: 0; }
.mf-role-info { flex: 1; min-width: 0; }
.mf-role-name {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 18px;
  margin-bottom: 2px;
}
.mf-role-name.mafia-color { color: #ff4444; }
.mf-role-name.citizen-color { color: #4fc3f7; }
.mf-role-desc {
  font-size: 12px;
  color: var(--text-dim);
  line-height: 1.4;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* --- Scrollable Content --- */
.mf-content {
  flex: 1;
  overflow-y: auto;
  padding: 8px 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  -webkit-overflow-scrolling: touch;
}

/* --- Player Grid --- */
.mf-player-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 8px;
}
.mf-player-grid.three-col { grid-template-columns: repeat(3, 1fr); }

.mf-player-card {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 5px;
  padding: 10px 6px 8px;
  background: var(--bg-card);
  border-radius: var(--radius-sm);
  border: 2px solid transparent;
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
  overflow: hidden;
}
.mf-player-card:active { transform: scale(0.96); }
.mf-player-card.selectable:hover { border-color: rgba(255,255,255,0.15); }
.mf-player-card.selected {
  border-color: var(--accent3);
  background: rgba(255,45,120,0.12);
  box-shadow: 0 0 12px rgba(255,45,120,0.2);
}
.mf-player-card.selected-snipe {
  border-color: #ff1744;
  background: rgba(255,23,68,0.15);
  box-shadow: 0 0 16px rgba(255,23,68,0.3);
}
.mf-player-card.dead {
  opacity: 0.3;
  pointer-events: none;
  filter: grayscale(0.6);
}
.mf-player-card.dead .mf-dead-overlay {
  display: flex;
}
.mf-player-card.voted-on {
  border-color: rgba(255,107,53,0.5);
}
.mf-player-card.is-me {
  border-color: rgba(0,229,255,0.3);
}

.mf-dead-overlay {
  display: none;
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.5);
  align-items: center;
  justify-content: center;
  font-size: 32px;
  z-index: 5;
  border-radius: var(--radius-sm);
}
.mf-player-avatar {
  width: 48px; height: 48px;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  flex-shrink: 0;
  border: 2px solid rgba(255,255,255,0.08);
}
.mf-player-name {
  font-size: 12px;
  font-weight: 700;
  color: var(--text);
  text-align: center;
  max-width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.mf-player-role-tag {
  font-size: 10px;
  padding: 1px 6px;
  border-radius: 8px;
  font-weight: 700;
}
.mf-player-role-tag.mafia-tag {
  background: rgba(255,0,0,0.2);
  color: #ff6b6b;
}
.mf-player-role-tag.citizen-tag {
  background: rgba(0,150,255,0.15);
  color: #64b5f6;
}

.mf-vote-count-badge {
  position: absolute;
  top: -2px;
  right: -2px;
  min-width: 22px; height: 22px;
  background: linear-gradient(135deg, #e03131, #c92a2a);
  border: 2px solid var(--bg-dark);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  font-weight: 900;
  color: white;
  z-index: 10;
  animation: mf-badge-pop 0.3s cubic-bezier(0.4,0,0.2,1);
}
@keyframes mf-badge-pop {
  0% { transform: scale(0); }
  50% { transform: scale(1.3); }
  100% { transform: scale(1); }
}
.mf-host-crown {
  position: absolute;
  top: -6px;
  left: -4px;
  font-size: 16px;
  z-index: 10;
  filter: drop-shadow(0 1px 3px rgba(0,0,0,0.8));
}
.mf-lover-heart {
  position: absolute;
  top: -4px;
  right: -4px;
  font-size: 14px;
  z-index: 10;
  animation: mf-heart-beat 1.5s ease-in-out infinite;
}
@keyframes mf-heart-beat {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.2); }
}
.mf-soldier-shield {
  position: absolute;
  bottom: 2px;
  right: 2px;
  font-size: 12px;
  z-index: 10;
}
.mf-snipe-used-badge {
  position: absolute;
  bottom: 2px;
  left: 2px;
  font-size: 10px;
  z-index: 10;
  opacity: 0.5;
}

/* --- Night Action Panel --- */
.mf-night-panel {
  background: var(--bg-card);
  border-radius: var(--radius);
  padding: 14px;
  border: 1px solid rgba(255,255,255,0.06);
}
.mf-night-title {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 16px;
  color: #87a6d9;
  margin-bottom: 8px;
  text-align: center;
}
.mf-night-desc {
  font-size: 13px;
  color: var(--text-dim);
  text-align: center;
  margin-bottom: 12px;
  line-height: 1.5;
}
.mf-night-waiting {
  text-align: center;
  padding: 24px 0;
}
.mf-night-waiting-icon {
  font-size: 48px;
  margin-bottom: 10px;
  animation: mf-moon-float 3s ease-in-out infinite;
}
@keyframes mf-moon-float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-8px); }
}
.mf-night-waiting-text {
  font-size: 14px;
  color: var(--text-dim);
}

/* --- Chat Panel (Mafia / Spy) --- */
.mf-chat-panel {
  background: var(--bg-card);
  border-radius: var(--radius);
  border: 1px solid rgba(139,0,0,0.3);
  overflow: hidden;
  display: flex;
  flex-direction: column;
  max-height: 180px;
}
.mf-chat-header {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  background: rgba(139,0,0,0.15);
  border-bottom: 1px solid rgba(139,0,0,0.2);
  font-size: 13px;
  font-weight: 700;
  color: #ff6b6b;
}
.mf-chat-messages {
  flex: 1;
  overflow-y: auto;
  padding: 8px 12px;
  display: flex;
  flex-direction: column;
  gap: 4px;
  min-height: 60px;
  max-height: 100px;
  -webkit-overflow-scrolling: touch;
}
.mf-chat-msg {
  font-size: 12px;
  line-height: 1.4;
}
.mf-chat-msg .sender {
  font-weight: 700;
  color: #ff8a80;
}
.mf-chat-msg .text {
  color: var(--text);
}
.mf-chat-input-row {
  display: flex;
  gap: 6px;
  padding: 8px;
  background: rgba(0,0,0,0.2);
  border-top: 1px solid rgba(139,0,0,0.15);
}
.mf-chat-input {
  flex: 1;
  padding: 8px 12px;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 8px;
  color: var(--text);
  font-size: 13px;
  font-family: 'Noto Sans KR', sans-serif;
  outline: none;
}
.mf-chat-input::placeholder { color: var(--text-dim); }
.mf-chat-send-btn {
  padding: 8px 14px;
  background: rgba(139,0,0,0.4);
  border: 1px solid rgba(139,0,0,0.5);
  border-radius: 8px;
  color: #ff8a80;
  font-size: 13px;
  font-weight: 700;
  cursor: pointer;
  flex-shrink: 0;
}
.mf-chat-send-btn:active { transform: scale(0.95); }

/* --- Action Buttons Area --- */
.mf-action-area {
  padding: 10px 14px 14px;
  background: linear-gradient(0deg, rgba(20,20,42,0.98) 0%, rgba(20,20,42,0.7) 100%);
  border-top: 1px solid rgba(255,255,255,0.04);
  flex-shrink: 0;
  display: flex;
  flex-direction: column;
  gap: 8px;
  z-index: 20;
}
.mf-message-box {
  font-size: 13px;
  color: var(--text);
  text-align: center;
  padding: 6px;
  line-height: 1.5;
  min-height: 24px;
}
.mf-btn-row {
  display: flex;
  gap: 8px;
}
.mf-action-btn {
  flex: 1;
  padding: 12px 16px;
  border-radius: var(--radius-sm);
  font-family: 'Noto Sans KR', sans-serif;
  font-weight: 900;
  font-size: 15px;
  cursor: pointer;
  transition: all 0.2s;
  border: none;
  text-align: center;
}
.mf-action-btn:active { transform: scale(0.96); }
.mf-action-btn.primary {
  background: linear-gradient(135deg, var(--accent), #e55a2b);
  color: white;
  box-shadow: 0 4px 12px rgba(255,107,53,0.3);
}
.mf-action-btn.primary:disabled {
  opacity: 0.4;
  pointer-events: none;
}
.mf-action-btn.secondary {
  background: rgba(255,255,255,0.08);
  color: var(--text);
  border: 1px solid rgba(255,255,255,0.12);
}
.mf-action-btn.danger {
  background: linear-gradient(135deg, #d32f2f, #b71c1c);
  color: white;
  box-shadow: 0 4px 12px rgba(211,47,47,0.3);
}
.mf-action-btn.snipe {
  background: linear-gradient(135deg, #ff1744, #d50000);
  color: white;
  box-shadow: 0 4px 12px rgba(255,23,68,0.3);
  font-size: 13px;
}
.mf-action-btn.snipe:disabled {
  opacity: 0.3;
  pointer-events: none;
}
.mf-action-btn.extend {
  background: rgba(255,215,0,0.15);
  color: var(--gold);
  border: 1px solid rgba(255,215,0,0.3);
  font-size: 13px;
}

/* --- Vote Status Panel --- */
.mf-vote-panel {
  background: var(--bg-card);
  border-radius: var(--radius);
  padding: 12px;
  border: 1px solid rgba(255,255,255,0.06);
}
.mf-vote-title {
  font-size: 13px;
  font-weight: 700;
  color: var(--gold);
  margin-bottom: 10px;
  text-transform: uppercase;
  letter-spacing: 1px;
}
.mf-vote-bars {
  display: flex;
  flex-direction: column;
  gap: 6px;
}
.mf-vote-bar {
  display: flex;
  align-items: center;
  gap: 8px;
}
.mf-vote-bar-name {
  font-size: 12px;
  color: var(--text);
  width: 52px;
  font-weight: 600;
  text-align: right;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.mf-vote-bar-track {
  flex: 1;
  height: 20px;
  background: rgba(0,0,0,0.3);
  border-radius: 10px;
  overflow: hidden;
  position: relative;
  border: 1px solid rgba(255,255,255,0.06);
}
.mf-vote-bar-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), #e55a2b);
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: flex-end;
  padding-right: 6px;
  font-size: 11px;
  font-weight: 900;
  color: white;
  transition: width 0.4s cubic-bezier(0.4,0,0.2,1);
  min-width: 0;
}
.mf-skip-count {
  font-size: 12px;
  color: var(--text-dim);
  text-align: center;
  margin-top: 8px;
}

/* --- Events / Announcements --- */
.mf-events-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.mf-event-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 14px;
  border-radius: var(--radius-sm);
  font-size: 13px;
  font-weight: 500;
  line-height: 1.4;
  animation: mf-event-in 0.5s cubic-bezier(0.4,0,0.2,1);
}
@keyframes mf-event-in {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}
.mf-event-item.death {
  background: linear-gradient(135deg, rgba(139,0,0,0.25), rgba(80,0,0,0.15));
  border: 1px solid rgba(139,0,0,0.4);
  color: #ff6b6b;
}
.mf-event-item.safe {
  background: linear-gradient(135deg, rgba(0,200,100,0.15), rgba(0,150,80,0.08));
  border: 1px solid rgba(0,200,100,0.3);
  color: #69f0ae;
}
.mf-event-item.info {
  background: linear-gradient(135deg, rgba(51,154,240,0.15), rgba(24,100,171,0.08));
  border: 1px solid rgba(51,154,240,0.3);
  color: #64b5f6;
}
.mf-event-item.snipe {
  background: linear-gradient(135deg, rgba(255,23,68,0.2), rgba(200,0,50,0.12));
  border: 1px solid rgba(255,23,68,0.5);
  color: #ff5252;
  animation: mf-event-in 0.5s cubic-bezier(0.4,0,0.2,1), mf-shake 0.4s ease-in-out 0.5s;
}
@keyframes mf-shake {
  0%,100% { transform: translateX(0); }
  25% { transform: translateX(-4px); }
  75% { transform: translateX(4px); }
}
.mf-event-item.vote-result {
  background: linear-gradient(135deg, rgba(255,45,120,0.15), rgba(200,30,80,0.08));
  border: 1px solid rgba(255,45,120,0.3);
  color: #ff6b9d;
}
.mf-event-item.immunity {
  background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(200,170,0,0.08));
  border: 1px solid rgba(255,215,0,0.3);
  color: #ffd740;
}
.mf-event-icon { font-size: 18px; flex-shrink: 0; }

/* --- Result Screen Overlay --- */
.mf-result-overlay {
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.85);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
  gap: 16px;
  padding: 24px;
  animation: mf-result-fade 0.8s ease-out;
}
@keyframes mf-result-fade {
  from { opacity: 0; }
  to { opacity: 1; }
}
.mf-result-title {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 36px;
  text-align: center;
}
.mf-result-title.win { color: var(--gold); }
.mf-result-title.lose { color: var(--text-dim); }
.mf-result-subtitle {
  font-size: 16px;
  color: var(--text);
  text-align: center;
}
.mf-result-roles {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  width: 100%;
  max-width: 340px;
  max-height: 260px;
  overflow-y: auto;
}
.mf-result-player {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 3px;
  padding: 8px 4px;
  background: var(--bg-card);
  border-radius: 8px;
  font-size: 11px;
}
.mf-result-player.dead-result { opacity: 0.5; }
.mf-result-player-avatar {
  width: 36px; height: 36px;
  border-radius: 10px;
  display: flex; align-items: center; justify-content: center;
  font-size: 18px;
}
.mf-result-player-name {
  font-weight: 700;
  font-size: 11px;
  color: var(--text);
  max-width: 70px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.mf-result-player-role {
  font-size: 10px;
  font-weight: 700;
}
.mf-result-player-role.mafia-text { color: #ff6b6b; }
.mf-result-player-role.citizen-text { color: #64b5f6; }

.mf-result-close-btn {
  padding: 12px 40px;
  background: var(--accent);
  border: none;
  border-radius: var(--radius-sm);
  color: white;
  font-family: 'Black Han Sans', sans-serif;
  font-size: 16px;
  cursor: pointer;
  margin-top: 8px;
}

/* --- Spy Info Panel --- */
.mf-spy-info {
  background: var(--bg-card);
  border-radius: var(--radius-sm);
  padding: 10px 12px;
  border: 1px solid rgba(128,0,128,0.3);
}
.mf-spy-info-title {
  font-size: 12px;
  font-weight: 700;
  color: #ce93d8;
  margin-bottom: 6px;
}
.mf-spy-dead-roles {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
}
.mf-spy-dead-tag {
  font-size: 11px;
  padding: 2px 8px;
  border-radius: 10px;
  background: rgba(128,0,128,0.15);
  color: #e1bee7;
}

/* --- Undertaker Info --- */
.mf-undertaker-result {
  background: var(--bg-card);
  border-radius: var(--radius-sm);
  padding: 10px 12px;
  border: 1px solid rgba(100,100,100,0.3);
}
.mf-undertaker-result-title {
  font-size: 12px;
  font-weight: 700;
  color: #90a4ae;
  margin-bottom: 4px;
}

/* --- Night overlay tint --- */
.mf-night-tint {
  position: absolute;
  inset: 0;
  background: rgba(10,12,30,0.4);
  pointer-events: none;
  z-index: 1;
  transition: opacity 0.5s;
}
.mf-night-tint.hidden { opacity: 0; }

/* --- Misc --- */
.mf-divider {
  height: 1px;
  background: rgba(255,255,255,0.06);
  margin: 4px 0;
}
.mf-section-label {
  font-size: 12px;
  font-weight: 700;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 4px;
}

/* Night mode background shift */
#mafiaGame.night-mode {
  background:
    radial-gradient(ellipse at 30% 80%, rgba(26,31,58,0.12) 0%, transparent 50%),
    radial-gradient(ellipse at 70% 20%, rgba(40,50,120,0.08) 0%, transparent 50%),
    linear-gradient(180deg, #080818 0%, #0a0a16 100%);
}

/* Lover reveal */
.mf-lover-reveal {
  background: var(--bg-card);
  border-radius: var(--radius);
  padding: 16px;
  border: 1px solid rgba(255,105,180,0.3);
  text-align: center;
}
.mf-lover-reveal-title {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 18px;
  color: #ff69b4;
  margin-bottom: 8px;
}
.mf-lover-reveal-text {
  font-size: 14px;
  color: var(--text);
}

/* --- Spectator bar for dead players --- */
.mf-spectator-bar {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 8px 14px;
  background: rgba(100,100,100,0.15);
  border: 1px solid rgba(100,100,100,0.2);
  border-radius: var(--radius-sm);
  font-size: 13px;
  color: var(--text-dim);
}

/* Scroll styling */
.mf-content::-webkit-scrollbar { width: 4px; }
.mf-content::-webkit-scrollbar-track { background: transparent; }
.mf-content::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }
.mf-chat-messages::-webkit-scrollbar { width: 3px; }
.mf-chat-messages::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }

/* ===== RESULT OVERLAY ===== */
.result-overlay {
  display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(10,10,18,0.95); z-index: 100;
  flex-direction: column; align-items: center; justify-content: center;
  padding: 24px; gap: 16px;
}
.result-overlay.active { display: flex; }
.result-title { font-family: 'Black Han Sans', sans-serif; font-size: 36px; }
.result-hand { font-size: 18px; color: var(--accent2); font-weight: 700; }
.result-cards { display: flex; gap: 8px; }
.result-pot { font-family: 'Black Han Sans', sans-serif; font-size: 24px; color: var(--gold); }

.winner-info {
  display: flex; flex-direction: column; align-items: center; gap: 8px;
  padding: 16px; background: var(--bg-card); border-radius: var(--radius);
  width: 100%; max-width: 340px;
}

/* ===== AD BANNER ===== */
.ad-banner {
  width: 100%; max-width: 380px; height: 60px;
  background: var(--bg-card); border: 1px dashed rgba(255,255,255,0.1);
  border-radius: var(--radius-sm);
  display: flex; align-items: center; justify-content: center;
  color: var(--text-dim); font-size: 12px; flex-shrink: 0;
}

/* ===== TOAST ===== */
.toast {
  position: fixed; top: 20px; left: 50%;
  transform: translateX(-50%) translateY(-100px);
  background: var(--bg-surface); border: 1px solid rgba(255,255,255,0.1);
  padding: 12px 24px; border-radius: var(--radius-sm);
  font-size: 14px; font-weight: 700; z-index: 200;
  transition: transform 0.3s ease; white-space: nowrap;
  max-width: 90vw; overflow: hidden; text-overflow: ellipsis;
}
.toast.show { transform: translateX(-50%) translateY(0); }

.spinner {
  width: 32px; height: 32px;
  border: 3px solid var(--bg-surface); border-top-color: var(--accent);
  border-radius: 50%; animation: spin 0.8s linear infinite; margin: 0 auto;
}
@keyframes spin { to { transform: rotate(360deg); } }

::-webkit-scrollbar { width: 4px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }

/* TRUTH GAME CSS */

/* ===== 전체 레이아웃 ===== */
#truthGame {
  padding: 12px 16px;
  gap: 10px;
  background:
    radial-gradient(ellipse at 30% 70%, rgba(0,230,118,0.04) 0%, transparent 50%),
    radial-gradient(ellipse at 70% 30%, rgba(255,23,68,0.04) 0%, transparent 50%),
    linear-gradient(180deg, #0d0d14 0%, #0a0a12 50%, #08080e 100%);
  position: relative;
  overflow: hidden;
}

#truthGame::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background:
    repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(255,255,255,0.008) 2px,
      rgba(255,255,255,0.008) 4px
    );
  pointer-events: none;
  z-index: 0;
}

#truthGame > * { position: relative; z-index: 1; }

/* ===== 상단 바 ===== */
.truth-top-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 14px;
  background: linear-gradient(135deg, rgba(20,20,42,0.95), rgba(28,28,58,0.9));
  border-radius: var(--radius-sm);
  border: 1px solid rgba(255,255,255,0.06);
  backdrop-filter: blur(10px);
}

.truth-round-badge {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 15px;
  color: var(--accent2);
  letter-spacing: 2px;
}

.truth-questioner-display {
  font-size: 13px;
  font-weight: 700;
  color: var(--text-dim);
}

/* ===== 메인 콘텐츠 ===== */
.truth-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 0;
  overflow-y: auto;
  padding: 8px 0;
}

.truth-phase-area {
  width: 100%;
  max-width: 400px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 16px;
  animation: truthFadeIn 0.4s ease;
}

@keyframes truthFadeIn {
  from { opacity: 0; transform: translateY(12px); }
  to   { opacity: 1; transform: translateY(0); }
}

/* ===== 질문 입력 (질문자) ===== */
.truth-your-turn-badge {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 22px;
  color: var(--gold);
  text-align: center;
  text-shadow: 0 0 20px rgba(255,215,0,0.3);
}

.truth-question-box {
  width: 100%;
  position: relative;
}

.truth-textarea {
  width: 100%;
  padding: 16px;
  background: var(--bg-surface);
  border: 2px solid rgba(255,255,255,0.08);
  border-radius: var(--radius-sm);
  color: var(--text);
  font-size: 16px;
  font-family: inherit;
  outline: none;
  resize: none;
  transition: border-color 0.3s;
  line-height: 1.5;
}

.truth-textarea:focus {
  border-color: var(--accent2);
  box-shadow: 0 0 20px rgba(0,229,255,0.1);
}

.truth-textarea::placeholder {
  color: var(--text-dim);
  font-size: 14px;
}

.truth-char-count {
  position: absolute;
  bottom: 8px;
  right: 12px;
  font-size: 11px;
  color: var(--text-dim);
}

.truth-submit-btn {
  max-width: 100%;
}

/* ===== 대기 화면 ===== */
.truth-waiting-icon {
  font-size: 64px;
  animation: float 3s ease-in-out infinite;
}

.truth-waiting-text {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 22px;
  color: var(--text);
}

.truth-waiting-sub {
  font-size: 14px;
  color: var(--text-dim);
  text-align: center;
}

.truth-dots-loader {
  display: flex;
  gap: 8px;
  justify-content: center;
  margin-top: 8px;
}

.truth-dots-loader span {
  width: 10px;
  height: 10px;
  background: var(--accent2);
  border-radius: 50%;
  animation: truthDotPulse 1.4s ease-in-out infinite;
}

.truth-dots-loader span:nth-child(2) { animation-delay: 0.2s; }
.truth-dots-loader span:nth-child(3) { animation-delay: 0.4s; }

@keyframes truthDotPulse {
  0%, 80%, 100% { opacity: 0.2; transform: scale(0.8); }
  40% { opacity: 1; transform: scale(1.2); }
}

/* ===== 질문 표시 ===== */
.truth-question-display {
  width: 100%;
  padding: 20px;
  background: linear-gradient(135deg, rgba(20,20,42,0.95), rgba(28,28,58,0.85));
  border-radius: var(--radius);
  border: 1px solid rgba(0,229,255,0.15);
  text-align: center;
  position: relative;
  overflow: hidden;
}

.truth-question-display::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 3px;
  background: linear-gradient(90deg, var(--accent2), var(--accent), var(--accent2));
}

.truth-question-display-small {
  padding: 14px;
}

.truth-question-display-small .truth-question-text {
  font-size: 16px;
}

.truth-question-label {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 28px;
  color: var(--accent2);
  margin-bottom: 8px;
  text-shadow: 0 0 15px rgba(0,229,255,0.4);
}

.truth-question-display-small .truth-question-label {
  font-size: 20px;
  margin-bottom: 4px;
}

.truth-question-text {
  font-size: 20px;
  font-weight: 700;
  line-height: 1.5;
  word-break: keep-all;
}

/* ===== O/X 투표 버튼 ===== */
.truth-vote-buttons {
  display: flex;
  gap: 20px;
  width: 100%;
  justify-content: center;
  padding: 10px 0;
}

.truth-vote-btn {
  width: 130px;
  height: 130px;
  border: none;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 6px;
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
}

.truth-vote-btn::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  background: rgba(255,255,255,0.15);
  border-radius: 50%;
  transform: translate(-50%, -50%);
  transition: width 0.4s, height 0.4s;
}

.truth-vote-btn:active::before {
  width: 200px;
  height: 200px;
}

.truth-vote-btn:active {
  transform: scale(0.92);
}

/* O 버튼 - 원형, 초록 */
.truth-vote-o {
  border-radius: 50%;
  background: linear-gradient(145deg, #00e676, #00c853);
  box-shadow:
    0 6px 30px rgba(0,230,118,0.4),
    0 0 60px rgba(0,230,118,0.15),
    inset 0 2px 4px rgba(255,255,255,0.25),
    inset 0 -3px 6px rgba(0,0,0,0.2);
}

.truth-vote-o:hover {
  box-shadow:
    0 8px 40px rgba(0,230,118,0.5),
    0 0 80px rgba(0,230,118,0.2),
    inset 0 2px 4px rgba(255,255,255,0.25),
    inset 0 -3px 6px rgba(0,0,0,0.2);
}

/* X 버튼 - 사각형, 빨강 */
.truth-vote-x {
  border-radius: var(--radius);
  background: linear-gradient(145deg, #ff1744, #d50000);
  box-shadow:
    0 6px 30px rgba(255,23,68,0.4),
    0 0 60px rgba(255,23,68,0.15),
    inset 0 2px 4px rgba(255,255,255,0.25),
    inset 0 -3px 6px rgba(0,0,0,0.2);
}

.truth-vote-x:hover {
  box-shadow:
    0 8px 40px rgba(255,23,68,0.5),
    0 0 80px rgba(255,23,68,0.2),
    inset 0 2px 4px rgba(255,255,255,0.25),
    inset 0 -3px 6px rgba(0,0,0,0.2);
}

.truth-vote-symbol {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 48px;
  color: white;
  text-shadow: 0 2px 8px rgba(0,0,0,0.3);
  line-height: 1;
}

.truth-vote-label {
  font-size: 14px;
  font-weight: 700;
  color: rgba(255,255,255,0.9);
}

.truth-vote-btn.selected {
  animation: truthBtnPulse 0.5s ease;
}

.truth-vote-btn.disabled {
  opacity: 0.3;
  pointer-events: none;
  filter: grayscale(0.5);
}

@keyframes truthBtnPulse {
  0%   { transform: scale(1); }
  30%  { transform: scale(1.1); }
  60%  { transform: scale(0.95); }
  100% { transform: scale(1); }
}

/* ===== 투표 대기 ===== */
.truth-vote-waiting {
  width: 100%;
  text-align: center;
}

.truth-voted-badge {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 20px;
  color: var(--success);
  margin-bottom: 16px;
  text-shadow: 0 0 15px rgba(0,230,118,0.3);
}

.truth-vote-progress {
  width: 100%;
  max-width: 300px;
  margin: 0 auto;
}

.truth-progress-bar {
  width: 100%;
  height: 8px;
  background: var(--bg-surface);
  border-radius: 4px;
  overflow: hidden;
  margin-bottom: 8px;
}

.truth-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent2), var(--accent));
  border-radius: 4px;
  transition: width 0.4s ease;
}

.truth-progress-text {
  font-size: 14px;
  color: var(--text-dim);
  font-weight: 700;
}

/* ===== 결과 영역 ===== */
.truth-result-container {
  width: 100%;
  padding: 24px 20px;
  background: linear-gradient(135deg, rgba(20,20,42,0.95), rgba(28,28,58,0.85));
  border-radius: var(--radius);
  border: 1px solid rgba(255,255,255,0.06);
}

.truth-result-title {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 18px;
  color: var(--text-dim);
  text-align: center;
  margin-bottom: 20px;
  letter-spacing: 2px;
}

.truth-result-row {
  display: flex;
  align-items: center;
  gap: 16px;
  margin-bottom: 16px;
  padding: 12px 16px;
  background: rgba(0,0,0,0.2);
  border-radius: var(--radius-sm);
}

.truth-result-icon {
  width: 52px;
  height: 52px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: 'Black Han Sans', sans-serif;
  font-size: 26px;
  color: white;
  flex-shrink: 0;
  text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.truth-result-icon-o {
  background: linear-gradient(145deg, #00e676, #00c853);
  box-shadow: 0 4px 20px rgba(0,230,118,0.35), 0 0 40px rgba(0,230,118,0.1);
}

.truth-result-icon-x {
  background: linear-gradient(145deg, #ff1744, #d50000);
  box-shadow: 0 4px 20px rgba(255,23,68,0.35), 0 0 40px rgba(255,23,68,0.1);
}

.truth-result-info {
  flex: 1;
}

.truth-result-count {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 28px;
  color: var(--text);
  margin-bottom: 6px;
}

.truth-result-dots {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
}

.truth-dot {
  width: 14px;
  height: 14px;
  border-radius: 50%;
  transition: all 0.3s ease;
}

.truth-dot.filled-o {
  background: var(--success);
  box-shadow: 0 0 8px rgba(0,230,118,0.5);
  animation: truthDotAppear 0.4s ease backwards;
}

.truth-dot.filled-x {
  background: var(--danger);
  box-shadow: 0 0 8px rgba(255,23,68,0.5);
  animation: truthDotAppear 0.4s ease backwards;
}

.truth-dot.empty {
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.1);
}

@keyframes truthDotAppear {
  from { transform: scale(0); opacity: 0; }
  to   { transform: scale(1); opacity: 1; }
}

.truth-result-total {
  text-align: center;
  font-size: 13px;
  color: var(--text-dim);
  margin-top: 4px;
  font-weight: 700;
}

/* ===== 다음 라운드 ===== */
.truth-next-btn {
  max-width: 100%;
}

.truth-next-waiting {
  font-size: 14px;
  color: var(--text-dim);
  text-align: center;
  font-weight: 700;
}

/* ===== 하단 플레이어 바 ===== */
.truth-players-bar {
  display: flex;
  gap: 8px;
  padding: 10px 8px;
  background: linear-gradient(135deg, rgba(20,20,42,0.9), rgba(28,28,58,0.85));
  border-radius: var(--radius-sm);
  border: 1px solid rgba(255,255,255,0.04);
  overflow-x: auto;
  flex-shrink: 0;
  justify-content: center;
}

.truth-player-chip {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 3px;
  min-width: 48px;
  flex-shrink: 0;
}

.truth-player-avatar {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  position: relative;
  transition: all 0.3s;
}

.truth-player-avatar.is-questioner {
  box-shadow: 0 0 0 3px var(--gold), 0 0 16px rgba(255,215,0,0.4);
}

.truth-player-avatar.has-voted::after {
  content: '\2713';
  position: absolute;
  bottom: -2px;
  right: -2px;
  width: 16px;
  height: 16px;
  background: var(--success);
  border-radius: 50%;
  font-size: 9px;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 900;
}

.truth-player-name {
  font-size: 10px;
  font-weight: 700;
  max-width: 52px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  text-align: center;
  color: var(--text-dim);
}

.truth-player-name.active-name {
  color: var(--gold);
}

/* QUICK DRAW CSS */
#quickDrawGame {
  padding: 16px;
  gap: 16px;
  background: linear-gradient(180deg, #1a0f0a 0%, #3d2817 100%);
}

.qd-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: rgba(20,20,42,0.7);
  border-radius: var(--radius-sm);
  backdrop-filter: blur(4px);
}

.qd-title {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 20px;
  color: #ff9800;
}

.qd-round {
  font-size: 13px;
  color: var(--text-dim);
  font-weight: 700;
}

.qd-main-area {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.qd-tap-zone {
  width: 280px;
  height: 280px;
  border-radius: 50%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5);
}

.qd-tap-zone.waiting {
  background: radial-gradient(circle, #2a2a3a, #1a1a2a);
  border: 4px solid rgba(255,255,255,0.1);
}

.qd-tap-zone.countdown {
  background: radial-gradient(circle, #4a3a2a, #2a1a1a);
  border: 4px solid rgba(255,152,0,0.3);
  animation: qd-pulse-countdown 1s ease-in-out infinite;
}

.qd-tap-zone.fire {
  background: radial-gradient(circle, #ff4444, #cc0000);
  border: 4px solid #ffaa00;
  box-shadow: 0 0 50px rgba(255,68,68,0.8), 0 8px 32px rgba(0,0,0,0.5);
  animation: qd-fire-pulse 0.5s ease-in-out infinite;
}

.qd-tap-zone.cheated {
  background: radial-gradient(circle, #666, #333);
  border: 4px solid #999;
}

.qd-tap-zone.done {
  background: radial-gradient(circle, #2a4a2a, #1a2a1a);
  border: 4px solid rgba(0,255,100,0.3);
}

@keyframes qd-pulse-countdown {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.02); }
}

@keyframes qd-fire-pulse {
  0%, 100% { transform: scale(1); box-shadow: 0 0 50px rgba(255,68,68,0.8), 0 8px 32px rgba(0,0,0,0.5); }
  50% { transform: scale(1.05); box-shadow: 0 0 80px rgba(255,68,68,1), 0 8px 40px rgba(0,0,0,0.6); }
}

.qd-status-text {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 42px;
  color: var(--text);
  text-align: center;
  text-shadow: 0 2px 8px rgba(0,0,0,0.5);
  margin-bottom: 12px;
}

.qd-tap-zone.fire .qd-status-text {
  font-size: 56px;
  color: #fff;
  animation: qd-fire-text 0.3s ease-in-out infinite;
}

@keyframes qd-fire-text {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

.qd-reaction-time {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 32px;
  color: var(--accent2);
  text-align: center;
  min-height: 40px;
}

.qd-rankings {
  padding: 16px;
  background: var(--bg-card);
  border-radius: var(--radius);
  border: 1px solid rgba(255,255,255,0.06);
  max-height: 200px;
  overflow-y: auto;
}

.qd-rankings-title {
  font-size: 14px;
  color: var(--text-dim);
  margin-bottom: 10px;
  font-weight: 700;
  text-align: center;
}

.qd-rankings-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.qd-ranking-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 12px;
  background: var(--bg-surface);
  border-radius: var(--radius-sm);
  border: 1px solid rgba(255,255,255,0.04);
  animation: slideIn 0.3s ease;
}

.qd-ranking-item.winner {
  border-color: var(--gold);
  background: rgba(255,215,0,0.1);
}

.qd-ranking-rank {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 18px;
  color: var(--text-dim);
  min-width: 28px;
  text-align: center;
}

.qd-ranking-item.winner .qd-ranking-rank {
  color: var(--gold);
}

.qd-ranking-avatar {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  flex-shrink: 0;
}

.qd-ranking-name {
  flex: 1;
  font-weight: 700;
  font-size: 14px;
}

.qd-ranking-time {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 16px;
  color: var(--accent2);
}

.qd-ranking-item.cheated .qd-ranking-time {
  color: var(--danger);
  font-size: 14px;
}

.qd-restart-btn {
  max-width: 280px;
  align-self: center;
}

/* ===== RUSSIAN ROULETTE CSS ===== */
#rouletteGame { padding: 12px; gap: 10px; }

.roulette-header {
  display: flex; justify-content: space-between; align-items: center;
  padding: 10px 12px; background: var(--bg-card); border-radius: var(--radius-sm);
}

.roulette-title {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 20px; letter-spacing: 0.5px;
}

.roulette-survivors {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 16px; color: var(--success);
}

/* 설정 패널 */
.roulette-setup {
  padding: 16px; background: var(--bg-card);
  border-radius: var(--radius); border: 1px solid rgba(255,255,255,0.06);
}

.setup-card {
  background: var(--bg-surface); padding: 14px;
  border-radius: var(--radius-sm); margin-bottom: 10px;
}

.setup-label {
  font-size: 14px; font-weight: 700; margin-bottom: 8px;
  color: var(--text-dim);
}

.setup-slider-row {
  display: flex; align-items: center; gap: 12px;
}

.setup-slider {
  flex: 1; -webkit-appearance: none; height: 6px;
  border-radius: 3px; background: var(--bg-dark); outline: none;
}

.setup-slider::-webkit-slider-thumb {
  -webkit-appearance: none; width: 24px; height: 24px;
  border-radius: 50%; background: var(--accent2); cursor: pointer;
  box-shadow: 0 2px 8px rgba(0,229,255,0.4);
}

.setup-value {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 20px; color: var(--accent2); min-width: 30px;
  text-align: center;
}

/* 실린더 영역 */
.cylinder-area {
  flex: 1; display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  padding: 16px; gap: 16px;
}

.current-turn-display {
  font-size: 16px; font-weight: 700;
  color: var(--text); text-align: center;
  padding: 8px 16px; background: var(--bg-surface);
  border-radius: var(--radius-sm);
}

#currentTurnName {
  color: var(--accent2); font-family: 'Black Han Sans', sans-serif;
}

.cylinder-container {
  position: relative; width: 200px; height: 200px;
}

.cylinder {
  width: 100%; height: 100%; border-radius: 50%;
  position: relative;
  background:
    conic-gradient(from 0deg,
      #2a2a3e 0deg 60deg, #1a1a2e 60deg 120deg,
      #2a2a3e 120deg 180deg, #1a1a2e 180deg 240deg,
      #2a2a3e 240deg 300deg, #1a1a2e 300deg 360deg);
  box-shadow:
    inset 0 0 30px rgba(0,0,0,0.5),
    0 4px 20px rgba(0,0,0,0.3);
  border: 4px solid #3a3a4e;
  transition: transform 3s cubic-bezier(0.25, 0.1, 0.25, 1);
}

.cylinder.spinning {
  animation: spin-cylinder 3s cubic-bezier(0.25, 0.1, 0.25, 1);
}

@keyframes spin-cylinder {
  from { transform: rotate(0deg); }
  to { transform: rotate(1440deg); }
}

.cylinder-center {
  position: absolute; top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  width: 50px; height: 50px; border-radius: 50%;
  background: linear-gradient(135deg, #3a3a4e, #2a2a3e);
  display: flex; align-items: center; justify-content: center;
  font-size: 24px;
  box-shadow: 0 2px 12px rgba(0,0,0,0.5);
  pointer-events: none;
}

.chamber-indicator {
  position: absolute;
  width: 20px; height: 20px;
  border-radius: 50%;
  background: rgba(120,120,140,0.5);
  border: 2px solid rgba(255,255,255,0.2);
  transform-origin: center;
}

.chamber-indicator.bullet {
  background: radial-gradient(circle, #ff1744, #c41c1c);
  border-color: #ff4444;
  box-shadow: 0 0 10px rgba(255,23,68,0.6);
}

.chamber-indicator.empty {
  background: rgba(120,120,140,0.3);
}

.cylinder-info {
  font-size: 13px; color: var(--text-dim);
  text-align: center; min-height: 18px;
}

/* 생존자 리스트 */
.survivors-list {
  display: grid; grid-template-columns: repeat(3, 1fr);
  gap: 8px; padding: 0 4px; max-height: 120px;
  overflow-y: auto;
}

.survivor-item {
  display: flex; flex-direction: column;
  align-items: center; gap: 4px;
  padding: 8px 4px; background: var(--bg-card);
  border-radius: var(--radius-sm); position: relative;
  transition: all 0.3s;
}

.survivor-item.dead {
  opacity: 0.4; filter: grayscale(1);
}

.survivor-item.dead::after {
  content: '\1F480';
  position: absolute; top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  font-size: 32px; pointer-events: none;
}

.survivor-avatar-sm {
  width: 36px; height: 36px; border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
  font-size: 18px;
}

.survivor-name {
  font-size: 11px; font-weight: 700;
  max-width: 60px; overflow: hidden;
  text-overflow: ellipsis; white-space: nowrap;
  text-align: center;
}

/* 액션 버튼 */
.roulette-actions {
  display: flex; flex-direction: column; gap: 8px;
  padding: 0 4px;
}

.btn-danger {
  background: linear-gradient(135deg, var(--danger), #c41c1c);
  color: white;
  box-shadow: 0 4px 20px rgba(255,23,68,0.4);
  font-size: 20px; padding: 18px;
  position: relative; overflow: hidden;
}

.btn-danger::before {
  content: '';
  position: absolute; top: 50%; left: 50%;
  width: 0; height: 0; border-radius: 50%;
  background: rgba(255,255,255,0.3);
  transform: translate(-50%, -50%);
  transition: width 0.6s, height 0.6s;
}

.btn-danger:active::before {
  width: 300px; height: 300px;
}

/* 결과 플래시 */
.roulette-flash {
  display: none; position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  z-index: 150; align-items: center; justify-content: center;
  pointer-events: none;
}

.roulette-flash.active { display: flex; }

.roulette-flash.bang {
  background: radial-gradient(circle, rgba(255,23,68,0.8), rgba(255,23,68,0) 70%);
  animation: flash-bang 0.8s ease-out;
}

.roulette-flash.safe {
  background: radial-gradient(circle, rgba(0,230,118,0.6), rgba(0,230,118,0) 70%);
  animation: flash-safe 0.8s ease-out;
}

@keyframes flash-bang {
  0% { opacity: 0; }
  20% { opacity: 1; }
  100% { opacity: 0; }
}

@keyframes flash-safe {
  0% { opacity: 0; }
  30% { opacity: 1; }
  100% { opacity: 0; }
}

.flash-content {
  display: flex; flex-direction: column;
  align-items: center; gap: 12px;
  animation: flash-zoom 0.8s ease-out;
}

@keyframes flash-zoom {
  0% { transform: scale(0.5); opacity: 0; }
  40% { transform: scale(1.3); opacity: 1; }
  100% { transform: scale(1); opacity: 0; }
}

.flash-icon {
  font-size: 120px; line-height: 1;
}

.flash-text {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 48px; color: white;
  text-shadow: 0 4px 20px rgba(0,0,0,0.5);
}

/* LOTTERY ROULETTE CSS */

/* Top Bar */
.lottery-top-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: var(--bg-card);
  border-radius: var(--radius-sm);
}

.lottery-title {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 20px;
  color: var(--text);
}

/* Mode Tabs */
.mode-tabs {
  display: flex;
  gap: 8px;
  padding: 0 12px;
}

.mode-tab {
  flex: 1;
  padding: 12px;
  background: var(--bg-surface);
  border: 2px solid transparent;
  border-radius: var(--radius-sm);
  text-align: center;
  font-size: 15px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
}

.mode-tab:active {
  transform: scale(0.97);
}

.mode-tab.active {
  background: rgba(255, 107, 53, 0.15);
  border-color: var(--accent);
  color: var(--accent);
}

/* Setup Panels */
.lottery-setup-panel,
.roulette-setup-panel {
  padding: 16px;
  background: var(--bg-card);
  border-radius: var(--radius);
  border: 1px solid rgba(255, 255, 255, 0.06);
  margin: 0 12px;
}

.lottery-items-input {
  width: 100%;
  min-height: 120px;
  padding: 12px;
  background: var(--bg-surface);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: var(--radius-sm);
  color: var(--text);
  font-size: 14px;
  font-family: inherit;
  resize: vertical;
  outline: none;
  margin-bottom: 12px;
}

.lottery-items-input:focus {
  border-color: var(--accent);
}

.setup-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 12px;
  justify-content: center;
}

.grid-size-select {
  padding: 8px 12px;
  background: var(--bg-surface);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: var(--radius-sm);
  color: var(--text);
  font-size: 14px;
  font-weight: 700;
  outline: none;
  cursor: pointer;
}

/* Lottery Grid */
.lottery-grid-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  padding: 12px;
  overflow-y: auto;
}

.lottery-status {
  text-align: center;
  padding: 10px;
  margin-bottom: 12px;
  background: var(--bg-card);
  border-radius: var(--radius-sm);
}

.picked-count {
  font-size: 13px;
  color: var(--text-dim);
  font-weight: 700;
}

.lottery-grid {
  display: grid;
  gap: 4px;
  width: 100%;
  max-width: 500px;
  margin: 0 auto;
}

.lottery-cell {
  aspect-ratio: 1;
  background: linear-gradient(135deg, #ffd700, #ffab00);
  border: 2px solid rgba(255, 215, 0, 0.6);
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  font-weight: 900;
  cursor: pointer;
  transition: all 0.15s;
  position: relative;
  transform-style: preserve-3d;
  perspective: 1000px;
}

.lottery-cell:active {
  transform: scale(0.95);
}

.lottery-cell.revealed {
  background: var(--bg-surface);
  border-color: var(--text-dim);
  cursor: default;
  animation: flip 0.6s ease;
}

.lottery-cell.revealed .cell-content {
  color: var(--text);
  font-size: 11px;
  padding: 4px;
  text-align: center;
  word-break: break-word;
  line-height: 1.2;
}

@keyframes flip {
  0% { transform: rotateY(0deg); }
  50% { transform: rotateY(90deg); }
  100% { transform: rotateY(0deg); }
}

/* My Result Panel */
.my-result-panel {
  padding: 12px;
  background: var(--bg-card);
  border-radius: var(--radius);
  margin: 0 12px 12px;
  border: 1px solid rgba(255, 255, 255, 0.06);
}

.result-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
  max-height: 120px;
  overflow-y: auto;
}

.result-item {
  padding: 8px 10px;
  background: var(--bg-surface);
  border-radius: var(--radius-sm);
  font-size: 13px;
  font-weight: 700;
  color: var(--text);
}

/* Roulette */
.roulette-display-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px 12px;
  gap: 20px;
}

.roulette-status {
  text-align: center;
  padding: 10px;
  background: var(--bg-card);
  border-radius: var(--radius-sm);
  width: 100%;
}

.roulette-wheel-container {
  position: relative;
  width: 100%;
  max-width: 320px;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.roulette-pointer {
  font-size: 40px;
  color: var(--accent3);
  margin-bottom: -10px;
  z-index: 10;
  filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
}

.roulette-wheel {
  width: 100%;
  max-width: 300px;
  aspect-ratio: 1;
  position: relative;
  transition: transform 4s cubic-bezier(0.17, 0.67, 0.12, 0.99);
}

.roulette-wheel.spinning {
  transition: transform 4s cubic-bezier(0.17, 0.67, 0.12, 0.99);
}

#rouletteCanvas {
  width: 100%;
  height: 100%;
  border-radius: 50%;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3),
              0 0 0 8px var(--bg-surface),
              0 0 0 10px rgba(255, 255, 255, 0.1);
}

.roulette-spin-btn {
  max-width: 280px;
  font-size: 24px;
  padding: 20px;
  box-shadow: 0 6px 30px rgba(255, 107, 53, 0.4);
}

.roulette-spin-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.roulette-result-display {
  text-align: center;
  padding: 20px;
  background: var(--bg-card);
  border-radius: var(--radius);
  border: 2px solid var(--accent);
  animation: resultPop 0.5s ease;
  width: 100%;
  max-width: 300px;
}

@keyframes resultPop {
  0% { transform: scale(0.5); opacity: 0; }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); opacity: 1; }
}

.result-emoji {
  font-size: 56px;
  margin-bottom: 8px;
}

.result-text {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 28px;
  color: var(--accent2);
  word-break: break-word;
}

/* Mode Containers */
.lottery-mode-container,
.roulette-mode-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 12px;
  overflow-y: auto;
}

/* ========================================= */
/* UP DOWN CSS */
/* ========================================= */
.updown-top-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 14px;
  background: var(--bg-card);
  border-radius: var(--radius-sm);
}

.updown-title {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 20px;
  color: var(--gold);
}

.updown-turn-name {
  font-size: 15px;
  font-weight: 700;
  color: var(--accent2);
}

.updown-table {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 16px;
  background: linear-gradient(135deg, #1a5f2f, #0f4520);
  border-radius: var(--radius);
  margin: 0 12px;
  position: relative;
  min-height: 300px;
}

.updown-deck-count {
  position: absolute;
  top: 12px;
  right: 12px;
  font-size: 13px;
  font-weight: 700;
  color: rgba(255,255,255,0.7);
  background: rgba(0,0,0,0.3);
  padding: 6px 12px;
  border-radius: 20px;
}

.updown-cards-row {
  display: flex;
  gap: 20px;
  align-items: flex-end;
  margin-bottom: 20px;
}

.updown-card-slot {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.updown-current-slot {
  transform: scale(1.3);
}

.updown-card-label {
  font-size: 11px;
  font-weight: 700;
  color: rgba(255,255,255,0.6);
  text-transform: uppercase;
}

.updown-card {
  width: 70px;
  height: 100px;
  border-radius: 8px;
  position: relative;
  perspective: 1000px;
  cursor: pointer;
}

.updown-card-inner {
  position: relative;
  width: 100%;
  height: 100%;
  transition: transform 0.6s;
  transform-style: preserve-3d;
}

.updown-card.flipped .updown-card-inner {
  transform: rotateY(180deg);
}

.updown-card-front,
.updown-card-back-face {
  position: absolute;
  width: 100%;
  height: 100%;
  border-radius: 8px;
  backface-visibility: hidden;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

.updown-card-front {
  background: white;
  color: #1a1a2e;
  border: 3px solid #ddd;
  font-weight: 900;
  font-size: 32px;
  transform: rotateY(180deg);
}

.updown-card-front.red {
  color: #d32f2f;
  border-color: #ffcdd2;
}

.updown-card-front.black {
  color: #1a1a2e;
  border-color: #ccc;
}

.updown-card-front .updown-card-rank {
  font-size: 32px;
  line-height: 1;
  margin-bottom: 4px;
}

.updown-card-front .updown-card-suit {
  font-size: 24px;
  line-height: 1;
}

.updown-card-back-face {
  background: linear-gradient(135deg, #8b0000, #dc143c);
  border: 3px solid #b22222;
  font-size: 48px;
  color: rgba(255,255,255,0.3);
}

.updown-card-placeholder {
  width: 70px;
  height: 100px;
  border-radius: 8px;
  background: rgba(255,255,255,0.05);
  border: 2px dashed rgba(255,255,255,0.2);
}

.updown-result {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 28px;
  text-align: center;
  min-height: 40px;
  animation: resultPop 0.4s ease;
}

@keyframes resultPop {
  0% { transform: scale(0); opacity: 0; }
  50% { transform: scale(1.2); }
  100% { transform: scale(1); opacity: 1; }
}

.updown-penalty-list {
  padding: 10px 16px;
  background: var(--bg-card);
  border-radius: var(--radius-sm);
  margin: 0 12px;
  max-height: 100px;
  overflow-y: auto;
}

#updownPenaltyItems {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.updown-penalty-item {
  font-size: 12px;
  color: var(--text-dim);
  padding: 4px 8px;
  background: var(--bg-surface);
  border-radius: 6px;
}

.updown-action-area {
  padding: 12px 16px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.updown-choice-buttons {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

.updown-btn {
  padding: 20px;
  border: none;
  border-radius: var(--radius-sm);
  font-family: 'Black Han Sans', sans-serif;
  font-size: 20px;
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

.updown-btn:active {
  transform: scale(0.95);
}

.updown-btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.updown-btn-up {
  background: linear-gradient(135deg, #2d6a4f, #40916c);
  color: white;
}

.updown-btn-down {
  background: linear-gradient(135deg, #264653, #2a9d8f);
  color: white;
}

.updown-bet-area {
  display: flex;
  gap: 8px;
  align-items: center;
}

.updown-bet-input {
  flex: 1;
  padding: 10px 12px;
  background: var(--bg-surface);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: var(--radius-sm);
  color: var(--text);
  font-size: 13px;
  font-family: inherit;
  outline: none;
}

.updown-bet-input:focus {
  border-color: var(--accent);
}

.updown-btn-bet {
  padding: 10px 16px;
  background: linear-gradient(135deg, #8b4513, #a0522d);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  font-family: 'Black Han Sans', sans-serif;
  font-size: 14px;
  cursor: pointer;
  white-space: nowrap;
  transition: all 0.15s;
}

.updown-btn-bet:active {
  transform: scale(0.95);
}

.updown-special-area {
  padding: 16px;
  background: var(--bg-card);
  border-radius: var(--radius);
  margin: 0 12px;
  border: 2px solid var(--accent);
  animation: specialGlow 2s ease infinite;
}

@keyframes specialGlow {
  0%, 100% { box-shadow: 0 0 10px rgba(255,107,53,0.3); }
  50% { box-shadow: 0 0 20px rgba(255,107,53,0.6); }
}

.updown-special-title {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 18px;
  color: var(--accent);
  margin-bottom: 6px;
}

.updown-special-desc {
  font-size: 12px;
  color: var(--text-dim);
  margin-bottom: 12px;
  line-height: 1.4;
}

.updown-player-select {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  margin-bottom: 12px;
  max-height: 120px;
  overflow-y: auto;
}

.updown-player-option {
  padding: 10px 8px;
  background: var(--bg-surface);
  border: 2px solid transparent;
  border-radius: var(--radius-sm);
  text-align: center;
  cursor: pointer;
  transition: all 0.2s;
  font-size: 12px;
  font-weight: 700;
}

.updown-player-option:active {
  transform: scale(0.95);
}

.updown-player-option.selected {
  border-color: var(--accent2);
  background: rgba(0,229,255,0.15);
}

.updown-player-option .player-avatar-sm {
  margin: 0 auto 4px;
}

.updown-btn-special {
  width: 100%;
  padding: 14px;
  background: linear-gradient(135deg, var(--accent), #ff8f5a);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  font-family: 'Black Han Sans', sans-serif;
  font-size: 16px;
  cursor: pointer;
  transition: all 0.15s;
}

.updown-btn-special:active {
  transform: scale(0.97);
}

.updown-btn-king {
  background: linear-gradient(135deg, #c1121f, #780000);
}

.updown-penalty-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(10,10,18,0.95);
  z-index: 150;
  align-items: center;
  justify-content: center;
  padding: 24px;
}

.updown-penalty-modal.active {
  display: flex;
}

.updown-penalty-content {
  background: var(--bg-card);
  border-radius: var(--radius);
  padding: 24px;
  max-width: 360px;
  width: 100%;
  text-align: center;
  border: 2px solid var(--danger);
}

.updown-penalty-title {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 32px;
  color: var(--danger);
  margin-bottom: 12px;
}

.updown-penalty-text {
  font-size: 20px;
  font-weight: 700;
  color: var(--text);
  margin-bottom: 8px;
  padding: 12px;
  background: var(--bg-surface);
  border-radius: var(--radius-sm);
}

.updown-penalty-who {
  font-size: 14px;
  color: var(--text-dim);
  margin-bottom: 16px;
}

.updown-btn-accept,
.updown-btn-reject {
  width: 100%;
  padding: 14px;
  border: none;
  border-radius: var(--radius-sm);
  font-family: 'Black Han Sans', sans-serif;
  font-size: 16px;
  cursor: pointer;
  transition: all 0.15s;
  margin-bottom: 8px;
}

.updown-btn-accept {
  background: var(--bg-surface);
  color: var(--text);
  border: 1px solid rgba(255,255,255,0.1);
}

.updown-btn-reject {
  background: linear-gradient(135deg, var(--danger), #ff4569);
  color: white;
}

.updown-btn-accept:active,
.updown-btn-reject:active {
  transform: scale(0.97);
}

/* ============================== */
/* YAHTZEE CSS */
/* ============================== */
#yahtzeeGame {
  padding: 10px;
  gap: 8px;
  background: linear-gradient(135deg, #5d4037, #6d4c41, #795548);
  overflow-y: auto;
}

.yahtzee-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: var(--bg-card);
  border-radius: var(--radius-sm);
  z-index: 10;
}

.yahtzee-turn-info {
  text-align: center;
  flex: 1;
}

.yahtzee-turn-text {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 16px;
  color: var(--text);
}

.yahtzee-current-player {
  font-size: 11px;
  color: var(--text-dim);
  margin-top: 2px;
}

.yahtzee-rolls-left {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 18px;
  color: var(--accent2);
  min-width: 60px;
  text-align: right;
}

.yahtzee-players-bar {
  display: flex;
  justify-content: center;
  gap: 8px;
  padding: 8px;
  background: var(--bg-card);
  border-radius: var(--radius-sm);
  flex-wrap: wrap;
}

.yahtzee-player-mini {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 3px;
  padding: 6px;
  background: var(--bg-surface);
  border-radius: var(--radius-sm);
  border: 2px solid transparent;
  min-width: 55px;
}

.yahtzee-player-mini.active {
  border-color: var(--accent);
  box-shadow: 0 0 10px rgba(255,107,53,0.3);
}

.yahtzee-player-mini-avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
}

.yahtzee-player-mini-name {
  font-size: 10px;
  font-weight: 700;
  max-width: 55px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.yahtzee-player-mini-score {
  font-size: 11px;
  color: var(--gold);
  font-weight: 700;
}

.yahtzee-dice-area {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  padding: 16px;
  background: rgba(10,10,18,0.4);
  border-radius: var(--radius);
  border: 2px solid rgba(255,255,255,0.1);
}

.yahtzee-dice-container {
  display: flex;
  gap: 8px;
  justify-content: center;
  flex-wrap: wrap;
}

.yahtzee-die {
  width: 60px;
  height: 60px;
  cursor: pointer;
  perspective: 1000px;
}

.yahtzee-die-inner {
  width: 100%;
  height: 100%;
  transition: transform 0.3s;
}

.yahtzee-die.held .yahtzee-die-inner {
  transform: scale(0.92);
}

.yahtzee-die-face {
  width: 100%;
  height: 100%;
  background: white;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  display: grid;
  grid-template-areas:
    "a . c"
    "e g f"
    "d . b";
  padding: 6px;
  border: 3px solid transparent;
  transition: border-color 0.2s;
}

.yahtzee-die.held .yahtzee-die-face {
  border-color: #2196F3;
  box-shadow: 0 0 0 2px #2196F3, 0 4px 12px rgba(0,0,0,0.3);
}

.yahtzee-die.rolling .yahtzee-die-inner {
  animation: yahBounce 0.5s ease-in-out;
}

@keyframes yahBounce {
  0%, 100% { transform: translateY(0) rotate(0deg); }
  25% { transform: translateY(-15px) rotate(90deg); }
  50% { transform: translateY(0) rotate(180deg); }
  75% { transform: translateY(-10px) rotate(270deg); }
}

.pip {
  display: block;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #1a1a2e;
}

.yahtzee-die-face[data-value="1"] .pip:nth-child(1) { grid-area: g; }

.yahtzee-die-face[data-value="2"] .pip:nth-child(1) { grid-area: a; }
.yahtzee-die-face[data-value="2"] .pip:nth-child(2) { grid-area: b; }

.yahtzee-die-face[data-value="3"] .pip:nth-child(1) { grid-area: a; }
.yahtzee-die-face[data-value="3"] .pip:nth-child(2) { grid-area: g; }
.yahtzee-die-face[data-value="3"] .pip:nth-child(3) { grid-area: b; }

.yahtzee-die-face[data-value="4"] .pip:nth-child(1) { grid-area: a; }
.yahtzee-die-face[data-value="4"] .pip:nth-child(2) { grid-area: c; }
.yahtzee-die-face[data-value="4"] .pip:nth-child(3) { grid-area: d; }
.yahtzee-die-face[data-value="4"] .pip:nth-child(4) { grid-area: b; }

.yahtzee-die-face[data-value="5"] .pip:nth-child(1) { grid-area: a; }
.yahtzee-die-face[data-value="5"] .pip:nth-child(2) { grid-area: c; }
.yahtzee-die-face[data-value="5"] .pip:nth-child(3) { grid-area: g; }
.yahtzee-die-face[data-value="5"] .pip:nth-child(4) { grid-area: d; }
.yahtzee-die-face[data-value="5"] .pip:nth-child(5) { grid-area: b; }

.yahtzee-die-face[data-value="6"] .pip:nth-child(1) { grid-area: a; }
.yahtzee-die-face[data-value="6"] .pip:nth-child(2) { grid-area: c; }
.yahtzee-die-face[data-value="6"] .pip:nth-child(3) { grid-area: e; }
.yahtzee-die-face[data-value="6"] .pip:nth-child(4) { grid-area: f; }
.yahtzee-die-face[data-value="6"] .pip:nth-child(5) { grid-area: d; }
.yahtzee-die-face[data-value="6"] .pip:nth-child(6) { grid-area: b; }

.yahtzee-roll-hint {
  font-size: 11px;
  color: var(--text-dim);
  text-align: center;
}

.yahtzee-roll-btn {
  background: linear-gradient(135deg, #2196F3, #1976D2);
  max-width: 240px;
}

.yahtzee-roll-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.yahtzee-scorecard-area {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding: 12px;
  background: var(--bg-card);
  border-radius: var(--radius);
  border: 1px solid rgba(255,255,255,0.06);
  flex: 1;
  overflow-y: auto;
}

.yahtzee-scorecard-title {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 16px;
  text-align: center;
  color: var(--text);
  margin-bottom: 4px;
}

.yahtzee-score-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 13px;
}

.yahtzee-score-table th {
  background: var(--bg-surface);
  padding: 8px;
  text-align: left;
  font-weight: 700;
  border-bottom: 2px solid rgba(255,255,255,0.1);
}

.yahtzee-score-table th:last-child {
  text-align: center;
  width: 70px;
}

.yahtzee-score-row {
  cursor: pointer;
  transition: background 0.2s;
}

.yahtzee-score-row:hover {
  background: rgba(255,255,255,0.03);
}

.yahtzee-score-row.filled {
  opacity: 0.6;
  cursor: not-allowed;
}

.yahtzee-score-row.selected {
  background: rgba(255,152,0,0.2);
  border-left: 3px solid #FF9800;
}

.yahtzee-score-row.preview {
  background: rgba(33,150,243,0.15);
}

.yahtzee-score-row td {
  padding: 8px;
  border-bottom: 1px solid rgba(255,255,255,0.05);
}

.yahtzee-cat-name {
  font-weight: 600;
}

.yahtzee-cat-score {
  text-align: center;
  font-weight: 700;
  color: var(--text);
}

.yahtzee-score-row.preview .yahtzee-cat-score {
  color: var(--accent2);
}

.yahtzee-score-row.filled .yahtzee-cat-score {
  color: var(--text-dim);
}

.yahtzee-subtotal-row,
.yahtzee-bonus-row,
.yahtzee-total-row {
  background: rgba(255,255,255,0.04);
  font-weight: 700;
}

.yahtzee-subtotal-row td,
.yahtzee-bonus-row td,
.yahtzee-total-row td {
  padding: 8px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  text-align: left;
}

.yahtzee-subtotal-row td:last-child,
.yahtzee-bonus-row td:last-child,
.yahtzee-total-row td:last-child {
  text-align: center;
  color: var(--gold);
  font-family: 'Black Han Sans', sans-serif;
}

.yahtzee-divider-row {
  height: 8px;
  background: transparent;
}

.yahtzee-divider-row td {
  border: none;
}

.yahtzee-score-btn {
  background: linear-gradient(135deg, #FF9800, #F57C00);
  color: white;
  max-width: 240px;
  margin: 0 auto;
}

.yahtzee-game-over {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(10,10,18,0.95);
  z-index: 100;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 24px;
  gap: 16px;
}

.yahtzee-final-scores {
  background: var(--bg-card);
  border-radius: var(--radius);
  padding: 20px;
  width: 100%;
  max-width: 340px;
}

.yahtzee-final-title {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 32px;
  text-align: center;
  margin-bottom: 16px;
  background: linear-gradient(135deg, var(--gold), var(--accent));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.yahtzee-rankings {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.yahtzee-rank-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  background: var(--bg-surface);
  border-radius: var(--radius-sm);
  border-left: 3px solid transparent;
}

.yahtzee-rank-item.first {
  border-left-color: var(--gold);
  background: rgba(255,215,0,0.08);
}

.yahtzee-rank-item.second {
  border-left-color: #C0C0C0;
}

.yahtzee-rank-item.third {
  border-left-color: #CD7F32;
}

.yahtzee-rank-number {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 20px;
  color: var(--text-dim);
  min-width: 25px;
}

.yahtzee-rank-avatar {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
}

.yahtzee-rank-info {
  flex: 1;
}

.yahtzee-rank-name {
  font-weight: 700;
  font-size: 15px;
}

.yahtzee-rank-score {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 18px;
  color: var(--gold);
}

/* ===== E CARD CSS ===== */
#ecardGame {
  background: linear-gradient(135deg, #0a4d0a 0%, #064206 100%);
  padding: 12px;
  gap: 8px;
}

.ecard-top-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: rgba(20, 20, 42, 0.8);
  border-radius: var(--radius-sm);
  border: 1px solid rgba(255, 215, 0, 0.2);
}

.ecard-title {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 18px;
  color: var(--gold);
  text-shadow: 0 2px 4px rgba(0,0,0,0.5);
}

.ecard-round {
  font-size: 13px;
  font-weight: 700;
  color: var(--text-dim);
}

.ecard-score {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 16px;
  padding: 12px;
  background: rgba(20, 20, 42, 0.6);
  border-radius: var(--radius-sm);
  border: 1px solid rgba(255, 215, 0, 0.15);
}

.score-item {
  display: flex;
  align-items: center;
  gap: 8px;
}

.score-icon {
  font-size: 28px;
}

.score-value {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 32px;
  color: var(--gold);
  text-shadow: 0 2px 8px rgba(255, 215, 0, 0.4);
}

.score-divider {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 32px;
  color: var(--text-dim);
}

.ecard-role-display {
  display: flex;
  justify-content: center;
  padding: 8px;
}

.role-badge {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 20px;
  background: rgba(20, 20, 42, 0.8);
  border-radius: 20px;
  border: 2px solid var(--gold);
  box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
}

.role-icon {
  font-size: 32px;
}

.role-text {
  font-weight: 700;
  font-size: 15px;
  color: var(--text);
}

.role-text span {
  color: var(--gold);
  font-family: 'Black Han Sans', sans-serif;
  font-size: 17px;
}

.ecard-opponent-area {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 12px;
  background: rgba(20, 20, 42, 0.5);
  border-radius: var(--radius-sm);
  min-height: 120px;
}

.ecard-opponent-area .opponent-info {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
}

.ecard-opponent-area .opponent-avatar {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 28px;
  border: 2px solid rgba(255, 255, 255, 0.2);
}

.ecard-opponent-area .opponent-name {
  font-weight: 700;
  font-size: 14px;
}

.opponent-cards-count {
  font-size: 12px;
  color: var(--text-dim);
}

.opponent-played-card {
  margin-top: 8px;
}

.ecard-battle-area {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 16px;
  padding: 20px;
  background: rgba(20, 20, 42, 0.7);
  border-radius: var(--radius);
  border: 2px solid var(--gold);
  margin: 8px 0;
  min-height: 140px;
}

.battle-card {
  transform: scale(1.1);
}

.battle-vs {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 24px;
  color: var(--accent);
  text-shadow: 0 0 10px rgba(255, 107, 53, 0.6);
}

.ecard-result-text {
  text-align: center;
  font-family: 'Black Han Sans', sans-serif;
  font-size: 20px;
  color: var(--gold);
  padding: 8px;
  min-height: 28px;
  text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
}

.ecard-my-cards-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 8px;
  min-height: 0;
}

.my-cards-label {
  text-align: center;
  font-size: 13px;
  font-weight: 700;
  color: var(--text-dim);
}

.ecard-cards-hand {
  display: flex;
  justify-content: center;
  align-items: flex-end;
  gap: -20px;
  padding: 12px 8px;
  flex: 1;
  min-height: 0;
}

.ecard-card {
  width: 70px;
  height: 100px;
  border-radius: 10px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-weight: 900;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  margin: 0 -10px;
}

.ecard-card:hover {
  transform: translateY(-15px) scale(1.05);
  z-index: 10;
}

.ecard-card.selected {
  transform: translateY(-20px) scale(1.08);
  z-index: 11;
  box-shadow: 0 8px 20px rgba(255, 215, 0, 0.6);
}

.ecard-card-emperor {
  background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
  border: 3px solid #b8860b;
  color: #1a1a2e;
}

.ecard-card-citizen {
  background: linear-gradient(135deg, #c0c0c0 0%, #e8e8e8 100%);
  border: 3px solid #808080;
  color: #1a1a2e;
}

.ecard-card-slave {
  background: linear-gradient(135deg, #4a4a4a 0%, #6a6a6a 100%);
  border: 3px solid #2a2a2a;
  color: #e8e8f0;
}

.ecard-card-dummy {
  background: linear-gradient(135deg, #7a7a7a 0%, #9a9a9a 100%);
  border: 3px solid #5a5a5a;
  color: #1a1a2e;
}

.ecard-card-icon {
  font-size: 36px;
  margin-bottom: 4px;
}

.ecard-card-name {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 13px;
  letter-spacing: 1px;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

.ecard-card-back {
  background: linear-gradient(135deg, #8b0000 0%, #640000 100%);
  border: 3px solid #400000;
  position: relative;
  overflow: hidden;
}

.ecard-card-back::before {
  content: 'E';
  position: absolute;
  font-family: 'Black Han Sans', sans-serif;
  font-size: 56px;
  color: var(--gold);
  opacity: 0.3;
  text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
}

.ecard-bet-area, .ecard-bet-response {
  padding: 16px;
  background: rgba(20, 20, 42, 0.8);
  border-radius: var(--radius);
  border: 1px solid rgba(255, 215, 0, 0.2);
}

.bet-label {
  text-align: center;
  font-weight: 700;
  font-size: 14px;
  color: var(--text);
  margin-bottom: 12px;
}

.bet-controls {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 12px;
}

.bet-slider {
  flex: 1;
  -webkit-appearance: none;
  height: 6px;
  border-radius: 3px;
  background: var(--bg-surface);
  outline: none;
}

.bet-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: var(--gold);
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(255, 215, 0, 0.5);
}

.bet-amount {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 20px;
  color: var(--gold);
  min-width: 60px;
  text-align: right;
}

.bet-proposal {
  text-align: center;
  font-size: 15px;
  font-weight: 700;
  margin-bottom: 12px;
  color: var(--text);
}

.bet-proposal span {
  color: var(--gold);
  font-family: 'Black Han Sans', sans-serif;
  font-size: 18px;
}

.bet-buttons {
  display: flex;
  gap: 8px;
}

.ecard-action-buttons {
  display: flex;
  gap: 8px;
}

.ecard-waiting {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
  background: rgba(20, 20, 42, 0.6);
  border-radius: var(--radius-sm);
}

/* SUTDA CSS */

/* ===== 섯다 전체 레이아웃 ===== */
#sutdaGame {
  padding: 10px 12px;
  gap: 6px;
  background:
    radial-gradient(ellipse at 40% 60%, rgba(34,120,60,0.12) 0%, transparent 55%),
    radial-gradient(ellipse at 60% 40%, rgba(180,140,40,0.08) 0%, transparent 50%),
    linear-gradient(180deg, #0a0f0a 0%, #0d1a0d 40%, #0a0a12 100%);
  position: relative;
  overflow: hidden;
}

/* ===== 상단 바 ===== */
.sutda-top-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 12px;
  background: rgba(20,20,42,0.9);
  border-radius: var(--radius-sm);
  border: 1px solid rgba(255,215,0,0.15);
  z-index: 10;
}

.sutda-title-area {
  display: flex;
  align-items: center;
  gap: 10px;
}

.sutda-title-text {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 18px;
  background: linear-gradient(135deg, #ffd700, #ff6b35);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.sutda-pot-badge {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 14px;
  color: var(--gold);
  background: rgba(255,215,0,0.1);
  padding: 2px 10px;
  border-radius: 20px;
  border: 1px solid rgba(255,215,0,0.3);
}

.sutda-my-balance {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 14px;
  color: var(--accent2);
}

/* ===== 상대방 영역 ===== */
.sutda-opponents {
  display: flex;
  justify-content: center;
  gap: 8px;
  flex-wrap: wrap;
  width: 100%;
  padding: 4px 0;
  min-height: 90px;
}

.sutda-opp-slot {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  min-width: 60px;
  max-width: 80px;
  position: relative;
}

.sutda-opp-avatar {
  width: 38px;
  height: 38px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  position: relative;
  transition: all 0.3s;
}

.sutda-opp-avatar.active-turn {
  box-shadow: 0 0 0 3px var(--gold), 0 0 20px rgba(255,215,0,0.5);
  animation: sutda-pulse 1.5s ease infinite;
}

@keyframes sutda-pulse {
  0%, 100% { box-shadow: 0 0 0 3px var(--gold), 0 0 20px rgba(255,215,0,0.4); }
  50% { box-shadow: 0 0 0 5px var(--gold), 0 0 30px rgba(255,215,0,0.7); }
}

.sutda-opp-name {
  font-size: 10px;
  font-weight: 700;
  max-width: 70px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  text-align: center;
}

.sutda-opp-chips {
  font-size: 9px;
  color: var(--gold);
  font-weight: 700;
}

.sutda-opp-status {
  font-size: 9px;
  font-weight: 700;
  min-height: 14px;
}

.sutda-opp-status.die { color: var(--danger); }
.sutda-opp-status.call { color: var(--success); }
.sutda-opp-status.waiting { color: var(--text-dim); }
.sutda-opp-status.bet { color: var(--accent); }

.sutda-opp-cards {
  display: flex;
  gap: 2px;
}

.sutda-opp-slot.died {
  opacity: 0.3;
}

/* ===== 테이블 중앙 ===== */
.sutda-table {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 0;
}

.sutda-table-felt {
  width: 100%;
  max-width: 340px;
  padding: 20px;
  background:
    radial-gradient(ellipse at center, rgba(34,120,60,0.3) 0%, rgba(20,80,40,0.15) 60%, transparent 100%),
    linear-gradient(135deg, #1a3a1a, #0d260d);
  border-radius: 60px;
  border: 3px solid rgba(255,215,0,0.2);
  box-shadow:
    inset 0 2px 20px rgba(0,0,0,0.4),
    0 4px 30px rgba(0,0,0,0.3);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  position: relative;
}

.sutda-pot-center {
  text-align: center;
}

.sutda-pot-label {
  font-size: 11px;
  color: rgba(255,215,0,0.6);
  font-weight: 700;
}

.sutda-pot-amount {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 28px;
  color: var(--gold);
  text-shadow: 0 0 20px rgba(255,215,0,0.3);
}

.sutda-turn-indicator {
  font-size: 13px;
  color: var(--text);
  font-weight: 700;
  min-height: 20px;
}

/* ===== 화투패 CSS ===== */
.hwatu-card {
  width: 42px;
  height: 62px;
  border-radius: 6px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  transition: all 0.3s;
  overflow: hidden;
}

.hwatu-card-big {
  width: 72px;
  height: 108px;
  border-radius: 10px;
  box-shadow: 0 4px 16px rgba(0,0,0,0.5);
}

/* 카드 앞면 - 광 */
.hwatu-card.gwang {
  background: linear-gradient(180deg, #fff8e1 0%, #ffe082 30%, #fff8e1 100%);
  border: 2px solid #ffd54f;
}

.hwatu-card.gwang::before {
  content: '';
  position: absolute;
  top: 4px;
  right: 4px;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: radial-gradient(circle, #ff1744, #d50000);
  box-shadow: 0 0 6px rgba(255,23,68,0.6);
}

.hwatu-card-big.gwang::before {
  width: 20px;
  height: 20px;
  top: 6px;
  right: 6px;
  box-shadow: 0 0 10px rgba(255,23,68,0.7);
}

/* 카드 앞면 - 비광 */
.hwatu-card.normal {
  background: linear-gradient(180deg, #f5f5f5 0%, #e0e0e0 100%);
  border: 2px solid #90a4ae;
}

.hwatu-card.normal::before {
  content: '';
  position: absolute;
  top: 4px;
  right: 4px;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #546e7a;
}

.hwatu-card-big.normal::before {
  width: 14px;
  height: 14px;
  top: 6px;
  right: 6px;
}

/* 카드 숫자 */
.hwatu-num {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 22px;
  line-height: 1;
  z-index: 1;
}

.hwatu-card-big .hwatu-num {
  font-size: 36px;
}

.hwatu-card.gwang .hwatu-num {
  color: #bf360c;
  text-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

.hwatu-card.normal .hwatu-num {
  color: #263238;
}

/* 카드 월 표시 */
.hwatu-month {
  font-size: 8px;
  font-weight: 700;
  z-index: 1;
  opacity: 0.6;
}

.hwatu-card-big .hwatu-month {
  font-size: 11px;
}

.hwatu-card.gwang .hwatu-month { color: #bf360c; }
.hwatu-card.normal .hwatu-month { color: #455a64; }

/* 광 글자 */
.hwatu-gwang-text {
  position: absolute;
  bottom: 3px;
  font-size: 7px;
  font-weight: 900;
  color: #d50000;
  letter-spacing: -0.5px;
}

.hwatu-card-big .hwatu-gwang-text {
  bottom: 6px;
  font-size: 11px;
}

/* 카드 전통 문양 배경 */
.hwatu-card::after {
  content: '';
  position: absolute;
  inset: 3px;
  border: 1px solid rgba(0,0,0,0.06);
  border-radius: 4px;
  pointer-events: none;
}

.hwatu-card-big::after {
  inset: 5px;
  border-radius: 6px;
}

/* 카드 뒷면 */
.hwatu-card.back {
  background:
    repeating-linear-gradient(
      45deg,
      #b71c1c 0px,
      #b71c1c 4px,
      #c62828 4px,
      #c62828 8px
    );
  border: 2px solid #e53935;
}

.hwatu-card.back::before {
  content: '';
  position: absolute;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: rgba(0,0,0,0.2);
  border: 1px solid rgba(255,255,255,0.1);
}

.hwatu-card.back::after {
  inset: 2px;
  border: 1px solid rgba(255,255,255,0.15);
}

.hwatu-card-big.back::before {
  width: 32px;
  height: 32px;
}

/* 1월 광 특수 문양 (송학) */
.hwatu-card.m1.gwang {
  background: linear-gradient(180deg, #fff8e1 0%, #ffecb3 50%, #fff3e0 100%);
}

/* 3월 광 특수 문양 (사쿠라) */
.hwatu-card.m3.gwang {
  background: linear-gradient(180deg, #fce4ec 0%, #f8bbd0 50%, #fce4ec 100%);
}

/* 8월 광 특수 문양 (공산) */
.hwatu-card.m8.gwang {
  background: linear-gradient(180deg, #e8eaf6 0%, #c5cae9 50%, #e8eaf6 100%);
}

/* ===== 내 패 영역 ===== */
.sutda-my-area {
  width: 100%;
  padding: 10px 16px;
  background: rgba(20,20,42,0.9);
  border-radius: var(--radius);
  border: 1px solid rgba(255,215,0,0.1);
}

.sutda-my-info {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 6px;
}

.sutda-my-name {
  font-weight: 700;
  font-size: 14px;
}

.sutda-my-chips {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 16px;
  color: var(--gold);
}

.sutda-my-cards {
  display: flex;
  justify-content: center;
  gap: 12px;
  margin-bottom: 6px;
}

.sutda-my-rank {
  text-align: center;
  font-family: 'Black Han Sans', sans-serif;
  font-size: 20px;
  color: #ff1744;
  min-height: 26px;
  text-shadow: 0 0 10px rgba(255,23,68,0.4);
}

/* ===== 세륙 패널 ===== */
.sutda-seryuk-panel {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(10,10,18,0.92);
  z-index: 90;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 16px;
  padding: 24px;
}

.sutda-seryuk-title {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 28px;
  color: var(--gold);
}

.sutda-seryuk-desc {
  font-size: 13px;
  color: var(--text-dim);
  text-align: center;
}

.sutda-seryuk-buttons {
  display: flex;
  gap: 16px;
}

.sutda-seryuk-btn {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 24px 32px;
  border: 2px solid transparent;
  border-radius: var(--radius);
  font-family: 'Black Han Sans', sans-serif;
  font-size: 20px;
  cursor: pointer;
  transition: all 0.2s;
}

.sutda-seryuk-btn:active { transform: scale(0.95); }

.sutda-seryuk-push {
  background: linear-gradient(135deg, #1b5e20, #2e7d32);
  color: #a5d6a7;
  border-color: #4caf50;
}

.sutda-seryuk-chaos {
  background: linear-gradient(135deg, #b71c1c, #c62828);
  color: #ef9a9a;
  border-color: #f44336;
}

.sutda-seryuk-icon {
  font-size: 36px;
}

.sutda-seryuk-sub {
  font-size: 12px;
  opacity: 0.7;
}

/* ===== 배팅 버튼 바 ===== */
.sutda-action-bar {
  display: flex;
  gap: 5px;
  width: 100%;
  padding: 0 4px;
  flex-wrap: wrap;
}

.sutda-bet-btn {
  flex: 1;
  min-width: 0;
  padding: 12px 4px;
  border: none;
  border-radius: var(--radius-sm);
  font-family: 'Black Han Sans', sans-serif;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.15s;
  letter-spacing: 0.3px;
}

.sutda-bet-btn:active { transform: scale(0.95); }
.sutda-bet-btn:disabled { opacity: 0.3; cursor: not-allowed; }

.sutda-bet-10k {
  background: linear-gradient(135deg, #1565c0, #1976d2);
  color: white;
}

.sutda-bet-50k {
  background: linear-gradient(135deg, #1565c0, #42a5f5);
  color: white;
}

.sutda-bet-100k {
  background: linear-gradient(135deg, #0d47a1, #1565c0);
  color: white;
}

.sutda-bet-call {
  background: linear-gradient(135deg, #2e7d32, #43a047);
  color: white;
}

.sutda-bet-die {
  background: linear-gradient(135deg, #4e342e, #6d4c41);
  color: #bcaaa4;
}

.sutda-bet-allin {
  background: linear-gradient(135deg, #c62828, #e53935);
  color: white;
}

/* ===== 결과 오버레이 ===== */
.sutda-result-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(10,10,18,0.95);
  z-index: 100;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.sutda-result-overlay.active {
  display: flex;
}

.sutda-result-box {
  background: var(--bg-card);
  border-radius: var(--radius);
  border: 1px solid rgba(255,215,0,0.2);
  padding: 24px;
  width: 100%;
  max-width: 380px;
  text-align: center;
  max-height: 90vh;
  overflow-y: auto;
}

.sutda-result-title {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 32px;
  margin-bottom: 12px;
}

.sutda-result-winner {
  font-size: 16px;
  font-weight: 700;
  margin-bottom: 8px;
}

.sutda-result-rank {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 24px;
  color: #ff1744;
  margin-bottom: 12px;
}

.sutda-result-cards {
  display: flex;
  justify-content: center;
  gap: 10px;
  margin-bottom: 12px;
}

.sutda-result-pot {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 22px;
  color: var(--gold);
  margin-bottom: 16px;
}

.sutda-result-all-hands {
  text-align: left;
  font-size: 13px;
  border-top: 1px solid rgba(255,255,255,0.1);
  padding-top: 12px;
}

.sutda-result-hand-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 0;
  border-bottom: 1px solid rgba(255,255,255,0.04);
}

.sutda-result-hand-avatar {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  flex-shrink: 0;
}

.sutda-result-hand-name {
  flex: 1;
  font-weight: 700;
  font-size: 12px;
}

.sutda-result-hand-rank {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 13px;
  color: #ff1744;
}

.sutda-result-hand-cards {
  display: flex;
  gap: 3px;
}

.sutda-result-hand-cards .hwatu-card {
  width: 28px;
  height: 42px;
}

.sutda-result-hand-cards .hwatu-num {
  font-size: 14px;
}

.sutda-result-hand-cards .hwatu-month {
  font-size: 6px;
}

.sutda-result-hand-cards .hwatu-gwang-text {
  font-size: 5px;
  bottom: 1px;
}

.sutda-result-hand-row.winner-row {
  background: rgba(255,215,0,0.08);
  border-radius: 6px;
  padding: 6px 8px;
}

.sutda-result-hand-row.died-row {
  opacity: 0.4;
}

/* RACING CSS */
#racingGame {
  background: linear-gradient(180deg, #0a0a1a 0%, #1a1a2e 50%, #2a1a3a 100%);
  position: relative;
  overflow: hidden;
}

/* 모드 선택 */
.racing-mode-select {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  padding: 16px;
  gap: 20px;
}

.racing-mode-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.racing-mode-title {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 22px;
  color: var(--accent2);
}

.racing-mode-cards {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
  padding: 20px;
}

.racing-mode-card {
  background: var(--bg-card);
  border: 2px solid rgba(255,255,255,0.1);
  border-radius: var(--radius);
  padding: 24px 16px;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s;
}

.racing-mode-card:active {
  transform: scale(0.95);
  border-color: var(--accent2);
  background: linear-gradient(135deg, rgba(0,229,255,0.1), rgba(255,107,53,0.1));
}

.racing-mode-icon {
  font-size: 48px;
  margin-bottom: 12px;
}

.racing-mode-name {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 20px;
  margin-bottom: 8px;
  color: var(--text);
}

.racing-mode-desc {
  font-size: 12px;
  color: var(--text-dim);
  line-height: 1.4;
}

.racing-gyro-permission {
  display: flex;
  flex-direction: column;
  gap: 16px;
  padding: 20px;
}

.racing-info-box {
  background: var(--bg-surface);
  border-radius: var(--radius-sm);
  padding: 16px;
  display: flex;
  gap: 12px;
  align-items: center;
}

.racing-info-icon {
  font-size: 32px;
  flex-shrink: 0;
}

.racing-info-text {
  font-size: 14px;
  line-height: 1.5;
}

/* 게임 화면 */
.racing-game-area {
  width: 100%;
  height: 100%;
  position: relative;
  overflow: hidden;
}

/* HUD */
.racing-hud {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-between;
  padding: 16px;
  z-index: 100;
  pointer-events: none;
}

.racing-hud-left,
.racing-hud-center,
.racing-hud-right {
  background: rgba(10,10,18,0.8);
  backdrop-filter: blur(4px);
  border-radius: var(--radius-sm);
  padding: 8px 12px;
  border: 1px solid rgba(255,255,255,0.1);
}

.racing-speed,
.racing-distance,
.racing-rank {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
}

.racing-speed-label,
.racing-distance-label,
.racing-rank-label {
  font-size: 9px;
  color: var(--text-dim);
  font-weight: 700;
  letter-spacing: 1px;
}

.racing-speed-value,
.racing-distance-value {
  font-family: 'Courier New', monospace;
  font-size: 24px;
  font-weight: 900;
  color: #00ff00;
  line-height: 1;
  text-shadow: 0 0 8px rgba(0,255,0,0.5);
}

.racing-speed-unit,
.racing-distance-unit {
  font-size: 10px;
  color: var(--text-dim);
}

.racing-rank-value {
  font-size: 14px;
  font-weight: 700;
  color: var(--gold);
}

/* 배경 건물 */
.racing-bg-buildings {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 40%;
  z-index: 1;
  overflow: hidden;
}

.racing-building {
  position: absolute;
  background: rgba(20,20,42,0.8);
  border-left: 1px solid rgba(255,255,255,0.05);
  border-right: 1px solid rgba(255,255,255,0.05);
}

.racing-building::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background:
    repeating-linear-gradient(
      0deg,
      transparent,
      transparent 20px,
      rgba(255,255,255,0.03) 20px,
      rgba(255,255,255,0.03) 22px
    ),
    repeating-linear-gradient(
      90deg,
      transparent,
      transparent 15px,
      rgba(255,255,255,0.02) 15px,
      rgba(255,255,255,0.02) 17px
    );
}

/* 도로 */
.racing-road {
  position: absolute;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 90%;
  height: 70%;
  background: linear-gradient(180deg, #2a2a3a 0%, #1a1a2a 100%);
  perspective: 800px;
  transform-style: preserve-3d;
  border-left: 4px solid #444;
  border-right: 4px solid #444;
  z-index: 10;
}

/* 차선 라인 */
.racing-lane-line {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 2px;
  background: rgba(255,255,255,0.2);
  z-index: 2;
}

/* 차선 점선 */
.racing-lane-dashes {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 1;
}

.racing-dash {
  position: absolute;
  width: 8px;
  height: 30px;
  background: rgba(255,255,255,0.6);
  border-radius: 2px;
  animation: racingDashMove 1s linear infinite;
}

@keyframes racingDashMove {
  from {
    transform: translateY(-100px) perspective(800px) rotateX(45deg);
    opacity: 0;
  }
  to {
    transform: translateY(calc(100vh + 100px)) perspective(800px) rotateX(45deg);
    opacity: 1;
  }
}

/* 장애물 */
.racing-obstacles {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 5;
}

.racing-obstacle {
  position: absolute;
  width: 28%;
  height: 60px;
  transition: left 0.2s ease-out;
}

.racing-obstacle-car {
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #3d5afe 0%, #1e3af7 100%);
  border-radius: 8px 8px 4px 4px;
  box-shadow:
    0 4px 0 rgba(0,0,0,0.3),
    inset 0 -2px 4px rgba(0,0,0,0.2),
    inset 0 2px 4px rgba(255,255,255,0.2);
  position: relative;
}

.racing-obstacle-car::before {
  content: '';
  position: absolute;
  top: 15%;
  left: 10%;
  right: 10%;
  height: 40%;
  background: rgba(100,150,255,0.3);
  border-radius: 4px;
}

.racing-obstacle-truck {
  width: 100%;
  height: 80px;
  background: linear-gradient(135deg, #f44336 0%, #c62828 100%);
  border-radius: 8px 8px 4px 4px;
  box-shadow:
    0 4px 0 rgba(0,0,0,0.3),
    inset 0 -2px 4px rgba(0,0,0,0.2),
    inset 0 2px 4px rgba(255,255,255,0.2);
  position: relative;
}

.racing-obstacle-truck::before {
  content: '';
  position: absolute;
  top: 20%;
  left: 10%;
  right: 10%;
  height: 30%;
  background: rgba(255,150,150,0.3);
  border-radius: 4px;
}

/* 오토바이 */
.racing-bike {
  position: absolute;
  bottom: 60px;
  width: 28%;
  height: 60px;
  transition: left 0.3s ease-out;
  z-index: 20;
}

.racing-bike-body {
  width: 100%;
  height: 100%;
  font-size: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  filter: drop-shadow(0 4px 8px rgba(0,0,0,0.4));
}

/* 핸들바 UI */
.racing-handlebar {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 80px;
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  padding: 0 20px 10px;
  z-index: 50;
  pointer-events: none;
}

.racing-handlebar-left,
.racing-handlebar-right {
  width: 100px;
  height: 60px;
  background: linear-gradient(135deg, #444 0%, #222 100%);
  border-radius: 50% 50% 20px 20px;
  border: 3px solid #666;
  box-shadow:
    inset 0 2px 4px rgba(255,255,255,0.2),
    inset 0 -2px 4px rgba(0,0,0,0.5),
    0 4px 8px rgba(0,0,0,0.3);
  position: relative;
}

.racing-handlebar-left {
  transform: rotate(-15deg);
  transform-origin: bottom right;
}

.racing-handlebar-right {
  transform: rotate(15deg);
  transform-origin: bottom left;
}

.racing-handlebar-center {
  width: 40px;
  height: 20px;
  background: linear-gradient(135deg, #555 0%, #333 100%);
  border-radius: 10px;
  border: 2px solid #777;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

/* 터치 컨트롤 */
.racing-touch-controls {
  position: absolute;
  bottom: 100px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 12px;
  z-index: 60;
}

.racing-touch-btn {
  width: 60px;
  height: 60px;
  background: rgba(255,255,255,0.1);
  backdrop-filter: blur(4px);
  border: 2px solid rgba(255,255,255,0.2);
  border-radius: 50%;
  color: var(--text);
  font-size: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.15s;
}

.racing-touch-btn:active {
  background: rgba(0,229,255,0.3);
  border-color: var(--accent2);
  transform: scale(0.9);
}

/* 충돌 효과 */
.racing-crash-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255,0,0,0.3);
  opacity: 0;
  pointer-events: none;
  z-index: 90;
}

.racing-crash-overlay.active {
  animation: racingCrashShake 0.5s ease-out;
}

@keyframes racingCrashShake {
  0%, 100% {
    transform: translate(0, 0);
    opacity: 0;
  }
  10%, 30%, 50%, 70%, 90% {
    transform: translate(-10px, 0);
    opacity: 0.7;
  }
  20%, 40%, 60%, 80% {
    transform: translate(10px, 0);
    opacity: 0.7;
  }
}

/* 결과 화면 */
.racing-result-screen {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  padding: 20px;
  gap: 20px;
  overflow-y: auto;
  background: linear-gradient(180deg, rgba(10,10,26,0.95) 0%, rgba(26,26,46,0.95) 100%);
}

.racing-result-header {
  text-align: center;
  padding: 20px;
  background: var(--bg-card);
  border-radius: var(--radius);
  border: 1px solid rgba(255,255,255,0.1);
}

.racing-result-title {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 32px;
  background: linear-gradient(135deg, var(--accent2), var(--accent));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-bottom: 8px;
}

.racing-result-subtitle {
  font-size: 14px;
  color: var(--text-dim);
}

.racing-result-stats {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 12px;
}

.racing-result-stat {
  background: var(--bg-surface);
  border-radius: var(--radius-sm);
  padding: 16px 12px;
  text-align: center;
}

.racing-result-stat-label {
  font-size: 11px;
  color: var(--text-dim);
  margin-bottom: 6px;
}

.racing-result-stat-value {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 18px;
  color: var(--accent2);
}

.racing-result-rankings {
  background: var(--bg-card);
  border-radius: var(--radius);
  padding: 16px;
  border: 1px solid rgba(255,255,255,0.06);
}

.racing-result-rankings-title {
  font-size: 14px;
  font-weight: 700;
  color: var(--text-dim);
  margin-bottom: 12px;
  text-align: center;
}

.racing-result-rankings-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.racing-result-ranking-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px;
  background: var(--bg-surface);
  border-radius: var(--radius-sm);
  transition: all 0.2s;
}

.racing-result-ranking-item.first {
  background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,193,7,0.1));
  border: 1px solid rgba(255,215,0,0.3);
}

.racing-result-ranking-rank {
  font-family: 'Black Han Sans', sans-serif;
  font-size: 18px;
  color: var(--text-dim);
  width: 40px;
  text-align: center;
}

.racing-result-ranking-item.first .racing-result-ranking-rank {
  color: var(--gold);
  font-size: 20px;
}

.racing-result-ranking-avatar {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  flex-shrink: 0;
}

.racing-result-ranking-name {
  flex: 1;
  font-weight: 700;
  font-size: 14px;
}

.racing-result-ranking-distance {
  font-family: 'Courier New', monospace;
  font-size: 14px;
  font-weight: 700;
  color: var(--accent2);
}

</style>
</head>
<body>

<div class="toast" id="toast"></div>

<!-- LOADING -->
<div class="screen active" id="loadingScreen">
  <div class="logo-icon">🎲</div>
  <div class="logo-title">파티덱</div>
  <div class="loading-text" id="loadingText">연결 준비 중...</div>
  <div class="loading-bar"><div class="loading-bar-inner" id="loadingBar"></div></div>
</div>

<!-- MAIN MENU -->
<div class="screen" id="mainMenu">
  <div class="logo-area">
    <div class="logo-icon">🎲</div>
    <div class="logo-title">파티덱</div>
    <div class="logo-sub">서버 없이 즐기는 P2P 미니게임</div>
  </div>

  <div class="menu-card">
    <div class="profile-section">
      <div class="avatar" id="myAvatar" onclick="cycleAvatar()">😎</div>
      <div class="profile-info">
        <input class="input-field" id="nameInput" placeholder="닉네임 입력" maxlength="8" style="padding:10px 12px; font-size:15px; font-weight:700;">
        <div class="profile-stats" id="profileStats">전적 로딩 중...</div>
      </div>
    </div>
  </div>

  <button class="btn btn-primary" onclick="createRoom()">🏠 방 만들기</button>

  <div class="join-row">
    <input class="input-field" id="joinCodeInput" placeholder="방 코드 입력" maxlength="6" style="text-transform:uppercase; text-align:center; letter-spacing:4px; font-weight:700; flex:1;">
    <button class="btn btn-accent2 btn-small" onclick="joinRoom()" style="width:auto; padding:14px 20px;">참가</button>
  </div>

  <button class="btn btn-secondary" onclick="shareApp()" style="max-width:380px;">📱 앱 공유 (QR 코드)</button>

  <div class="ad-banner">📢 광고 영역 (AdSense / AdMob)</div>
</div>

<!-- LOBBY -->
<div class="screen" id="lobby">
  <div class="lobby-header">
    <button class="back-btn" onclick="leaveLobby()">←</button>
    <div style="font-family:'Black Han Sans'; font-size:20px;">대기실</div>
    <div style="width:40px;"></div>
  </div>

  <div class="room-code-display">
    <div class="room-code-label">방 코드를 친구에게 공유하세요</div>
    <div class="room-code" id="roomCodeDisplay" onclick="copyRoomCode()">------</div>
    <div class="room-code-hint">탭하여 복사</div>
    <div class="share-btn-row">
      <button class="share-btn" onclick="copyRoomCode()">📋 코드 복사</button>
      <button class="share-btn" onclick="shareLink()">🔗 링크 공유</button>
    </div>
    <div id="qrCodeDisplay" style="margin:10px auto;width:180px;height:180px;"></div>
  </div>

  <div class="players-section">
    <div class="players-title">플레이어 (<span id="playerCount">0</span>/14)</div>
    <div class="player-list" id="playerList"></div>
  </div>

  <div class="game-select" id="gameSelectArea" style="display:none;">
    <div class="game-select-title">게임 선택 (호스트만 가능)</div>
    <div class="game-options" style="grid-template-columns: repeat(3, 1fr);">
      <div class="game-option selected" data-game="poker" onclick="selectGame(this)">
        <span class="game-emoji">🃏</span>포커
      </div>
      <div class="game-option" data-game="mafia" onclick="selectGame(this)">
        <span class="game-emoji">🕵️</span>마피아
      </div>
      <div class="game-option" data-game="sutda" onclick="selectGame(this)">
        <span class="game-emoji">🎴</span>섯다
      </div>
      <div class="game-option" data-game="quickdraw" onclick="selectGame(this)">
        <span class="game-emoji">🤠</span>총잡이
      </div>
      <div class="game-option" data-game="roulette" onclick="selectGame(this)">
        <span class="game-emoji">🔫</span>룰렛
      </div>
      <div class="game-option" data-game="racing" onclick="selectGame(this)">
        <span class="game-emoji">🏍️</span>레이싱
      </div>
      <div class="game-option" data-game="lottery" onclick="selectGame(this)">
        <span class="game-emoji">🎰</span>뽑기
      </div>
      <div class="game-option" data-game="ecard" onclick="selectGame(this)">
        <span class="game-emoji">👑</span>E카드
      </div>
      <div class="game-option" data-game="yahtzee" onclick="selectGame(this)">
        <span class="game-emoji">🎲</span>야추
      </div>
      <div class="game-option" data-game="updown" onclick="selectGame(this)">
        <span class="game-emoji">🃏</span>업다운
      </div>
      <div class="game-option" data-game="truth" onclick="selectGame(this)">
        <span class="game-emoji">⭕</span>진실게임
      </div>
    </div>
  </div>

  <button class="btn btn-primary" id="startGameBtn" style="display:none;" onclick="startGame()">🎮 게임 시작</button>

  <div id="waitingMsg" style="text-align:center; color:var(--text-dim); font-size:14px; padding:10px;">
    <div class="spinner"></div>
    <div style="margin-top:8px;">호스트가 게임을 시작하길 대기 중...</div>
  </div>
</div>

<!-- POKER -->
<div class="screen" id="pokerGame">
  <div class="poker-top-bar">
    <div class="pot-display">💰 <span id="potAmount">0</span></div>
    <div class="round-display" id="roundDisplay">프리플랍</div>
    <button class="back-btn" style="font-size:18px;padding:4px;" onclick="leaveGame()">✕</button>
  </div>
  <div class="opponents-area" id="opponentsArea"></div>
  <div class="table-area">
    <div class="community-cards" id="communityCards"></div>
  </div>
  <div class="my-hand-area">
    <div class="my-info-row">
      <div class="my-chips" id="myChipsDisplay">💰 1000</div>
      <div class="my-hand-label">내 패</div>
    </div>
    <div class="my-cards" id="myCardsDisplay"></div>
    <div class="hand-rank-display" id="handRankDisplay"></div>
  </div>
  <div class="raise-slider-area" id="raiseSliderArea">
    <input type="range" class="raise-slider" id="raiseSlider" min="0" max="1000" value="100">
    <div class="raise-amount" id="raiseAmountDisplay">100</div>
    <button class="raise-confirm" onclick="confirmRaise()">확인</button>
  </div>
  <div class="action-bar" id="actionBar">
    <button class="action-btn btn-fold" onclick="pokerAction('fold')">폴드</button>
    <button class="action-btn btn-check" id="checkCallBtn" onclick="pokerAction('check')">체크</button>
    <button class="action-btn btn-raise" onclick="showRaiseSlider()">레이즈</button>
    <button class="action-btn btn-allin" onclick="pokerAction('allin')">올인</button>
  </div>
</div>

<!-- MAFIA FULL VERSION -->
<div class="screen" id="mafiaGame">
  <!-- Top Bar -->
  <div class="mf-topbar">
    <div class="mf-topbar-left">
      <button class="mf-back-btn" onclick="mfLeaveGame()">✕</button>
      <div class="mf-phase-badge day" id="mfPhaseBadge">
        <span id="mfPhaseIcon">☀️</span>
        <span id="mfPhaseText">낮</span>
      </div>
    </div>
    <div class="mf-day-counter" id="mfDayCounter">1일차</div>
    <div class="mf-timer-box" id="mfTimerBox">
      <span>⏱</span>
      <span id="mfTimer">180</span>
    </div>
  </div>

  <!-- Role Banner -->
  <div class="mf-role-banner team-citizen" id="mfRoleBanner">
    <div class="mf-role-emoji" id="mfRoleEmoji">👤</div>
    <div class="mf-role-info">
      <div class="mf-role-name citizen-color" id="mfRoleName">시민</div>
      <div class="mf-role-desc" id="mfRoleDesc">마피아를 찾아 투표하세요</div>
    </div>
  </div>

  <!-- Main Scrollable Content -->
  <div class="mf-content" id="mfContent">
    <!-- Dynamic content injected by JS:
         - Player grid
         - Night action panel
         - Chat panel (mafia/spy)
         - Vote status panel
         - Events list
         - Spectator mode
         - Lover reveal
         etc.
    -->
  </div>

  <!-- Bottom Action Area -->
  <div class="mf-action-area" id="mfActionArea">
    <div class="mf-message-box" id="mfMessageBox"></div>
    <div class="mf-btn-row" id="mfBtnRow">
      <!-- Buttons injected dynamically -->
    </div>
  </div>

  <!-- Result Overlay (hidden by default) -->
  <div class="mf-result-overlay" id="mfResultOverlay" style="display:none;">
    <div class="mf-result-title" id="mfResultTitle"></div>
    <div class="mf-result-subtitle" id="mfResultSubtitle"></div>
    <div class="mf-result-roles" id="mfResultRoles"></div>
    <button class="mf-result-close-btn" onclick="mfCloseResult()">로비로 돌아가기</button>
  </div>
</div>

<!-- TRUTH GAME -->
<div class="screen" id="truthGame">
  <!-- 상단 바 -->
  <div class="truth-top-bar">
    <button class="back-btn" style="font-size:18px;padding:4px;" onclick="leaveGame()">✕</button>
    <div class="truth-round-display">
      <span class="truth-round-badge" id="truthRoundBadge">ROUND 1</span>
    </div>
    <div class="truth-questioner-display" id="truthQuestionerDisplay">질문자: ---</div>
  </div>

  <!-- 메인 콘텐츠 영역 -->
  <div class="truth-content">

    <!-- Phase: question (질문자 입력) -->
    <div class="truth-phase-area" id="truthQuestionInputArea" style="display:none;">
      <div class="truth-your-turn-badge">✨ 당신의 차례입니다</div>
      <div class="truth-question-box">
        <textarea
          class="truth-textarea"
          id="truthQuestionInput"
          placeholder="질문을 입력하세요...&#10;예: 여기서 OO를 이성적으로 좋아하는 사람이 있다?"
          maxlength="200"
          rows="3"
        ></textarea>
        <div class="truth-char-count"><span id="truthCharCount">0</span>/200</div>
      </div>
      <button class="btn btn-primary truth-submit-btn" onclick="submitTruthQuestion()">
        📨 질문 제출
      </button>
    </div>

    <!-- Phase: question (대기 화면 - 질문자가 아닌 경우) -->
    <div class="truth-phase-area" id="truthWaitQuestionArea" style="display:none;">
      <div class="truth-waiting-icon">🤔</div>
      <div class="truth-waiting-text" id="truthWaitingText">질문을 기다리는 중...</div>
      <div class="truth-waiting-sub" id="truthWaitingSubText">질문자가 질문을 작성하고 있습니다</div>
      <div class="truth-dots-loader">
        <span></span><span></span><span></span>
      </div>
    </div>

    <!-- Phase: voting (질문 표시 + O/X 투표) -->
    <div class="truth-phase-area" id="truthVotingArea" style="display:none;">
      <div class="truth-question-display">
        <div class="truth-question-label">Q.</div>
        <div class="truth-question-text" id="truthQuestionText">질문 내용</div>
      </div>

      <!-- 투표 버튼 영역 -->
      <div class="truth-vote-buttons" id="truthVoteButtons">
        <button class="truth-vote-btn truth-vote-o" id="truthBtnO" onclick="castTruthVote('O')">
          <span class="truth-vote-symbol">O</span>
          <span class="truth-vote-label">예</span>
        </button>
        <button class="truth-vote-btn truth-vote-x" id="truthBtnX" onclick="castTruthVote('X')">
          <span class="truth-vote-symbol">✕</span>
          <span class="truth-vote-label">아니오</span>
        </button>
      </div>

      <!-- 투표 완료 후 대기 -->
      <div class="truth-vote-waiting" id="truthVoteWaiting" style="display:none;">
        <div class="truth-voted-badge" id="truthVotedBadge">✅ 투표 완료</div>
        <div class="truth-vote-progress">
          <div class="truth-progress-bar">
            <div class="truth-progress-fill" id="truthProgressFill" style="width:0%"></div>
          </div>
          <div class="truth-progress-text" id="truthProgressText">투표 중... (0/0명 완료)</div>
        </div>
      </div>
    </div>

    <!-- Phase: result (결과 표시) -->
    <div class="truth-phase-area" id="truthResultArea" style="display:none;">
      <div class="truth-question-display truth-question-display-small">
        <div class="truth-question-label">Q.</div>
        <div class="truth-question-text" id="truthResultQuestionText">질문 내용</div>
      </div>

      <div class="truth-result-container">
        <div class="truth-result-title">투표 결과</div>

        <!-- O 결과 -->
        <div class="truth-result-row">
          <div class="truth-result-icon truth-result-icon-o">O</div>
          <div class="truth-result-info">
            <div class="truth-result-count" id="truthResultOCount">0명</div>
            <div class="truth-result-dots" id="truthResultODots"></div>
          </div>
        </div>

        <!-- X 결과 -->
        <div class="truth-result-row">
          <div class="truth-result-icon truth-result-icon-x">✕</div>
          <div class="truth-result-info">
            <div class="truth-result-count" id="truthResultXCount">0명</div>
            <div class="truth-result-dots" id="truthResultXDots"></div>
          </div>
        </div>

        <!-- 총원 -->
        <div class="truth-result-total" id="truthResultTotal">총 0명 참여</div>
      </div>

      <!-- 다음 질문 버튼 (질문자 또는 호스트) -->
      <button class="btn btn-accent2 truth-next-btn" id="truthNextBtn" onclick="truthNextRound()" style="display:none;">
        ➡️ 다음 질문
      </button>
      <div class="truth-next-waiting" id="truthNextWaiting" style="display:none;">
        다음 질문을 기다리는 중...
      </div>
    </div>

  </div>

  <!-- 하단 플레이어 표시 -->
  <div class="truth-players-bar" id="truthPlayersBar"></div>
</div>

<!-- QUICK DRAW GAME -->
<div class="screen" id="quickDrawGame">
  <div class="qd-header">
    <button class="back-btn" style="font-size:18px;padding:4px;" onclick="leaveGame()">✕</button>
    <div class="qd-title">🤠 서부 총잡이</div>
    <div class="qd-round">라운드 <span id="qdRoundNum">1</span></div>
  </div>

  <div class="qd-main-area">
    <div class="qd-tap-zone" id="qdTapZone" onclick="qdTap()">
      <div class="qd-status-text" id="qdStatusText">준비...</div>
      <div class="qd-reaction-time" id="qdReactionTime"></div>
    </div>
  </div>

  <div class="qd-rankings">
    <div class="qd-rankings-title">순위</div>
    <div class="qd-rankings-list" id="qdRankingsList"></div>
  </div>

  <button class="btn btn-primary qd-restart-btn" id="qdRestartBtn" style="display:none;" onclick="restartQuickDraw()">다시 하기</button>
</div>

<!-- RUSSIAN ROULETTE -->
<div class="screen" id="rouletteGame">
  <div class="roulette-header">
    <button class="back-btn" style="font-size:18px;padding:4px;" onclick="leaveGame()">✕</button>
    <div class="roulette-title">🔫 러시안 룰렛</div>
    <div class="roulette-survivors">
      <span id="rouletteSurvivors">6</span>/<span id="rouletteTotalPlayers">6</span>
    </div>
  </div>

  <!-- 게임 시작 전 설정 (호스트만) -->
  <div class="roulette-setup" id="rouletteSetup" style="display:none;">
    <div class="setup-card">
      <div class="setup-label">총알 개수</div>
      <div class="setup-slider-row">
        <input type="range" class="setup-slider" id="bulletsSlider" min="1" max="3" value="1">
        <div class="setup-value" id="bulletsValue">1</div>
      </div>
    </div>
    <div class="setup-card">
      <div class="setup-label">실린더 칸 수</div>
      <div class="setup-slider-row">
        <input type="range" class="setup-slider" id="chambersSlider" min="6" max="8" value="6">
        <div class="setup-value" id="chambersValue">6</div>
      </div>
    </div>
    <button class="btn btn-primary" onclick="confirmRouletteSetup()" style="margin-top:12px;">설정 완료 및 시작</button>
  </div>

  <!-- 실린더 시각화 -->
  <div class="cylinder-area">
    <div class="current-turn-display" id="currentTurnDisplay">
      <span id="currentTurnName">플레이어</span>의 차례
    </div>

    <div class="cylinder-container">
      <div class="cylinder" id="cylinder">
        <!-- 동적 생성: 6~8개 칸 -->
      </div>
      <div class="cylinder-center">🎯</div>
    </div>

    <div class="cylinder-info" id="cylinderInfo">
      실린더를 돌려주세요
    </div>
  </div>

  <!-- 생존자 리스트 -->
  <div class="survivors-list" id="survivorsList">
    <!-- 동적 생성 -->
  </div>

  <!-- 액션 버튼 -->
  <div class="roulette-actions" id="rouletteActions">
    <button class="btn btn-secondary" id="spinBtn" onclick="spinCylinder()" style="display:none;">
      🔄 실린더 돌리기
    </button>
    <button class="btn btn-danger" id="triggerBtn" onclick="pullTrigger()" style="display:none;">
      💥 방아쇠 당기기
    </button>
    <button class="btn btn-primary" id="restartBtn" onclick="restartRoulette()" style="display:none;">
      🔁 다시 하기
    </button>
  </div>
</div>

<!-- 결과 플래시 오버레이 -->
<div class="roulette-flash" id="rouletteFlash">
  <div class="flash-content" id="flashContent">
    <div class="flash-icon" id="flashIcon">💥</div>
    <div class="flash-text" id="flashText">탕!</div>
  </div>
</div>

<!-- LOTTERY & ROULETTE GAME -->
<div class="screen" id="lotteryGame">
  <!-- Top Bar -->
  <div class="lottery-top-bar">
    <button class="back-btn" style="font-size:18px;padding:4px;" onclick="leaveGame()">✕</button>
    <div class="lottery-title">🎰 뽑기 & 룰렛</div>
    <div style="width:40px;"></div>
  </div>

  <!-- Mode Tabs -->
  <div class="mode-tabs">
    <div class="mode-tab active" data-mode="lottery" onclick="switchLotteryMode('lottery')">
      📋 종이뽑기
    </div>
    <div class="mode-tab" data-mode="roulette" onclick="switchLotteryMode('roulette')">
      🎡 룰렛
    </div>
  </div>

  <!-- LOTTERY MODE -->
  <div class="lottery-mode-container" id="lotteryModeContainer">
    <!-- Setup Panel (Host Only) -->
    <div class="lottery-setup-panel" id="lotterySetupPanel" style="display:none;">
      <div class="setup-title">🎯 뽑기 항목 설정 (호스트만 가능)</div>
      <textarea class="lottery-items-input" id="lotteryItemsInput" placeholder="항목을 줄바꿈으로 구분하여 입력하세요&#10;예:&#10;당첨!&#10;꽝&#10;벌칙: 원샷&#10;벌칙: 춤추기&#10;행운!&#10;다시 뽑기"></textarea>
      <div class="setup-row">
        <label style="color:var(--text);font-size:14px;font-weight:700;">칸 개수:</label>
        <select class="grid-size-select" id="gridSizeSelect">
          <option value="4">4x4 (16칸)</option>
          <option value="5">5x5 (25칸)</option>
          <option value="6">6x6 (36칸)</option>
          <option value="8">8x8 (64칸)</option>
          <option value="10" selected>10x10 (100칸)</option>
        </select>
      </div>
      <button class="btn btn-primary" onclick="startLotteryGame()">🎮 뽑기 시작</button>
    </div>

    <!-- Lottery Grid -->
    <div class="lottery-grid-container" id="lotteryGridContainer" style="display:none;">
      <div class="lottery-status">
        <div class="status-text">🎯 칸을 터치하여 뽑기!</div>
        <div class="picked-count">뽑은 개수: <span id="pickedCount">0</span> / <span id="totalCount">100</span></div>
      </div>
      <div class="lottery-grid" id="lotteryGrid"></div>
    </div>

    <!-- My Result Display -->
    <div class="my-result-panel" id="myLotteryResult" style="display:none;">
      <div class="result-label">🎁 내가 뽑은 결과</div>
      <div class="result-list" id="myResultList"></div>
    </div>
  </div>

  <!-- ROULETTE MODE -->
  <div class="roulette-mode-container" id="rouletteModeContainer" style="display:none;">
    <!-- Setup Panel (Host Only) -->
    <div class="roulette-setup-panel" id="rouletteSetupPanel" style="display:none;">
      <div class="setup-title">🎡 룰렛 항목 설정 (호스트만 가능)</div>
      <textarea class="lottery-items-input" id="rouletteItemsInput" placeholder="룰렛 항목을 줄바꿈으로 구분 (2~12개)&#10;예:&#10;당첨!&#10;벌칙 1&#10;꽝&#10;원샷&#10;행운&#10;다시!"></textarea>
      <button class="btn btn-primary" onclick="startRouletteGame()">🎡 룰렛 시작</button>
    </div>

    <!-- Roulette Display -->
    <div class="roulette-display-container" id="rouletteDisplayContainer" style="display:none;">
      <div class="roulette-status">
        <div class="status-text">🎰 돌리기 버튼을 눌러주세요!</div>
      </div>

      <div class="roulette-wheel-container">
        <div class="roulette-pointer">▼</div>
        <div class="roulette-wheel" id="rouletteWheel">
          <canvas id="rouletteCanvas" width="300" height="300"></canvas>
        </div>
      </div>

      <button class="btn btn-primary roulette-spin-btn" id="rouletteSpinBtn" onclick="spinRoulette()">
        🎡 돌리기!
      </button>

      <!-- Result Display -->
      <div class="roulette-result-display" id="rouletteResultDisplay" style="display:none;">
        <div class="result-emoji">🎉</div>
        <div class="result-text" id="rouletteResultText">당첨!</div>
      </div>
    </div>
  </div>
</div>

<!-- ========================================= -->
<!-- UP DOWN GAME -->
<!-- ========================================= -->
<div class="screen" id="updownGame">
  <div class="updown-top-bar">
    <div class="updown-title">K's Game</div>
    <div class="updown-turn-name" id="updownTurnName">플레이어</div>
    <button class="back-btn" style="font-size:18px;padding:4px;" onclick="leaveGame()">&#10005;</button>
  </div>

  <div class="updown-table">
    <div class="updown-deck-count" id="updownDeckCount">남은 카드: 52</div>

    <div class="updown-cards-row">
      <div class="updown-card-slot" id="updownPrevCard">
        <div class="updown-card-label">이전 카드</div>
        <div class="updown-card-placeholder"></div>
      </div>

      <div class="updown-card-slot updown-current-slot" id="updownCurrentCard">
        <div class="updown-card-label">현재 카드</div>
        <div class="updown-card updown-card-back">
          <div class="updown-card-inner">
            <div class="updown-card-front"></div>
            <div class="updown-card-back-face">&#127924;</div>
          </div>
        </div>
      </div>
    </div>

    <div class="updown-result" id="updownResult"></div>
  </div>

  <div class="updown-penalty-list" id="updownPenaltyList">
    <div style="font-size:12px;color:var(--text-dim);margin-bottom:4px;font-weight:700;">벌칙 목록</div>
    <div id="updownPenaltyItems"></div>
  </div>

  <div class="updown-action-area" id="updownActionArea">
    <div class="updown-choice-buttons" id="updownChoiceButtons">
      <button class="updown-btn updown-btn-up" onclick="udChoice('up')">
        <span style="font-size:28px;">&#8593;</span>
        <span>UP</span>
      </button>
      <button class="updown-btn updown-btn-down" onclick="udChoice('down')">
        <span style="font-size:28px;">&#8595;</span>
        <span>DOWN</span>
      </button>
    </div>

    <div class="updown-bet-area">
      <input type="text" class="updown-bet-input" id="updownBetInput" placeholder="벌칙 내용 입력..." maxlength="30">
      <button class="updown-btn-bet" onclick="udAddBet()">+Bet 벌칙</button>
    </div>
  </div>

  <!-- Special Card Areas -->
  <div class="updown-special-area updown-special-jq" id="updownSpecialJQ" style="display:none;">
    <div class="updown-special-title">흑기사 요청</div>
    <div class="updown-special-desc">다른 플레이어에게 벌칙을 대신 받을 것을 요청할 수 있습니다. 거절하면 나머지 모두가 벌칙!</div>
    <div class="updown-player-select" id="updownJQPlayerSelect"></div>
    <button class="updown-btn-special" onclick="udBlackKnight()">흑기사 요청</button>
  </div>

  <div class="updown-special-area updown-special-k" id="updownSpecialK" style="display:none;">
    <div class="updown-special-title">왕의 명령</div>
    <div class="updown-special-desc">3명에게 벌칙을 내릴 수 있습니다!</div>
    <div class="updown-player-select" id="updownKPlayerSelect"></div>
    <button class="updown-btn-special updown-btn-king" onclick="udKingPenalty()">왕 벌칙 부여</button>
  </div>

  <!-- Penalty Modal -->
  <div class="updown-penalty-modal" id="updownPenaltyModal">
    <div class="updown-penalty-content">
      <div class="updown-penalty-title">벌칙!</div>
      <div class="updown-penalty-text" id="updownPenaltyText">소주 1잔</div>
      <div class="updown-penalty-who" id="updownPenaltyWho">플레이어님의 차례</div>
      <button class="updown-btn-accept" onclick="udAcceptPenalty()">수행하기</button>
      <button class="updown-btn-reject" onclick="udRejectPenalty()">거절 (술 마시기)</button>
    </div>
  </div>

  <!-- Black Knight Request Modal -->
  <div class="updown-penalty-modal" id="updownBKModal">
    <div class="updown-penalty-content">
      <div class="updown-penalty-title">흑기사 요청</div>
      <div class="updown-penalty-text" id="updownBKText">벌칙 내용</div>
      <div class="updown-penalty-who" id="updownBKWho">누가 요청했습니다</div>
      <button class="updown-btn-accept" onclick="udAcceptBK()">수락 (대신 받기)</button>
      <button class="updown-btn-reject" onclick="udRejectBK()">거절 (나머지 모두 벌칙)</button>
    </div>
  </div>
</div>

<!-- ============================== -->
<!-- YAHTZEE GAME -->
<!-- ============================== -->
<div class="screen" id="yahtzeeGame">
  <div class="yahtzee-header">
    <button class="back-btn" style="font-size:18px;padding:4px;" onclick="leaveGame()">&#10005;</button>
    <div class="yahtzee-turn-info">
      <div class="yahtzee-turn-text" id="yahTurnText">턴 1/13</div>
      <div class="yahtzee-current-player" id="yahCurrentPlayer">플레이어 차례</div>
    </div>
    <div class="yahtzee-rolls-left" id="yahRollsLeft">3 left</div>
  </div>

  <div class="yahtzee-players-bar" id="yahtzeePlayersBar">
  </div>

  <div class="yahtzee-dice-area">
    <div class="yahtzee-dice-container" id="yahtzeeDiceContainer">
      <div class="yahtzee-die" data-idx="0" onclick="yahToggleHold(0)">
        <div class="yahtzee-die-inner">
          <div class="yahtzee-die-face" id="yahdice0">
            <span class="pip"></span>
          </div>
        </div>
      </div>
      <div class="yahtzee-die" data-idx="1" onclick="yahToggleHold(1)">
        <div class="yahtzee-die-inner">
          <div class="yahtzee-die-face" id="yahdice1">
            <span class="pip"></span>
          </div>
        </div>
      </div>
      <div class="yahtzee-die" data-idx="2" onclick="yahToggleHold(2)">
        <div class="yahtzee-die-inner">
          <div class="yahtzee-die-face" id="yahdice2">
            <span class="pip"></span>
          </div>
        </div>
      </div>
      <div class="yahtzee-die" data-idx="3" onclick="yahToggleHold(3)">
        <div class="yahtzee-die-inner">
          <div class="yahtzee-die-face" id="yahdice3">
            <span class="pip"></span>
          </div>
        </div>
      </div>
      <div class="yahtzee-die" data-idx="4" onclick="yahToggleHold(4)">
        <div class="yahtzee-die-inner">
          <div class="yahtzee-die-face" id="yahdice4">
            <span class="pip"></span>
          </div>
        </div>
      </div>
    </div>
    <div class="yahtzee-roll-hint">탭하여 주사위 잠금/해제</div>
    <button class="btn btn-primary yahtzee-roll-btn" id="yahtzeeRollBtn" onclick="yahRoll()">주사위 굴리기</button>
  </div>

  <div class="yahtzee-scorecard-area">
    <div class="yahtzee-scorecard-title">점수표</div>
    <div class="yahtzee-scorecard" id="yahtzeeScorecard">
      <table class="yahtzee-score-table">
        <thead>
          <tr>
            <th>카테고리</th>
            <th>점수</th>
          </tr>
        </thead>
        <tbody>
          <tr class="yahtzee-score-row" data-cat="ones">
            <td class="yahtzee-cat-name">1s (Ones)</td>
            <td class="yahtzee-cat-score" id="yahcat-ones">-</td>
          </tr>
          <tr class="yahtzee-score-row" data-cat="twos">
            <td class="yahtzee-cat-name">2s (Twos)</td>
            <td class="yahtzee-cat-score" id="yahcat-twos">-</td>
          </tr>
          <tr class="yahtzee-score-row" data-cat="threes">
            <td class="yahtzee-cat-name">3s (Threes)</td>
            <td class="yahtzee-cat-score" id="yahcat-threes">-</td>
          </tr>
          <tr class="yahtzee-score-row" data-cat="fours">
            <td class="yahtzee-cat-name">4s (Fours)</td>
            <td class="yahtzee-cat-score" id="yahcat-fours">-</td>
          </tr>
          <tr class="yahtzee-score-row" data-cat="fives">
            <td class="yahtzee-cat-name">5s (Fives)</td>
            <td class="yahtzee-cat-score" id="yahcat-fives">-</td>
          </tr>
          <tr class="yahtzee-score-row" data-cat="sixes">
            <td class="yahtzee-cat-name">6s (Sixes)</td>
            <td class="yahtzee-cat-score" id="yahcat-sixes">-</td>
          </tr>
          <tr class="yahtzee-subtotal-row">
            <td><strong>상단 합계</strong></td>
            <td id="yahcat-upper-subtotal">0</td>
          </tr>
          <tr class="yahtzee-bonus-row">
            <td><strong>보너스 (63+ 시)</strong></td>
            <td id="yahcat-bonus">0</td>
          </tr>
          <tr class="yahtzee-divider-row">
            <td colspan="2"></td>
          </tr>
          <tr class="yahtzee-score-row" data-cat="three-kind">
            <td class="yahtzee-cat-name">3 of a Kind</td>
            <td class="yahtzee-cat-score" id="yahcat-three-kind">-</td>
          </tr>
          <tr class="yahtzee-score-row" data-cat="four-kind">
            <td class="yahtzee-cat-name">4 of a Kind</td>
            <td class="yahtzee-cat-score" id="yahcat-four-kind">-</td>
          </tr>
          <tr class="yahtzee-score-row" data-cat="full-house">
            <td class="yahtzee-cat-name">Full House (25점)</td>
            <td class="yahtzee-cat-score" id="yahcat-full-house">-</td>
          </tr>
          <tr class="yahtzee-score-row" data-cat="small-straight">
            <td class="yahtzee-cat-name">Small Straight (30점)</td>
            <td class="yahtzee-cat-score" id="yahcat-small-straight">-</td>
          </tr>
          <tr class="yahtzee-score-row" data-cat="large-straight">
            <td class="yahtzee-cat-name">Large Straight (40점)</td>
            <td class="yahtzee-cat-score" id="yahcat-large-straight">-</td>
          </tr>
          <tr class="yahtzee-score-row" data-cat="yahtzee">
            <td class="yahtzee-cat-name">Yahtzee! (50점)</td>
            <td class="yahtzee-cat-score" id="yahcat-yahtzee">-</td>
          </tr>
          <tr class="yahtzee-score-row" data-cat="chance">
            <td class="yahtzee-cat-name">Chance</td>
            <td class="yahtzee-cat-score" id="yahcat-chance">-</td>
          </tr>
          <tr class="yahtzee-total-row">
            <td><strong>총점</strong></td>
            <td id="yahcat-total"><strong>0</strong></td>
          </tr>
        </tbody>
      </table>
    </div>
    <button class="btn yahtzee-score-btn" id="yahtzeeScoreBtn" onclick="yahScore()" style="display:none;">점수 확정</button>
  </div>

  <div class="yahtzee-game-over" id="yahtzeeGameOver" style="display:none;">
    <div class="yahtzee-final-scores">
      <div class="yahtzee-final-title">게임 종료!</div>
      <div class="yahtzee-rankings" id="yahtzeeRankings">
      </div>
    </div>
    <button class="btn btn-primary" onclick="closeYahtzeeGame()" style="max-width:280px;">대기실로</button>
  </div>
</div>

<!-- ===== E CARD GAME ===== -->
<div class="screen" id="ecardGame">
  <div class="ecard-top-bar">
    <button class="back-btn" style="font-size:18px;padding:4px;" onclick="leaveGame()">&#10005;</button>
    <div class="ecard-title">E카드 (왕과 노예)</div>
    <div class="ecard-round">라운드 <span id="ecardRound">1</span>/5</div>
  </div>

  <div class="ecard-score">
    <div class="score-item score-emperor">
      <div class="score-icon">&#128081;</div>
      <div class="score-value" id="ecardScoreEmperor">0</div>
    </div>
    <div class="score-divider">:</div>
    <div class="score-item score-slave">
      <div class="score-icon">&#9939;&#65039;</div>
      <div class="score-value" id="ecardScoreSlave">0</div>
    </div>
  </div>

  <div class="ecard-role-display" id="ecardRoleDisplay">
    <div class="role-badge" id="ecardRoleBadge">
      <div class="role-icon" id="ecardRoleIcon">&#128081;</div>
      <div class="role-text">당신은 <span id="ecardRoleName">황제</span>입니다</div>
    </div>
  </div>

  <div class="ecard-opponent-area" id="ecardOpponentArea">
    <div class="opponent-info">
      <div class="opponent-avatar" id="ecardOppAvatar" style="background: linear-gradient(135deg, #00e5ff, #00b8d4);">&#128526;</div>
      <div class="opponent-name" id="ecardOppName">상대방</div>
      <div class="opponent-cards-count">남은 카드: <span id="ecardOppCardsCount">5</span>장</div>
    </div>
    <div class="opponent-played-card" id="ecardOppPlayedCard">
    </div>
  </div>

  <div class="ecard-battle-area" id="ecardBattleArea" style="display:none;">
    <div class="battle-card" id="ecardBattleOpp"></div>
    <div class="battle-vs">VS</div>
    <div class="battle-card" id="ecardBattleMy"></div>
  </div>

  <div class="ecard-result-text" id="ecardResultText"></div>

  <div class="ecard-my-cards-area">
    <div class="my-cards-label">내 카드 (<span id="ecardMyCardsCount">5</span>장)</div>
    <div class="ecard-cards-hand" id="ecardMyCards">
    </div>
  </div>

  <div class="ecard-bet-area" id="ecardBetArea" style="display:none;">
    <div class="bet-label">배팅 금액 제안</div>
    <div class="bet-controls">
      <input type="range" class="bet-slider" id="ecardBetSlider" min="10" max="500" value="100" step="10">
      <div class="bet-amount" id="ecardBetAmount">100</div>
    </div>
    <button class="btn btn-primary" id="ecardBetSubmit" onclick="ecardSubmitBet()">배팅 제안</button>
  </div>

  <div class="ecard-bet-response" id="ecardBetResponse" style="display:none;">
    <div class="bet-proposal">상대방이 <span id="ecardBetProposed">100</span> 배팅을 제안했습니다</div>
    <div class="bet-buttons">
      <button class="btn btn-secondary" onclick="ecardRejectBet()">거절</button>
      <button class="btn btn-primary" onclick="ecardAcceptBet()">수락</button>
    </div>
  </div>

  <div class="ecard-action-buttons" id="ecardActionButtons">
    <button class="btn btn-primary" id="ecardSubmitBtn" onclick="ecardSubmitCard()" disabled>카드 제출</button>
  </div>

  <div class="ecard-waiting" id="ecardWaiting" style="display:none;">
    <div class="spinner"></div>
    <div style="margin-top:8px;font-size:14px;color:var(--text-dim);" id="ecardWaitingText">상대방을 기다리는 중...</div>
  </div>
</div>

<!-- SUTDA GAME -->
<div class="screen" id="sutdaGame">
  <!-- 상단 바 -->
  <div class="sutda-top-bar">
    <button class="back-btn" style="font-size:18px;padding:4px;" onclick="leaveGame()">&#10005;</button>
    <div class="sutda-title-area">
      <span class="sutda-title-text">장땡 섯다</span>
      <span class="sutda-pot-badge" id="sutdaPotBadge">0</span>
    </div>
    <div class="sutda-my-balance" id="sutdaMyBalance">0</div>
  </div>

  <!-- 상대방 영역 -->
  <div class="sutda-opponents" id="sutdaOpponents"></div>

  <!-- 테이블 중앙 -->
  <div class="sutda-table">
    <div class="sutda-table-felt">
      <div class="sutda-pot-center">
        <div class="sutda-pot-label">판돈</div>
        <div class="sutda-pot-amount" id="sutdaPotAmount">0</div>
      </div>
      <div class="sutda-turn-indicator" id="sutdaTurnIndicator"></div>
    </div>
  </div>

  <!-- 내 패 영역 -->
  <div class="sutda-my-area">
    <div class="sutda-my-info">
      <div class="sutda-my-name" id="sutdaMyName">나</div>
      <div class="sutda-my-chips" id="sutdaMyChips">0</div>
    </div>
    <div class="sutda-my-cards" id="sutdaMyCards"></div>
    <div class="sutda-my-rank" id="sutdaMyRank"></div>
  </div>

  <!-- 세륙 선택 패널 -->
  <div class="sutda-seryuk-panel" id="sutdaSeryukPanel" style="display:none;">
    <div class="sutda-seryuk-title">세륙 (6+4) 선택</div>
    <div class="sutda-seryuk-desc">밀기: 10끗으로 계산 | 깽판: 패 재분배</div>
    <div class="sutda-seryuk-buttons">
      <button class="sutda-seryuk-btn sutda-seryuk-push" onclick="sutdaSeryukChoice('push')">
        <span class="sutda-seryuk-icon">&#x1F4AA;</span>
        <span>밀기</span>
        <span class="sutda-seryuk-sub">10끗</span>
      </button>
      <button class="sutda-seryuk-btn sutda-seryuk-chaos" onclick="sutdaSeryukChoice('chaos')">
        <span class="sutda-seryuk-icon">&#x1F300;</span>
        <span>깽판</span>
        <span class="sutda-seryuk-sub">패 재분배</span>
      </button>
    </div>
  </div>

  <!-- 배팅 버튼 -->
  <div class="sutda-action-bar" id="sutdaActionBar">
    <button class="sutda-bet-btn sutda-bet-10k" onclick="sutdaBet('raise',10000)" id="sutdaBtn10k">+1만</button>
    <button class="sutda-bet-btn sutda-bet-50k" onclick="sutdaBet('raise',50000)" id="sutdaBtn50k">+5만</button>
    <button class="sutda-bet-btn sutda-bet-100k" onclick="sutdaBet('raise',100000)" id="sutdaBtn100k">+10만</button>
    <button class="sutda-bet-btn sutda-bet-call" onclick="sutdaBet('call',0)" id="sutdaBtnCall">콜</button>
    <button class="sutda-bet-btn sutda-bet-die" onclick="sutdaBet('die',0)" id="sutdaBtnDie">다이</button>
    <button class="sutda-bet-btn sutda-bet-allin" onclick="sutdaBet('allin',0)" id="sutdaBtnAllin">올인</button>
  </div>

  <!-- 결과 오버레이 -->
  <div class="sutda-result-overlay" id="sutdaResultOverlay">
    <div class="sutda-result-box">
      <div class="sutda-result-title" id="sutdaResultTitle">승리!</div>
      <div class="sutda-result-winner" id="sutdaResultWinner"></div>
      <div class="sutda-result-rank" id="sutdaResultRank"></div>
      <div class="sutda-result-cards" id="sutdaResultCards"></div>
      <div class="sutda-result-pot" id="sutdaResultPot"></div>
      <div class="sutda-result-all-hands" id="sutdaResultAllHands"></div>
      <button class="btn btn-primary" onclick="closeSutdaResult()" style="margin-top:16px;">확인</button>
    </div>
  </div>
</div>

<!-- RACING GAME -->
<div class="screen" id="racingGame">
  <!-- 모드 선택 화면 -->
  <div class="racing-mode-select" id="racingModeSelect">
    <div class="racing-mode-header">
      <button class="back-btn" onclick="leaveGame()">←</button>
      <div class="racing-mode-title">🏍️ 오토바이 레이싱</div>
      <div style="width:40px;"></div>
    </div>

    <div class="racing-mode-cards">
      <div class="racing-mode-card" onclick="selectRacingMode('survival')">
        <div class="racing-mode-icon">⚡</div>
        <div class="racing-mode-name">서바이벌</div>
        <div class="racing-mode-desc">점점 빨라지는 속도<br>최대한 멀리 가기!</div>
      </div>
      <div class="racing-mode-card" onclick="selectRacingMode('race')">
        <div class="racing-mode-icon">🏁</div>
        <div class="racing-mode-name">레이스</div>
        <div class="racing-mode-desc">목표 지점까지<br>1000m 완주하기!</div>
      </div>
    </div>

    <div class="racing-gyro-permission" id="racingGyroPermission" style="display:none;">
      <div class="racing-info-box">
        <div class="racing-info-icon">📱</div>
        <div class="racing-info-text">
          이 게임은 휴대폰 기울기를 사용합니다<br>
          <small style="color:var(--text-dim);">좌우로 기울여서 조종하세요</small>
        </div>
      </div>
      <button class="btn btn-primary" onclick="requestGyroPermission()">
        🎮 기울기 권한 요청
      </button>
    </div>
  </div>

  <!-- 게임 화면 -->
  <div class="racing-game-area" id="racingGameArea" style="display:none;">
    <!-- HUD 오버레이 -->
    <div class="racing-hud">
      <div class="racing-hud-left">
        <div class="racing-speed">
          <div class="racing-speed-label">SPEED</div>
          <div class="racing-speed-value" id="racingSpeed">0</div>
          <div class="racing-speed-unit">km/h</div>
        </div>
      </div>
      <div class="racing-hud-center">
        <div class="racing-distance">
          <div class="racing-distance-label">DISTANCE</div>
          <div class="racing-distance-value" id="racingDistance">0</div>
          <div class="racing-distance-unit">m</div>
        </div>
      </div>
      <div class="racing-hud-right">
        <div class="racing-rank" id="racingRank" style="display:none;">
          <div class="racing-rank-label">RANK</div>
          <div class="racing-rank-value" id="racingRankValue">1위/4명</div>
        </div>
      </div>
    </div>

    <!-- 배경 건물 -->
    <div class="racing-bg-buildings" id="racingBuildings">
      <!-- 동적 생성 -->
    </div>

    <!-- 도로 -->
    <div class="racing-road">
      <!-- 차선 라인 -->
      <div class="racing-lane-line" style="left:33.33%;"></div>
      <div class="racing-lane-line" style="left:66.66%;"></div>

      <!-- 차선 점선 애니메이션 -->
      <div class="racing-lane-dashes" id="racingDashes">
        <!-- 동적 생성 -->
      </div>

      <!-- 장애물 컨테이너 -->
      <div class="racing-obstacles" id="racingObstacles">
        <!-- 동적 생성 -->
      </div>

      <!-- 오토바이 (하단 고정) -->
      <div class="racing-bike" id="racingBike">
        <div class="racing-bike-body">🏍️</div>
      </div>
    </div>

    <!-- 핸들바 UI -->
    <div class="racing-handlebar">
      <div class="racing-handlebar-left"></div>
      <div class="racing-handlebar-center"></div>
      <div class="racing-handlebar-right"></div>
    </div>

    <!-- 터치 컨트롤 폴백 -->
    <div class="racing-touch-controls" id="racingTouchControls" style="display:none;">
      <button class="racing-touch-btn racing-touch-left" ontouchstart="racingMoveLane(0)" ontouchend="racingStopMove()">←</button>
      <button class="racing-touch-btn racing-touch-center" ontouchstart="racingMoveLane(1)" ontouchend="racingStopMove()">↑</button>
      <button class="racing-touch-btn racing-touch-right" ontouchstart="racingMoveLane(2)" ontouchend="racingStopMove()">→</button>
    </div>

    <!-- 충돌 효과 오버레이 -->
    <div class="racing-crash-overlay" id="racingCrashOverlay"></div>
  </div>

  <!-- 결과 화면 -->
  <div class="racing-result-screen" id="racingResultScreen" style="display:none;">
    <div class="racing-result-header">
      <div class="racing-result-title" id="racingResultTitle">완주!</div>
      <div class="racing-result-subtitle" id="racingResultSubtitle"></div>
    </div>

    <div class="racing-result-stats">
      <div class="racing-result-stat">
        <div class="racing-result-stat-label">최종 거리</div>
        <div class="racing-result-stat-value" id="racingResultDistance">0m</div>
      </div>
      <div class="racing-result-stat">
        <div class="racing-result-stat-label">최고 속도</div>
        <div class="racing-result-stat-value" id="racingResultMaxSpeed">0 km/h</div>
      </div>
      <div class="racing-result-stat">
        <div class="racing-result-stat-label">플레이 시간</div>
        <div class="racing-result-stat-value" id="racingResultTime">0초</div>
      </div>
    </div>

    <div class="racing-result-rankings" id="racingResultRankings">
      <div class="racing-result-rankings-title">순위</div>
      <div class="racing-result-rankings-list" id="racingResultRankingsList"></div>
    </div>

    <button class="btn btn-primary" onclick="restartRacing()">🔁 다시 하기</button>
    <button class="btn btn-secondary" onclick="leaveGame()" style="margin-top:12px;">← 로비로</button>
  </div>
</div>

<!-- RESULT -->
<div class="result-overlay" id="resultOverlay">
  <div class="result-title" id="resultTitle">🏆 승리!</div>
  <div class="winner-info">
    <div id="winnerName" style="font-size:20px;font-weight:900;"></div>
    <div class="result-cards" id="resultCards"></div>
    <div class="result-hand" id="resultHand"></div>
    <div class="result-pot" id="resultPot"></div>
  </div>
  <button class="btn btn-primary" onclick="closeResult()" style="max-width:280px;">다음 라운드</button>
</div>

<!-- QR Code library -->
<script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

<!-- PeerJS loaded dynamically -->
<script>
// ===== LOAD PEERJS DYNAMICALLY =====
function loadPeerJS() {
  return new Promise((resolve, reject) => {
    if(window.Peer) { resolve(); return; }
    const s = document.createElement('script');
    s.src = 'https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js';
    s.onload = resolve;
    s.onerror = () => {
      // Fallback CDN
      const s2 = document.createElement('script');
      s2.src = 'https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js';
      s2.onload = resolve;
      s2.onerror = reject;
      document.head.appendChild(s2);
    };
    document.head.appendChild(s);
  });
}

// ===== CONSTANTS & STATE =====
const AVATARS = ['😎','🤠','👻','🦊','🐱','🐼','🦁','🐸','🎃','🤖','👽','🦄'];
const SUITS = ['♠','♥','♦','♣'];
const RANKS = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
const PLAYER_COLORS = [
  'linear-gradient(135deg, #ff6b35, #ff8f5a)',
  'linear-gradient(135deg, #00e5ff, #00b8d4)',
  'linear-gradient(135deg, #ff2d78, #ff6090)',
  'linear-gradient(135deg, #ffd700, #ffab00)',
  'linear-gradient(135deg, #76ff03, #64dd17)',
  'linear-gradient(135deg, #e040fb, #aa00ff)',
  'linear-gradient(135deg, #ff6e40, #ff3d00)',
  'linear-gradient(135deg, #18ffff, #00b8d4)',
  'linear-gradient(135deg, #ffab40, #ff6d00)',
  'linear-gradient(135deg, #69f0ae, #00c853)',
  'linear-gradient(135deg, #ea80fc, #d500f9)',
  'linear-gradient(135deg, #ff80ab, #f50057)',
  'linear-gradient(135deg, #b388ff, #651fff)',
  'linear-gradient(135deg, #84ffff, #00e5ff)'
];

let state = {
  myId: '', myName: '', myAvatar: '😎', avatarIdx: 0,
  isHost: false, roomCode: '',
  peer: null, connections: {}, players: [],
  selectedGame: 'poker',
  poker: null, mafia: null,
  _pokerView: null, _mafiaView: null,
};

// ===== INIT =====
async function init() {
  const bar = document.getElementById('loadingBar');
  const txt = document.getElementById('loadingText');
  
  bar.style.width = '30%';
  txt.textContent = 'PeerJS 라이브러리 로딩 중...';
  
  try {
    await loadPeerJS();
    bar.style.width = '80%';
    txt.textContent = '프로필 로딩 중...';
    loadProfile();
    
    // Check URL for room code
    const params = new URLSearchParams(location.search);
    const code = params.get('room');
    if(code) {
      document.getElementById('joinCodeInput').value = code;
    }
    
    bar.style.width = '100%';
    txt.textContent = '완료!';
    
    setTimeout(() => {
      showScreen('mainMenu');
    }, 400);
    
  } catch(e) {
    txt.textContent = '❌ PeerJS 로드 실패. 새로고침 해주세요.';
    console.error('Failed to load PeerJS:', e);
  }
}

// ===== UTILS =====
function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2500);
}

function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

function genCode() {
  const c = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let r = '';
  for(let i = 0; i < 5; i++) r += c[Math.floor(Math.random() * c.length)];
  return r;
}

// ===== PROFILE =====
function loadProfile() {
  const s = localStorage.getItem('pd_profile');
  if(s) {
    const p = JSON.parse(s);
    state.myName = p.name || '';
    state.myAvatar = p.avatar || '😎';
    state.avatarIdx = Math.max(0, AVATARS.indexOf(state.myAvatar));
  }
  document.getElementById('nameInput').value = state.myName;
  document.getElementById('myAvatar').textContent = state.myAvatar;
  updateStats();
}

function saveProfile() {
  state.myName = document.getElementById('nameInput').value.trim() || '플레이어';
  state.myAvatar = AVATARS[state.avatarIdx];
  localStorage.setItem('pd_profile', JSON.stringify({ name: state.myName, avatar: state.myAvatar }));
}

function updateStats() {
  const s = JSON.parse(localStorage.getItem('pd_stats') || '{"w":0,"g":0}');
  const r = s.g > 0 ? Math.round((s.w / s.g) * 100) : 0;
  document.getElementById('profileStats').textContent = `${s.g}전 ${s.w}승 (${r}%)`;
}

function recordGame(won) {
  const s = JSON.parse(localStorage.getItem('pd_stats') || '{"w":0,"g":0}');
  s.g++;
  if(won) s.w++;
  localStorage.setItem('pd_stats', JSON.stringify(s));
  updateStats();
}

function cycleAvatar() {
  state.avatarIdx = (state.avatarIdx + 1) % AVATARS.length;
  state.myAvatar = AVATARS[state.avatarIdx];
  document.getElementById('myAvatar').textContent = state.myAvatar;
  saveProfile();
}

// ===== PEER CONNECTION =====
function initPeer(id) {
  return new Promise((resolve, reject) => {
    const peer = new Peer(id, {
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
          { urls: 'stun:stun2.l.google.com:19302' },
        ]
      }
    });
    
    const timeout = setTimeout(() => {
      reject(new Error('Connection timeout'));
    }, 15000);
    
    peer.on('open', (myId) => {
      clearTimeout(timeout);
      state.myId = myId;
      state.peer = peer;
      console.log('Peer connected:', myId);
      resolve(peer);
    });
    
    peer.on('error', (err) => {
      clearTimeout(timeout);
      console.error('Peer error:', err);
      if(err.type === 'unavailable-id') showToast('이미 사용 중인 코드입니다');
      else if(err.type === 'peer-unavailable') showToast('방을 찾을 수 없습니다');
      else showToast('연결 오류: ' + err.type);
      reject(err);
    });
    
    peer.on('disconnected', () => {
      console.log('Peer disconnected, reconnecting...');
      if(!peer.destroyed) peer.reconnect();
    });
  });
}

function broadcast(data, exclude) {
  const msg = JSON.stringify(data);
  Object.entries(state.connections).forEach(([pid, conn]) => {
    if(pid !== exclude && conn.open) conn.send(msg);
  });
}

function sendTo(peerId, data) {
  const conn = state.connections[peerId];
  if(conn?.open) conn.send(JSON.stringify(data));
}

function handleMessage(peerId, raw) {
  const msg = typeof raw === 'string' ? JSON.parse(raw) : raw;
  
  const handlers = {
    'player-info': () => handlePlayerJoin(peerId, msg),
    'player-list': () => { state.players = msg.players; updateLobbyUI(); },
    'game-start': () => handleGameStart(msg),
    'poker-state': () => { showScreen('pokerGame'); renderPokerView(msg); },
    'poker-action': () => { if(state.isHost) processPokerAction(peerId, msg.action, msg.amount); },
    'poker-result': () => handlePokerResult(msg),
    'mf-state': () => { mfHandleState(msg); },
    'mf-action': () => { if(state.isHost) mfProcessAction(peerId, msg); },
    'mf-result': () => { mfHandleResult(msg); },
    'truth-state': () => {
      showScreen('truthGame');
      renderTruthView(msg);
    },
    'truth-question': () => {
      if (state.isHost) processTruthQuestion(peerId, msg.question);
    },
    'truth-vote': () => {
      if (state.isHost) processTruthVote(peerId, msg.vote);
    },
    'truth-next': () => {
      if (state.isHost) processTruthNext();
    },
    'qd-state': () => {
      if(msg.phase === 'fire' && navigator.vibrate) navigator.vibrate(200);
      qdState.phase = msg.phase;
      qdState.startTime = msg.startTime;
      qdState.results = msg.results;
      qdState.roundNum = msg.roundNum;
      renderQuickDrawView(qdState);
    },
    'qd-action': () => {
      if(state.isHost) processQDAction(msg);
    },
    'qd-result': () => handleQDResult(msg),
    'roulette-state': () => { showScreen('rouletteGame'); renderRouletteView(msg); },
    'rr-action': () => { if(state.isHost) processRRAction(peerId, msg.action); },
    'rr-result': () => handleRRResult(msg),
    'lottery-state': () => handleLotteryMessage(peerId, msg),
    'lottery-pick-request': () => handleLotteryMessage(peerId, msg),
    'lottery-pick': () => handleLotteryMessage(peerId, msg),
    'roulette-spin-request': () => handleLotteryMessage(peerId, msg),
    'roulette-spin': () => handleLotteryMessage(peerId, msg),
    // UpDown handlers
    'ud-state': () => { showScreen('updownGame'); renderUpDownView(msg.state); },
    'ud-choice': () => { if(state.isHost) processUpDownChoice(peerId, msg.choice); },
    'ud-addbet': () => { if(state.isHost) { udState.penalties.push(msg.text); udState.currentBet = msg.text; broadcastUpDownState(); } },
    'ud-special': () => {
      if(state.isHost) {
        if(msg.action === 'blackknight') processBlackKnight(peerId, msg.targetId);
        else if(msg.action === 'king') processKingPenalty(peerId, msg.targets);
      }
    },
    'ud-bk-request': () => showUpDownBKModal(msg),
    'ud-bk-response': () => {
      if(state.isHost) {
        const penaltyText = udState.specialData?.penaltyText || '벌칙';
        if(msg.accepted) resolveBKAccept(msg.requesterId, peerId, penaltyText);
        else resolveBKReject(msg.requesterId, peerId, penaltyText);
      }
    },
    'ud-penalty': () => handleUpDownPenalty(msg),
    'ud-penalty-done': () => { if(state.isHost) continueUpDown(); },
    // Yahtzee handlers
    'yah-state': () => { showScreen('yahtzeeGame'); renderYahtzeeView(msg.state); },
    'yah-action': () => {
      if(state.isHost) {
        if(yahState.players[yahState.turnIdx].id !== peerId) return;
        if(msg.action === 'roll') {
          if(yahState.rollsLeft > 0) { yahRollDice(); broadcastYahtzeeState(); }
        } else if(msg.action === 'hold') {
          if(yahState.rollsLeft < 3) { yahState.held[msg.index] = !yahState.held[msg.index]; broadcastYahtzeeState(); }
        } else if(msg.action === 'select') {
          const player = yahState.players[yahState.turnIdx];
          if(player.scores[msg.category] === null) { yahState.selectedCategory = msg.category; yahState.phase = 'scoring'; broadcastYahtzeeState(); }
        } else if(msg.action === 'score') {
          if(yahState.selectedCategory) {
            const player = yahState.players[yahState.turnIdx];
            const score = calcYahtzeeScore(yahState.dice, yahState.selectedCategory);
            player.scores[yahState.selectedCategory] = score;
            player.total = calculatePlayerTotal(player);
            const allFinished = yahState.players.every(p => YAHTZEE_CATEGORIES.every(cat => p.scores[cat] !== null));
            if(allFinished) { yahState.phase = 'gameover'; broadcastYahtzeeState(); handleYahtzeeGameOver(); return; }
            yahState.turnIdx = (yahState.turnIdx + 1) % yahState.players.length;
            if(yahState.turnIdx === 0) yahState.turnNum++;
            yahState.dice = [1,1,1,1,1]; yahState.held = [false,false,false,false,false];
            yahState.rollsLeft = 3; yahState.selectedCategory = null; yahState.phase = 'rolling';
            yahRollDice(); broadcastYahtzeeState();
          }
        }
      }
    },
    // E-Card handlers
    'ec-state': () => { showScreen('ecardGame'); renderECardView(msg); },
    'ec-bet': () => { if(state.isHost) processECardBet(peerId, msg.bet); },
    'ec-bet-response': () => { if(state.isHost) processECardBetResponse(peerId, msg.accept); },
    'ec-play': () => { if(state.isHost) processECardPlay(peerId, msg.cardType, msg.cardIdx); },
    'ec-result': () => handleECardResult(msg),
    // Sutda handlers
    'sutda-state': () => { showScreen('sutdaGame'); renderSutdaView(msg); },
    'sutda-bet': () => { if(state.isHost) processSutdaAction(peerId, msg.action, msg.amount); },
    'sutda-seryuk': () => { if(state.isHost) processSutdaSeryuk(peerId, msg.choice); },
    'sutda-result': () => handleSutdaResult(msg),
    // Racing handlers
    'race-position': () => { if(state.isHost) handleRacePosition(peerId, msg); },
    'race-result': () => handleRaceResult(msg),
    'player-left': () => {
      state.players = state.players.filter(p => p.id !== msg.playerId);
      updateLobbyUI();
      showToast(msg.name + ' 퇴장');
    },
    'room-full': () => showToast('방이 가득 찼습니다'),
  };
  
  if(handlers[msg.type]) handlers[msg.type]();
}

// ===== ROOM =====
async function createRoom() {
  saveProfile();
  state.roomCode = genCode();
  state.isHost = true;
  
  try {
    showToast('방 생성 중...');
    await initPeer('pd-' + state.roomCode);
    
    state.players = [{
      id: state.myId, name: state.myName, avatar: state.myAvatar, isHost: true
    }];
    
    state.peer.on('connection', (conn) => {
      conn.on('open', () => {
        state.connections[conn.peer] = conn;
        conn.on('data', (d) => handleMessage(conn.peer, d));
        conn.on('close', () => {
          const p = state.players.find(pp => pp.id === conn.peer);
          delete state.connections[conn.peer];
          state.players = state.players.filter(pp => pp.id !== conn.peer);
          broadcast({ type: 'player-list', players: state.players });
          updateLobbyUI();
          if(p) showToast(p.name + ' 퇴장');
        });
      });
    });
    
    document.getElementById('roomCodeDisplay').textContent = state.roomCode;
    document.getElementById('gameSelectArea').style.display = 'block';
    document.getElementById('startGameBtn').style.display = 'none';
    document.getElementById('waitingMsg').style.display = 'none';
    showScreen('lobby');
    updateLobbyUI();
    showToast('방이 만들어졌습니다!');

    setTimeout(() => {
      const qrDiv = document.getElementById('qrCodeDisplay');
      if(qrDiv && window.QRCode) {
        qrDiv.innerHTML = '';
        new QRCode(qrDiv, {
          text: location.origin + location.pathname + '?room=' + state.roomCode,
          width: 180, height: 180,
          colorDark: '#e8e8f0', colorLight: '#14142a'
        });
      }
    }, 200);

  } catch(e) { console.error(e); }
}

async function joinRoom() {
  saveProfile();
  const code = document.getElementById('joinCodeInput').value.trim().toUpperCase();
  if(!code || code.length < 4) { showToast('방 코드를 입력하세요'); return; }
  
  state.roomCode = code;
  state.isHost = false;
  
  try {
    showToast('방 연결 중...');
    await initPeer('pd-' + code + '-' + Date.now().toString(36));
    
    const conn = state.peer.connect('pd-' + code, { reliable: true });
    
    conn.on('open', () => {
      state.connections[conn.peer] = conn;
      conn.send(JSON.stringify({
        type: 'player-info', name: state.myName, avatar: state.myAvatar, id: state.myId
      }));
      conn.on('data', (d) => handleMessage(conn.peer, d));
      conn.on('close', () => {
        showToast('호스트와 연결이 끊어졌습니다');
        leaveLobby();
      });
    });
    
    conn.on('error', (err) => {
      showToast('연결 실패: ' + err);
    });
    
    state.peer.on('connection', (inConn) => {
      inConn.on('open', () => {
        state.connections[inConn.peer] = inConn;
        inConn.on('data', (d) => handleMessage(inConn.peer, d));
      });
    });
    
    document.getElementById('roomCodeDisplay').textContent = code;
    document.getElementById('gameSelectArea').style.display = 'none';
    document.getElementById('startGameBtn').style.display = 'none';
    document.getElementById('waitingMsg').style.display = 'block';
    showScreen('lobby');
    
  } catch(e) { console.error(e); }
}

function handlePlayerJoin(peerId, msg) {
  if(!state.isHost) return;
  if(state.players.length >= 14) {
    sendTo(peerId, { type: 'room-full' });
    return;
  }
  state.players.push({ id: peerId, name: msg.name, avatar: msg.avatar, isHost: false });
  broadcast({ type: 'player-list', players: state.players });
  updateLobbyUI();
  showToast(msg.name + ' 참가!');
}

function leaveLobby() {
  if(state.peer) { state.peer.destroy(); state.peer = null; }
  state.connections = {};
  state.players = [];
  state.poker = null;
  state.mafia = null;
  showScreen('mainMenu');
}

function leaveGame() { leaveLobby(); }

function copyRoomCode() {
  const url = location.origin + location.pathname + '?room=' + state.roomCode;
  navigator.clipboard?.writeText(state.roomCode).then(() => showToast('코드 복사됨: ' + state.roomCode));
}

function shareLink() {
  const url = location.origin + location.pathname + '?room=' + state.roomCode;
  if(navigator.share) {
    navigator.share({ title: '파티덱', text: '파티덱 게임에 참가하세요! 코드: ' + state.roomCode, url: url });
  } else {
    navigator.clipboard?.writeText(url).then(() => showToast('링크가 복사되었습니다'));
  }
}

function shareApp() {
  const url = location.origin + location.pathname;
  if(navigator.share) {
    navigator.share({ title: '파티덱', text: '파티덱 - 서버 없이 즐기는 미니게임!', url: url });
  } else {
    navigator.clipboard?.writeText(url).then(() => showToast('링크가 복사되었습니다'));
  }
}

function updateLobbyUI() {
  const list = document.getElementById('playerList');
  list.innerHTML = state.players.map((p, i) => `
    <div class="player-item">
      <div class="player-avatar-sm" style="background:${PLAYER_COLORS[i % PLAYER_COLORS.length]};">${p.avatar}</div>
      <div class="player-name">${p.name}</div>
      ${p.isHost ? '<span class="host-badge">HOST</span>' : ''}
      ${p.id === state.myId ? '<span style="font-size:11px;color:var(--accent2);">나</span>' : ''}
    </div>
  `).join('');
  document.getElementById('playerCount').textContent = state.players.length;
  if(state.isHost) {
    document.getElementById('startGameBtn').style.display = state.players.length >= 2 ? 'block' : 'none';
  }
}

function selectGame(el) {
  if(el.classList.contains('disabled')) return;
  document.querySelectorAll('.game-option').forEach(o => o.classList.remove('selected'));
  el.classList.add('selected');
  state.selectedGame = el.dataset.game;
}

// ===== GAME START =====
function startGame() {
  if(!state.isHost || state.players.length < 2) { showToast('최소 2명 필요'); return; }
  const g = state.selectedGame;
  if(g === 'poker') startPoker();
  else if(g === 'mafia') startMafia();
  else if(g === 'sutda') startSutda();
  else if(g === 'quickdraw') startQuickDraw();
  else if(g === 'roulette') startRussianRoulette();
  else if(g === 'racing') startRacing();
  else if(g === 'lottery') startLottery();
  else if(g === 'ecard') startECard();
  else if(g === 'yahtzee') startYahtzee();
  else if(g === 'updown') startUpDown();
  else if(g === 'truth') startTruthGame();
  else showToast('준비 중인 게임입니다');
}

function handleGameStart(msg) {
  if(msg.game === 'poker') { showScreen('pokerGame'); renderPokerView(msg.state); }
  else if(msg.game === 'mafia') { showScreen('mafiaGame'); }
  else if(msg.game === 'sutda') { showScreen('sutdaGame'); renderSutdaView(msg.state); }
  else if(msg.game === 'quickdraw') {
    showScreen('quickDrawGame');
    qdState = msg.state;
    renderQuickDrawView(qdState);
  }
  else if(msg.game === 'roulette') {
    showScreen('rouletteGame');
    renderRouletteView(msg.state);
  }
  else if(msg.game === 'racing') { showScreen('racingGame'); document.getElementById('racingModeSelect').style.display = 'flex'; }
  else if(msg.game === 'lottery') {
    if(msg.state) {
      showScreen('lotteryGame');
      if(msg.state.mode === 'lottery') {
        switchLotteryMode('lottery');
        if(msg.state.phase === 'playing') {
          renderLotteryGame(msg.state);
        } else {
          renderLotterySetup();
        }
      } else {
        switchLotteryMode('roulette');
        if(msg.state.phase === 'playing') {
          renderRouletteGame(msg.state);
        } else {
          renderRouletteSetup();
        }
      }
    }
  }
  else if(msg.game === 'updown') { showScreen('updownGame'); renderUpDownView(msg.state); }
  else if(msg.game === 'yahtzee') { showScreen('yahtzeeGame'); renderYahtzeeView(msg.state); }
  else if(msg.game === 'ecard') { showScreen('ecardGame'); renderECardView(msg.state); }
  else if(msg.game === 'truth') {
    showScreen('truthGame');
    renderTruthView(msg.state);
  }
}

// =======================================
// ===== POKER ENGINE (Host-side) =====
// =======================================
function createDeck() {
  const deck = [];
  for(const s of SUITS) for(const r of RANKS) deck.push({ rank: r, suit: s });
  for(let i = deck.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [deck[i], deck[j]] = [deck[j], deck[i]];
  }
  return deck;
}

function startPoker() {
  const deck = createDeck();
  const n = state.players.length;
  const prevChips = state.poker?.players;
  
  const ps = {
    deck, deckIdx: 0,
    players: state.players.map((p, i) => ({
      id: p.id, name: p.name, avatar: p.avatar,
      cards: [], chips: prevChips ? (prevChips.find(pp => pp.id === p.id)?.chips || 1000) : 1000,
      bet: 0, totalBet: 0, folded: false, allIn: false, seatIdx: i, acted: false,
    })),
    community: [], pot: 0, currentBet: 0, minRaise: 20,
    phase: 'preflop', turnIdx: 0,
    dealerIdx: state.poker ? (state.poker.dealerIdx + 1) % n : 0,
    sb: 10, bb: 20,
  };
  
  // Deal
  for(let i = 0; i < n; i++) ps.players[i].cards = [deck[ps.deckIdx++], deck[ps.deckIdx++]];
  
  // Blinds
  const sbI = (ps.dealerIdx + 1) % n;
  const bbI = (ps.dealerIdx + 2) % n;
  
  const sbAmt = Math.min(ps.sb, ps.players[sbI].chips);
  ps.players[sbI].bet = sbAmt;
  ps.players[sbI].totalBet = sbAmt;
  ps.players[sbI].chips -= sbAmt;
  
  const bbAmt = Math.min(ps.bb, ps.players[bbI].chips);
  ps.players[bbI].bet = bbAmt;
  ps.players[bbI].totalBet = bbAmt;
  ps.players[bbI].chips -= bbAmt;
  
  ps.pot = sbAmt + bbAmt;
  ps.currentBet = bbAmt;
  ps.minRaise = ps.bb;
  ps.turnIdx = (bbI + 1) % n;
  
  // Skip folded/allin for turnIdx
  ps.turnIdx = findNextActive(ps, ps.turnIdx);
  
  state.poker = ps;
  broadcastPokerState();
  showScreen('pokerGame');
}

function findNextActive(ps, from) {
  let idx = from;
  for(let i = 0; i < ps.players.length; i++) {
    const p = ps.players[idx];
    if(!p.folded && !p.allIn && p.chips > 0) return idx;
    idx = (idx + 1) % ps.players.length;
  }
  return from;
}

function broadcastPokerState() {
  const ps = state.poker;
  ps.players.forEach(p => {
    const view = {
      type: 'poker-state',
      players: ps.players.map(pp => ({
        id: pp.id, name: pp.name, avatar: pp.avatar,
        chips: pp.chips, bet: pp.bet, totalBet: pp.totalBet,
        folded: pp.folded, allIn: pp.allIn, seatIdx: pp.seatIdx,
        cards: pp.id === p.id ? pp.cards : (ps.phase === 'showdown' && !pp.folded ? pp.cards : null)
      })),
      community: ps.community, pot: ps.pot, currentBet: ps.currentBet,
      minRaise: ps.minRaise, phase: ps.phase, turnIdx: ps.turnIdx,
    };
    if(p.id === state.myId) renderPokerView(view);
    else sendTo(p.id, view);
  });
}

function renderPokerView(ps) {
  state._pokerView = ps;
  const me = ps.players.find(p => p.id === state.myId);
  const isMyTurn = ps.players[ps.turnIdx]?.id === state.myId && ps.phase !== 'showdown';
  
  // Opponents
  const opArea = document.getElementById('opponentsArea');
  const ops = ps.players.filter(p => p.id !== state.myId);
  opArea.innerHTML = ops.map((p, i) => {
    const isTurn = ps.players[ps.turnIdx]?.id === p.id && ps.phase !== 'showdown';
    return `<div class="opponent-slot ${p.folded ? 'fold-overlay' : ''}">
      <div class="opponent-avatar ${isTurn ? 'active-turn' : ''}" style="background:${PLAYER_COLORS[ps.players.findIndex(pp=>pp.id===p.id) % PLAYER_COLORS.length]};">${p.avatar}</div>
      <div class="opponent-name">${p.name}</div>
      <div class="opponent-chips">💰${p.chips}</div>
      <div class="opponent-bet">${p.bet > 0 ? '🔸' + p.bet : (p.folded ? '폴드' : '')}</div>
      <div class="opponent-cards">${p.cards ? p.cards.map(c => cardHTML(c)).join('') : '<div class="card card-back"></div><div class="card card-back"></div>'}</div>
    </div>`;
  }).join('');
  
  // Community
  const cc = document.getElementById('communityCards');
  let cHTML = '';
  for(let i = 0; i < 5; i++) {
    cHTML += i < ps.community.length ? cardHTML(ps.community[i]) : '<div class="card card-placeholder"></div>';
  }
  cc.innerHTML = cHTML;
  
  // My cards
  const mc = document.getElementById('myCardsDisplay');
  mc.innerHTML = me?.cards ? me.cards.map(c => cardHTML(c)).join('') : '<div class="card card-back"></div><div class="card card-back"></div>';
  
  document.getElementById('myChipsDisplay').textContent = '💰 ' + (me?.chips || 0);
  document.getElementById('potAmount').textContent = ps.pot;
  
  const phaseNames = { preflop:'프리플랍', flop:'플랍', turn:'턴', river:'리버', showdown:'쇼다운' };
  document.getElementById('roundDisplay').textContent = phaseNames[ps.phase] || ps.phase;
  
  // Hand rank
  if(me?.cards && ps.community.length > 0) {
    document.getElementById('handRankDisplay').textContent = evaluateHandName([...me.cards, ...ps.community]);
  } else {
    document.getElementById('handRankDisplay').textContent = '';
  }
  
  // Actions
  const btns = document.getElementById('actionBar').querySelectorAll('.action-btn');
  const ccb = document.getElementById('checkCallBtn');
  
  if(!isMyTurn || me?.folded || me?.allIn) {
    btns.forEach(b => b.disabled = true);
  } else {
    btns.forEach(b => b.disabled = false);
    const toCall = ps.currentBet - (me?.bet || 0);
    if(toCall > 0) {
      ccb.textContent = `콜 ${Math.min(toCall, me.chips)}`;
      ccb.className = 'action-btn btn-call';
      ccb.onclick = () => pokerAction('call');
    } else {
      ccb.textContent = '체크';
      ccb.className = 'action-btn btn-check';
      ccb.onclick = () => pokerAction('check');
    }
    const slider = document.getElementById('raiseSlider');
    const minR = ps.currentBet + ps.minRaise;
    slider.min = minR;
    slider.max = me.chips + me.bet;
    slider.value = minR;
    document.getElementById('raiseAmountDisplay').textContent = minR;
  }
}

function cardHTML(c) {
  if(!c) return '<div class="card card-back"></div>';
  const red = c.suit === '♥' || c.suit === '♦';
  return `<div class="card card-face ${red ? 'red' : 'black'}"><span class="card-rank">${c.rank}</span><span class="card-suit">${c.suit}</span></div>`;
}

function pokerAction(action) {
  document.getElementById('raiseSliderArea').classList.remove('visible');
  if(state.isHost) processPokerAction(state.myId, action);
  else {
    const host = Object.values(state.connections)[0];
    if(host?.open) host.send(JSON.stringify({ type: 'poker-action', action }));
  }
}

function showRaiseSlider() { document.getElementById('raiseSliderArea').classList.toggle('visible'); }

document.getElementById('raiseSlider').addEventListener('input', e => {
  document.getElementById('raiseAmountDisplay').textContent = e.target.value;
});

function confirmRaise() {
  const amt = parseInt(document.getElementById('raiseSlider').value);
  document.getElementById('raiseSliderArea').classList.remove('visible');
  if(state.isHost) processPokerAction(state.myId, 'raise', amt);
  else {
    const host = Object.values(state.connections)[0];
    if(host?.open) host.send(JSON.stringify({ type: 'poker-action', action: 'raise', amount: amt }));
  }
}

function processPokerAction(playerId, action, amount) {
  const ps = state.poker;
  if(!ps || ps.phase === 'showdown') return;
  
  const pIdx = ps.players.findIndex(p => p.id === playerId);
  if(pIdx !== ps.turnIdx) return;
  
  const player = ps.players[pIdx];
  if(player.folded || player.allIn) return;
  
  const toCall = ps.currentBet - player.bet;
  
  switch(action) {
    case 'fold': player.folded = true; break;
    case 'check': if(toCall > 0) return; break;
    case 'call': {
      const a = Math.min(toCall, player.chips);
      player.chips -= a; player.bet += a; player.totalBet += a; ps.pot += a;
      if(player.chips === 0) player.allIn = true;
      break;
    }
    case 'raise': {
      const total = amount || (ps.currentBet + ps.minRaise);
      const a = total - player.bet;
      if(a > player.chips) return;
      player.chips -= a; player.bet += a; player.totalBet += a; ps.pot += a;
      ps.minRaise = total - ps.currentBet; ps.currentBet = player.bet;
      if(player.chips === 0) player.allIn = true;
      // Reset acted flags for others (they need to respond to raise)
      ps.players.forEach((p, i) => { if(i !== pIdx && !p.folded && !p.allIn) p.acted = false; });
      break;
    }
    case 'allin': {
      const a = player.chips;
      player.bet += a; player.totalBet += a; ps.pot += a; player.chips = 0; player.allIn = true;
      if(player.bet > ps.currentBet) {
        ps.minRaise = player.bet - ps.currentBet; ps.currentBet = player.bet;
        ps.players.forEach((p, i) => { if(i !== pIdx && !p.folded && !p.allIn) p.acted = false; });
      }
      break;
    }
  }
  
  player.acted = true;
  
  // Only one left?
  const active = ps.players.filter(p => !p.folded);
  if(active.length === 1) { endPokerHand(active[0]); return; }
  
  // Check if betting round complete
  const canAct = ps.players.filter(p => !p.folded && !p.allIn);
  const allActed = canAct.every(p => p.acted && p.bet === ps.currentBet);
  
  if(canAct.length === 0 || allActed) {
    advancePokerPhase();
    return;
  }
  
  // Next player
  ps.turnIdx = findNextActive(ps, (ps.turnIdx + 1) % ps.players.length);
  broadcastPokerState();
}

function advancePokerPhase() {
  const ps = state.poker;
  
  ps.players.forEach(p => { p.bet = 0; p.acted = false; });
  ps.currentBet = 0;
  ps.turnIdx = findNextActive(ps, (ps.dealerIdx + 1) % ps.players.length);
  
  switch(ps.phase) {
    case 'preflop':
      ps.phase = 'flop';
      ps.deckIdx++;
      ps.community.push(ps.deck[ps.deckIdx++], ps.deck[ps.deckIdx++], ps.deck[ps.deckIdx++]);
      break;
    case 'flop':
      ps.phase = 'turn';
      ps.deckIdx++;
      ps.community.push(ps.deck[ps.deckIdx++]);
      break;
    case 'turn':
      ps.phase = 'river';
      ps.deckIdx++;
      ps.community.push(ps.deck[ps.deckIdx++]);
      break;
    case 'river':
      ps.phase = 'showdown';
      resolveShowdown();
      return;
  }
  
  const canAct = ps.players.filter(p => !p.folded && !p.allIn);
  if(canAct.length <= 1) {
    broadcastPokerState();
    setTimeout(() => advancePokerPhase(), 800);
    return;
  }
  
  broadcastPokerState();
}

function resolveShowdown() {
  const ps = state.poker;
  const active = ps.players.filter(p => !p.folded);
  
  let best = -1, winner = null;
  active.forEach(p => {
    const s = evaluateHand([...p.cards, ...ps.community]);
    p._score = s;
    p._handName = evaluateHandName([...p.cards, ...ps.community]);
    if(s > best) { best = s; winner = p; }
  });
  
  if(winner) endPokerHand(winner);
}

function endPokerHand(winner) {
  const ps = state.poker;
  winner.chips += ps.pot;
  
  const result = {
    type: 'poker-result',
    winnerId: winner.id, winnerName: winner.name, winnerAvatar: winner.avatar,
    winnerCards: winner.cards, handName: winner._handName || '최후의 1인', pot: ps.pot,
  };
  
  ps.phase = 'showdown';
  broadcastPokerState();
  setTimeout(() => { broadcast(result); handlePokerResult(result); }, 1200);
}

function handlePokerResult(msg) {
  const won = msg.winnerId === state.myId;
  recordGame(won);
  
  document.getElementById('resultTitle').textContent = won ? '🏆 승리!' : '😢 패배...';
  document.getElementById('resultTitle').style.color = won ? 'var(--gold)' : 'var(--text-dim)';
  document.getElementById('winnerName').textContent = msg.winnerName + ' ' + msg.winnerAvatar;
  document.getElementById('resultHand').textContent = msg.handName;
  document.getElementById('resultPot').textContent = '💰 ' + msg.pot;
  document.getElementById('resultCards').innerHTML = msg.winnerCards ? msg.winnerCards.map(c => cardHTML(c)).join('') : '';
  document.getElementById('resultOverlay').classList.add('active');
}

function closeResult() {
  document.getElementById('resultOverlay').classList.remove('active');
  if(state.isHost) setTimeout(() => startPoker(), 300);
}

// ===== HAND EVALUATION =====
function cardValue(r) {
  return {'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'10':10,'J':11,'Q':12,'K':13,'A':14}[r]||0;
}

function evaluateHand(cards) {
  if(!cards || cards.length < 5) return 0;
  let best = 0;
  for(const combo of getCombos(cards, 5)) {
    const s = scoreHand(combo);
    if(s > best) best = s;
  }
  return best;
}

function evaluateHandName(cards) {
  if(!cards || cards.length < 5) return '';
  let best = 0, bestH = null;
  for(const combo of getCombos(cards, 5)) {
    const s = scoreHand(combo);
    if(s > best) { best = s; bestH = combo; }
  }
  const cat = Math.floor(best / 1000000);
  return ['','하이카드','원페어','투페어','쓰리카드','스트레이트','플러시','풀하우스','포카드','스트레이트 플러시','로얄 플러시'][cat] || '';
}

function scoreHand(hand) {
  const vals = hand.map(c => cardValue(c.rank)).sort((a,b) => b - a);
  const suits = hand.map(c => c.suit);
  const isFlush = suits.every(s => s === suits[0]);
  const unique = [...new Set(vals)].sort((a,b) => b - a);
  let isStraight = false;
  
  if(unique.length === 5) {
    if(unique[0] - unique[4] === 4) isStraight = true;
    if(unique[0] === 14 && unique[1] === 5) isStraight = true;
  }
  
  const counts = {};
  vals.forEach(v => counts[v] = (counts[v]||0)+1);
  const groups = Object.entries(counts).sort((a,b) => b[1]-a[1] || parseInt(b[0])-parseInt(a[0]));
  const pattern = groups.map(g => g[1]).join('');
  
  let cat = 1;
  if(isStraight && isFlush && vals[0] === 14) cat = 10; // Royal
  else if(isStraight && isFlush) cat = 9;
  else if(pattern === '41') cat = 8;
  else if(pattern === '32') cat = 7;
  else if(isFlush) cat = 6;
  else if(isStraight) cat = 5;
  else if(pattern === '311') cat = 4;
  else if(pattern === '221') cat = 3;
  else if(pattern === '2111') cat = 2;
  
  let sub = 0;
  groups.forEach((g, i) => sub += parseInt(g[0]) * Math.pow(15, 4-i));
  return cat * 1000000 + sub;
}

function getCombos(arr, k) {
  if(k === 0) return [[]];
  if(!arr.length) return [];
  const [first, ...rest] = arr;
  return [...getCombos(rest, k-1).map(c => [first,...c]), ...getCombos(rest, k)];
}

// ====================================================================
// ===== MAFIA FULL VERSION ENGINE ====================================
// ====================================================================

/*
 * Replaces the basic startMafia() with a complete 11-role implementation.
 *
 * ROLES:
 *  마피아팀: mafia (x2), spy
 *  시민팀:   police, doctor, reporter, undertaker, detective,
 *            senator, soldier, lover (x2), baeksu (unemployed), citizen
 *
 * Architecture:
 *  - Host-authoritative: all game state lives on host
 *  - Host sends each player a personalized "view" object
 *  - Clients render purely from their view
 *  - Night actions collected from all players, resolved simultaneously on host
 *
 * Message types used:
 *  Host -> Client:  { type: 'mf-state', ...viewData }
 *  Host -> Client:  { type: 'mf-result', winner, message }
 *  Client -> Host:  { type: 'mf-action', action, targetId, extra }
 *  Client -> Host:  { type: 'mf-vote', targetId }
 *  Client -> Host:  { type: 'mf-chat', text }
 *  Client -> Host:  { type: 'mf-extend' }
 *  Client -> Host:  { type: 'mf-skip-vote' }
 */

// ========================= CONSTANTS =========================

const MF_ROLES = {
  mafia:      { emoji: '🔪', name: '마피아',   team: 'mafia',   desc: '밤에 팀원과 상의하여 1명을 제거하세요' },
  spy:        { emoji: '🕵️', name: '스파이',   team: 'mafia',   desc: '밤마다 마피아를 1명 찾을 수 있습니다' },
  police:     { emoji: '🔍', name: '경찰',     team: 'citizen', desc: '밤마다 1명이 마피아인지 조사합니다' },
  doctor:     { emoji: '💊', name: '의사',     team: 'citizen', desc: '밤마다 1명을 치료하여 마피아 공격을 막습니다' },
  reporter:   { emoji: '📰', name: '기자',     team: 'citizen', desc: '밤마다 1명이 스파이인지 조사합니다' },
  undertaker: { emoji: '⚰️', name: '장의사',   team: 'citizen', desc: '밤에 죽은 시체가 마피아인지 시민인지 확인합니다' },
  detective:  { emoji: '🔎', name: '탐정',     team: 'citizen', desc: '시민이 죽으면 그 시민을 죽인 마피아를 알 수 있습니다' },
  senator:    { emoji: '🏛️', name: '국회의원', team: 'citizen', desc: '투표로 처형당하지 않습니다' },
  soldier:    { emoji: '🛡️', name: '군인',     team: 'citizen', desc: '마피아 일반 공격을 1회 막을 수 있습니다 (저격은 즉사)' },
  lover:      { emoji: '💕', name: '연인',     team: 'citizen', desc: '서로 연인이 누구인지 알고 시작합니다' },
  baeksu:     { emoji: '😴', name: '백수',     team: 'citizen', desc: '4번째 사망 시, 첫 사망자의 직업을 이어받습니다' },
  citizen:    { emoji: '👤', name: '시민',     team: 'citizen', desc: '마피아를 찾아 투표하세요' },
};

const MF_PHASE_LABELS = {
  'role-reveal': { icon: '🎭', text: '역할 배분', cls: 'night' },
  'night':       { icon: '🌙', text: '밤',       cls: 'night' },
  'day-announce': { icon: '☀️', text: '아침 발표', cls: 'day' },
  'day-discuss':  { icon: '☀️', text: '토론',     cls: 'day' },
  'day-vote':     { icon: '🗳️', text: '투표',     cls: 'vote' },
  'vote-result':  { icon: '⚖️', text: '처형 결과', cls: 'vote' },
  'result':       { icon: '🏆', text: '게임 종료', cls: 'result' },
};

const MF_NIGHT_DURATION = 30;
const MF_DISCUSS_DURATION = 180;
const MF_VOTE_DURATION = 30;
const MF_ANNOUNCE_DURATION = 8;
const MF_REVEAL_DURATION = 8;
const MF_VOTE_RESULT_DURATION = 6;

// ========================= HOST STATE =========================

let mfState = null;    // host-only full state
let mfView = null;     // local player's current view
let mfTimer = null;    // interval id
let mfSelectedTarget = null;
let mfUseSnipe = false;

// ========================= ROLE ASSIGNMENT ====================

function mfAssignRoles(playerCount) {
  // Role distribution based on player count
  const roles = [];

  if (playerCount <= 5) {
    // Minimum: 1 mafia, doctor, police, citizens
    roles.push('mafia', 'doctor', 'police');
    while (roles.length < playerCount) roles.push('citizen');
  } else if (playerCount <= 7) {
    // 6-7 players: 2 mafia, doctor, police, citizens
    roles.push('mafia', 'mafia', 'doctor', 'police');
    while (roles.length < playerCount) roles.push('citizen');
  } else if (playerCount <= 9) {
    // 8-9 players: 2 mafia, spy, doctor, police, reporter, citizens
    roles.push('mafia', 'mafia', 'spy', 'doctor', 'police', 'reporter');
    while (roles.length < playerCount) roles.push('citizen');
  } else if (playerCount <= 10) {
    // 10 players: core + senator, soldier
    roles.push('mafia', 'mafia', 'spy', 'doctor', 'police', 'reporter',
               'senator', 'soldier');
    while (roles.length < playerCount) roles.push('citizen');
  } else {
    // 11+ players: full role set
    roles.push('mafia', 'mafia', 'spy',
               'police', 'doctor', 'reporter', 'undertaker', 'detective',
               'senator', 'soldier');
    // Add lovers if 11+
    if (playerCount >= 11) {
      roles.push('lover', 'lover');
    }
    // Add baeksu if 13+
    if (playerCount >= 13) {
      roles.push('baeksu');
    }
    // Fill remainder with citizens
    while (roles.length < playerCount) roles.push('citizen');
  }

  // Shuffle
  for (let i = roles.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [roles[i], roles[j]] = [roles[j], roles[i]];
  }
  return roles;
}

// ========================= START GAME =========================

function startMafia() {
  if (!state.isHost) return;
  const n = state.players.length;
  if (n < 4) {
    showToast('마피아는 최소 4명이 필요합니다');
    return;
  }

  const roles = mfAssignRoles(n);

  // Find lover partner IDs
  const loverIndices = [];
  roles.forEach((r, i) => { if (r === 'lover') loverIndices.push(i); });

  mfState = {
    phase: 'role-reveal',
    round: 1,
    players: state.players.map((p, i) => ({
      id: p.id,
      name: p.name,
      avatar: p.avatar,
      isHost: p.isHost || false,
      role: roles[i],             // original assigned role
      activeRole: roles[i],       // can change for baeksu
      alive: true,
      lives: roles[i] === 'soldier' ? 2 : 1,
      snipesLeft: roles[i] === 'mafia' ? 1 : 0,
      // Spy tracking
      spyFoundMafia: false,
      // Baeksu tracking
      baeksuInherited: false,
      // Senator immunity revealed
      senatorRevealed: false,
      // Lover partner
      loverPartnerId: null,
    })),
    // Night action collection
    nightActions: {},
    // Who killed whom (for detective tracking)
    killLog: [],     // { victimId, killerId, method:'kill'|'snipe', round }
    // Death order for baeksu mechanic
    deathOrder: [],  // ordered list of player IDs who died
    // Mafia team chat
    chatMessages: [], // { sender, senderName, text, round }
    // Spy's discovered info
    spyKnownRoles: {},  // { deadPlayerId: roleLabel }
    // Votes
    votes: {},          // { voterId: targetId | 'skip' }
    // Extension tracking
    extensionUsed: {},  // { playerId: true } per day
    extensionAdded: false,
    // Timer
    timer: MF_REVEAL_DURATION,
    // Announcement messages for day phase
    announcements: [],
    // For 6-player rule: first night doctor-only scan
    sixPlayerFirstNight: (n === 6),
  };

  // Assign lover partners
  if (loverIndices.length === 2) {
    const p0 = mfState.players[loverIndices[0]];
    const p1 = mfState.players[loverIndices[1]];
    p0.loverPartnerId = p1.id;
    p1.loverPartnerId = p0.id;
  }

  mfBroadcastState();
  showScreen('mafiaGame');
  mfStartTimer();
}

// ========================= TIMER ==============================

function mfStartTimer() {
  clearInterval(mfTimer);
  mfTimer = setInterval(() => {
    if (!mfState) return;
    mfState.timer--;

    // Update local display
    const timerEl = document.getElementById('mfTimer');
    if (timerEl) timerEl.textContent = mfState.timer;

    if (mfState.timer <= 0) {
      clearInterval(mfTimer);
      if (state.isHost) mfAdvancePhase();
    }
  }, 1000);
}

function mfSetPhaseTimer(duration) {
  mfState.timer = duration;
  mfStartTimer();
}

// ========================= PHASE ADVANCEMENT ==================

function mfAdvancePhase() {
  if (!state.isHost || !mfState) return;

  const phase = mfState.phase;

  if (phase === 'role-reveal') {
    // Move to first night
    mfState.phase = 'night';
    mfState.nightActions = {};
    mfSetPhaseTimer(MF_NIGHT_DURATION);

    // For 6-player variant: first night only doctor scans
    // (handled in night action validation)
  }
  else if (phase === 'night') {
    mfResolveNight();
  }
  else if (phase === 'day-announce') {
    mfState.phase = 'day-discuss';
    mfState.votes = {};
    mfState.extensionUsed = {};
    mfState.extensionAdded = false;
    mfSetPhaseTimer(MF_DISCUSS_DURATION);
  }
  else if (phase === 'day-discuss') {
    mfState.phase = 'day-vote';
    mfState.votes = {};
    mfSetPhaseTimer(MF_VOTE_DURATION);
  }
  else if (phase === 'day-vote') {
    mfResolveVote();
  }
  else if (phase === 'vote-result') {
    // Check win condition
    if (mfCheckWin()) return;
    // Go to night
    mfState.phase = 'night';
    mfState.round++;
    mfState.nightActions = {};
    mfState.announcements = [];
    mfSetPhaseTimer(MF_NIGHT_DURATION);
  }

  mfBroadcastState();
}

// ========================= NIGHT RESOLUTION ===================

function mfResolveNight() {
  const ms = mfState;
  const actions = ms.nightActions;
  const announcements = [];

  // --- Collect mafia team actions ---
  // Find mafia kill action (only 1 mafia acts per night for kill/snipe)
  let killTargetId = null;
  let killerId = null;
  let isSnipe = false;

  // Iterate mafia actions
  const mafiaPlayers = ms.players.filter(p => p.activeRole === 'mafia' && p.alive);
  for (const mp of mafiaPlayers) {
    const act = actions[mp.id];
    if (act && act.action === 'kill') {
      killTargetId = act.targetId;
      killerId = mp.id;
      isSnipe = false;
      break;
    }
    if (act && act.action === 'snipe') {
      killTargetId = act.targetId;
      killerId = mp.id;
      isSnipe = true;
      break;
    }
  }

  // --- Doctor heal target ---
  const doctorPlayer = ms.players.find(p => p.activeRole === 'doctor' && p.alive);
  let healTargetId = null;
  if (doctorPlayer && actions[doctorPlayer.id]) {
    healTargetId = actions[doctorPlayer.id].targetId;
  }

  // --- Detective tracking target ---
  const detectivePlayer = ms.players.find(p => p.activeRole === 'detective' && p.alive);
  let detectiveTargetId = null;
  if (detectivePlayer && actions[detectivePlayer.id]) {
    detectiveTargetId = actions[detectivePlayer.id].targetId;
  }

  // --- Police investigation ---
  const policePlayer = ms.players.find(p => p.activeRole === 'police' && p.alive);
  let policeTargetId = null;
  let policeResult = null;
  if (policePlayer && actions[policePlayer.id]) {
    policeTargetId = actions[policePlayer.id].targetId;
    const target = ms.players.find(p => p.id === policeTargetId);
    if (target) {
      const isMafia = (target.activeRole === 'mafia');
      policeResult = { targetId: policeTargetId, targetName: target.name, isMafia };
    }
  }

  // --- Reporter investigation (looking for spy) ---
  const reporterPlayer = ms.players.find(p => p.activeRole === 'reporter' && p.alive);
  let reporterTargetId = null;
  let reporterResult = null;
  if (reporterPlayer && actions[reporterPlayer.id]) {
    reporterTargetId = actions[reporterPlayer.id].targetId;
    const target = ms.players.find(p => p.id === reporterTargetId);
    if (target) {
      const isSpy = (target.activeRole === 'spy');
      reporterResult = { targetId: reporterTargetId, targetName: target.name, isSpy };
    }
  }

  // --- Spy investigation (looking for mafia) ---
  const spyPlayer = ms.players.find(p => p.activeRole === 'spy' && p.alive);
  let spyTargetId = null;
  let spyResult = null;
  if (spyPlayer && actions[spyPlayer.id]) {
    spyTargetId = actions[spyPlayer.id].targetId;
    const target = ms.players.find(p => p.id === spyTargetId);
    if (target) {
      const isMafia = (target.activeRole === 'mafia');
      if (isMafia) {
        spyPlayer.spyFoundMafia = true;
      }
      spyResult = { targetId: spyTargetId, targetName: target.name, isMafia };
    }
  }

  // --- Undertaker target (check corpse from last night/vote death) ---
  const undertakerPlayer = ms.players.find(p => p.activeRole === 'undertaker' && p.alive);
  let undertakerTargetId = null;
  let undertakerResult = null;
  if (undertakerPlayer && actions[undertakerPlayer.id]) {
    undertakerTargetId = actions[undertakerPlayer.id].targetId;
    const target = ms.players.find(p => p.id === undertakerTargetId);
    if (target && !target.alive) {
      // Spy shows as citizen
      const showTeam = (target.activeRole === 'mafia') ? '마피아' : '시민';
      undertakerResult = { targetId: undertakerTargetId, targetName: target.name, team: showTeam };
    }
  }

  // =========================
  // RESOLVE KILL
  // =========================
  let killedPlayer = null;
  let killBlocked = false;
  let deathMessage = '';

  if (killTargetId) {
    const victim = ms.players.find(p => p.id === killTargetId);
    if (victim && victim.alive) {
      if (isSnipe) {
        // Snipe bypasses doctor, soldier, detective
        victim.alive = false;
        victim.lives = 0;
        killedPlayer = victim;
        deathMessage = 'snipe';

        // Deduct snipe from killer
        const killer = ms.players.find(p => p.id === killerId);
        if (killer) killer.snipesLeft = Math.max(0, killer.snipesLeft - 1);

        // Log kill
        ms.killLog.push({ victimId: victim.id, killerId, method: 'snipe', round: ms.round });
        ms.deathOrder.push(victim.id);

        announcements.push({
          type: 'snipe',
          icon: '🎯',
          text: `${victim.name}님이 저격당했습니다!`
        });
      } else {
        // Normal kill - check doctor heal and soldier
        if (healTargetId === killTargetId) {
          // Doctor saved
          killBlocked = true;
          announcements.push({
            type: 'safe',
            icon: '🌙',
            text: '밤에 아무 일도 일어나지 않았습니다.'
          });
        } else if (victim.activeRole === 'soldier' && victim.lives > 1) {
          // Soldier survives
          victim.lives--;
          killBlocked = true;
          announcements.push({
            type: 'safe',
            icon: '🌙',
            text: '밤에 아무 일도 일어나지 않았습니다.'
          });
        } else {
          // Victim dies
          victim.alive = false;
          victim.lives = 0;
          killedPlayer = victim;
          deathMessage = 'kill';

          ms.killLog.push({ victimId: victim.id, killerId, method: 'kill', round: ms.round });
          ms.deathOrder.push(victim.id);

          announcements.push({
            type: 'death',
            icon: '💀',
            text: `${victim.name}님이 마피아에게 살해당했습니다.`
          });
        }
      }
    }
  } else {
    // No mafia action
    announcements.push({
      type: 'safe',
      icon: '🌙',
      text: '평화로운 밤이었습니다.'
    });
  }

  // --- Detective result (only if a citizen was killed by normal kill) ---
  let detectiveResult = null;
  if (detectivePlayer && detectivePlayer.alive && detectiveTargetId && killedPlayer) {
    // Detective was tracking the killed person
    if (detectiveTargetId === killedPlayer.id && deathMessage === 'kill') {
      const killerP = ms.players.find(p => p.id === killerId);
      if (killerP) {
        detectiveResult = { victimName: killedPlayer.name, killerName: killerP.name, killerId };
      }
    }
    // Note: snipe bypasses detective
  }

  // --- Spy: update dead player roles knowledge ---
  if (spyPlayer && spyPlayer.alive) {
    ms.players.forEach(p => {
      if (!p.alive && !ms.spyKnownRoles[p.id]) {
        // Spy can see dead player's role
        ms.spyKnownRoles[p.id] = MF_ROLES[p.activeRole]?.name || '시민';
      }
    });
  }

  // --- Baeksu mechanic: 4th death triggers inheritance ---
  if (ms.deathOrder.length >= 4) {
    const baeksuPlayer = ms.players.find(p => p.activeRole === 'baeksu' && p.alive && !p.baeksuInherited);
    if (baeksuPlayer) {
      let inheritFrom = null;
      // First death's role
      const firstDead = ms.players.find(p => p.id === ms.deathOrder[0]);
      if (firstDead) {
        const firstRole = firstDead.activeRole;
        const firstTeam = MF_ROLES[firstRole]?.team;
        if (firstTeam === 'mafia') {
          // If first dead was mafia team, inherit next citizen's role
          for (let i = 1; i < ms.deathOrder.length; i++) {
            const dp = ms.players.find(p => p.id === ms.deathOrder[i]);
            if (dp && MF_ROLES[dp.activeRole]?.team === 'citizen') {
              inheritFrom = dp;
              break;
            }
          }
        } else {
          inheritFrom = firstDead;
        }
      }

      if (inheritFrom) {
        baeksuPlayer.activeRole = inheritFrom.activeRole;
        baeksuPlayer.baeksuInherited = true;
        // Copy special attributes
        if (inheritFrom.activeRole === 'soldier') {
          baeksuPlayer.lives = 2;
        }
      }
    }
  }

  // Store announcements
  ms.announcements = announcements;

  // Store personal results for this night
  ms._nightResults = {
    policeResult,
    reporterResult,
    spyResult,
    detectiveResult,
    undertakerResult,
    killedPlayer,
    deathMessage,
  };

  // Check win
  if (mfCheckWin()) return;

  // Move to day announce
  ms.phase = 'day-announce';
  mfSetPhaseTimer(MF_ANNOUNCE_DURATION);
  mfBroadcastState();
}

// ========================= VOTE RESOLUTION ====================

function mfResolveVote() {
  const ms = mfState;
  const votes = ms.votes;

  // Count votes
  const counts = {};
  let skipCount = 0;
  Object.values(votes).forEach(v => {
    if (v === 'skip') { skipCount++; return; }
    counts[v] = (counts[v] || 0) + 1;
  });

  // Find highest vote
  let maxVotes = 0;
  let candidates = [];
  Object.entries(counts).forEach(([pid, c]) => {
    if (c > maxVotes) {
      maxVotes = c;
      candidates = [pid];
    } else if (c === maxVotes) {
      candidates.push(pid);
    }
  });

  const announcements = [];

  if (candidates.length === 1 && maxVotes > skipCount) {
    const targetId = candidates[0];
    const target = ms.players.find(p => p.id === targetId);

    if (target) {
      // Check senator immunity
      if (target.activeRole === 'senator' && !target.senatorRevealed) {
        target.senatorRevealed = true;
        announcements.push({
          type: 'immunity',
          icon: '🏛️',
          text: `${target.name}님은 국회의원입니다! 투표로 처형할 수 없습니다.`
        });
      } else {
        // Execute
        target.alive = false;
        target.lives = 0;
        ms.deathOrder.push(target.id);

        const roleName = MF_ROLES[target.activeRole]?.name || '시민';
        const teamLabel = MF_ROLES[target.activeRole]?.team === 'mafia' ? '마피아팀' : '시민팀';

        announcements.push({
          type: 'vote-result',
          icon: '⚖️',
          text: `${target.name}님이 처형되었습니다. 정체: ${roleName} (${teamLabel})`
        });

        // Check baeksu inheritance
        if (ms.deathOrder.length >= 4) {
          const baeksu = ms.players.find(p => p.activeRole === 'baeksu' && p.alive && !p.baeksuInherited);
          if (baeksu) {
            const firstDead = ms.players.find(p => p.id === ms.deathOrder[0]);
            if (firstDead) {
              const firstTeam = MF_ROLES[firstDead.activeRole]?.team;
              let inheritFrom = null;
              if (firstTeam === 'mafia') {
                for (let i = 1; i < ms.deathOrder.length; i++) {
                  const dp = ms.players.find(p => p.id === ms.deathOrder[i]);
                  if (dp && MF_ROLES[dp.activeRole]?.team === 'citizen') {
                    inheritFrom = dp;
                    break;
                  }
                }
              } else {
                inheritFrom = firstDead;
              }
              if (inheritFrom) {
                baeksu.activeRole = inheritFrom.activeRole;
                baeksu.baeksuInherited = true;
                if (inheritFrom.activeRole === 'soldier') baeksu.lives = 2;
              }
            }
          }
        }
      }
    }
  } else if (candidates.length > 1) {
    announcements.push({
      type: 'safe',
      icon: '⚖️',
      text: '투표가 동률입니다. 아무도 처형되지 않았습니다.'
    });
  } else {
    announcements.push({
      type: 'safe',
      icon: '⚖️',
      text: '과반수 건너뛰기로 아무도 처형되지 않았습니다.'
    });
  }

  ms.announcements = announcements;
  ms._nightResults = null;
  ms.votes = {};

  // Check win
  if (mfCheckWin()) return;

  ms.phase = 'vote-result';
  mfSetPhaseTimer(MF_VOTE_RESULT_DURATION);
  mfBroadcastState();
}

// ========================= WIN CHECK ==========================

function mfCheckWin() {
  const ms = mfState;
  const alive = ms.players.filter(p => p.alive);
  const mafiaAlive = alive.filter(p => MF_ROLES[p.activeRole]?.team === 'mafia').length;
  const citizenAlive = alive.filter(p => MF_ROLES[p.activeRole]?.team !== 'mafia').length;

  let winner = null;
  let message = '';

  if (mafiaAlive === 0) {
    winner = 'citizen';
    message = '시민 팀 승리! 모든 마피아가 제거되었습니다.';
  } else if (mafiaAlive >= citizenAlive) {
    winner = 'mafia';
    message = '마피아 팀 승리! 마피아가 도시를 장악했습니다.';
  }

  if (winner) {
    ms.phase = 'result';
    clearInterval(mfTimer);
    mfBroadcastState();

    const result = { type: 'mf-result', winner, message };
    broadcast(result);
    mfHandleResult(result);
    return true;
  }
  return false;
}

// ========================= STATE BROADCAST ====================

function mfBroadcastState() {
  if (!mfState) return;
  const ms = mfState;

  ms.players.forEach(p => {
    const view = mfBuildView(p.id);
    if (p.id === state.myId) {
      mfView = view;
      mfRenderView();
    } else {
      sendTo(p.id, { type: 'mf-state', ...view });
    }
  });
}

function mfBuildView(playerId) {
  const ms = mfState;
  const me = ms.players.find(p => p.id === playerId);
  if (!me) return {};

  const myRole = me.activeRole;
  const myTeam = MF_ROLES[myRole]?.team || 'citizen';
  const isAlive = me.alive;
  const results = ms._nightResults || {};

  // Build player list with visibility rules
  const playersView = ms.players.map(p => {
    const pv = {
      id: p.id,
      name: p.name,
      avatar: p.avatar,
      alive: p.alive,
      isHost: p.isHost,
      isMe: p.id === playerId,
      role: null,           // hidden by default
      roleEmoji: null,
      roleName: null,
      showLoverHeart: false,
      showSoldierShield: false,
      showSnipeUsed: false,
      voteCount: 0,
    };

    // Self always sees own role
    if (p.id === playerId) {
      pv.role = p.activeRole;
      pv.roleEmoji = MF_ROLES[p.activeRole]?.emoji;
      pv.roleName = MF_ROLES[p.activeRole]?.name;
    }

    // Mafia can see other mafia
    if (myRole === 'mafia' && p.activeRole === 'mafia' && p.id !== playerId) {
      pv.role = 'mafia';
      pv.roleEmoji = '🔪';
      pv.roleName = '마피아';
    }

    // Spy who found mafia can see mafia
    if (myRole === 'spy' && me.spyFoundMafia && p.activeRole === 'mafia') {
      pv.role = 'mafia';
      pv.roleEmoji = '🔪';
      pv.roleName = '마피아';
    }

    // Lover sees partner
    if (myRole === 'lover' && me.loverPartnerId === p.id) {
      pv.showLoverHeart = true;
    }

    // Result phase: show all roles
    if (ms.phase === 'result') {
      pv.role = p.activeRole;
      pv.roleEmoji = MF_ROLES[p.activeRole]?.emoji;
      pv.roleName = MF_ROLES[p.activeRole]?.name;
    }

    // Dead player role reveal (public)
    if (!p.alive && ms.phase !== 'night' && ms.phase !== 'role-reveal') {
      pv.role = p.activeRole;
      pv.roleEmoji = MF_ROLES[p.activeRole]?.emoji;
      pv.roleName = MF_ROLES[p.activeRole]?.name;
    }

    // Soldier shield indicator (only for self or result)
    if (p.activeRole === 'soldier' && p.lives > 1 && (p.id === playerId || ms.phase === 'result')) {
      pv.showSoldierShield = true;
    }

    // Vote counts
    if (ms.phase === 'day-vote' || ms.phase === 'vote-result') {
      let vc = 0;
      Object.values(ms.votes).forEach(v => { if (v === p.id) vc++; });
      pv.voteCount = vc;
    }

    return pv;
  });

  // Build personal notifications
  const personalEvents = [];

  // Police result
  if (results.policeResult && playerId === (ms.players.find(p => p.activeRole === 'police' && p.alive)?.id)) {
    const r = results.policeResult;
    personalEvents.push({
      type: 'info',
      icon: '🔍',
      text: `${r.targetName}님은 ${r.isMafia ? '마피아입니다!' : '마피아가 아닙니다.'}`
    });
  }

  // Reporter result
  if (results.reporterResult && playerId === (ms.players.find(p => p.activeRole === 'reporter' && p.alive)?.id)) {
    const r = results.reporterResult;
    personalEvents.push({
      type: 'info',
      icon: '📰',
      text: `${r.targetName}님은 ${r.isSpy ? '스파이입니다!' : '스파이가 아닙니다.'}`
    });
  }

  // Spy result
  if (results.spyResult && playerId === (ms.players.find(p => p.activeRole === 'spy' && p.alive)?.id)) {
    const r = results.spyResult;
    personalEvents.push({
      type: 'info',
      icon: '🕵️',
      text: `${r.targetName}님은 ${r.isMafia ? '마피아입니다! 이제 마피아와 대화할 수 있습니다.' : '마피아가 아닙니다.'}`
    });
  }

  // Detective result
  if (results.detectiveResult && playerId === (ms.players.find(p => p.activeRole === 'detective' && p.alive)?.id)) {
    const r = results.detectiveResult;
    personalEvents.push({
      type: 'info',
      icon: '🔎',
      text: `${r.victimName}님을 죽인 마피아는 ${r.killerName}님입니다!`
    });
  }

  // Undertaker result
  if (results.undertakerResult && playerId === (ms.players.find(p => p.activeRole === 'undertaker' && p.alive)?.id)) {
    const r = results.undertakerResult;
    personalEvents.push({
      type: 'info',
      icon: '⚰️',
      text: `${r.targetName}님의 시체를 확인: ${r.team}입니다.`
    });
  }

  // Baeksu inheritance notification
  const mePlayer = ms.players.find(p => p.id === playerId);
  if (mePlayer && mePlayer.role === 'baeksu' && mePlayer.baeksuInherited) {
    const newRoleName = MF_ROLES[mePlayer.activeRole]?.name || '시민';
    personalEvents.push({
      type: 'info',
      icon: '😴',
      text: `백수 능력 발동! 이제 당신의 역할은 "${newRoleName}"입니다.`
    });
  }

  // Can this player chat with mafia team?
  const canChat = (myRole === 'mafia') ||
                  (myRole === 'spy' && me.spyFoundMafia);

  // What chat messages to show
  const chatView = canChat ? ms.chatMessages : [];

  // Spy dead role info
  const spyDeadRoles = (myRole === 'spy') ? ms.spyKnownRoles : {};

  // Determine what night action this player can take
  let nightAction = null;
  if (ms.phase === 'night' && isAlive) {
    // 6-player first night: only doctor scans
    const isFirstNight = ms.round === 1;
    const sixPlayerRestrict = ms.sixPlayerFirstNight && isFirstNight;

    if (myRole === 'mafia' && !sixPlayerRestrict) {
      nightAction = { type: 'mafia', canSnipe: me.snipesLeft > 0, label: '제거할 대상 선택' };
    } else if (myRole === 'spy') {
      nightAction = { type: 'spy', label: '마피아로 의심되는 대상 선택' };
    } else if (myRole === 'police' && !sixPlayerRestrict) {
      nightAction = { type: 'police', label: '조사할 대상 선택' };
    } else if (myRole === 'doctor') {
      nightAction = { type: 'doctor', label: '치료할 대상 선택' };
    } else if (myRole === 'reporter' && !sixPlayerRestrict) {
      nightAction = { type: 'reporter', label: '스파이 의심 대상 선택' };
    } else if (myRole === 'undertaker') {
      nightAction = { type: 'undertaker', label: '확인할 시체 선택' };
    } else if (myRole === 'detective' && !sixPlayerRestrict) {
      nightAction = { type: 'detective', label: '추적할 대상 선택' };
    }
  }

  // Did this player already submit night action?
  const nightActionDone = ms.nightActions[playerId] !== undefined;

  // My snipes remaining
  const mySnipesLeft = me.snipesLeft;

  // Lover partner info
  let loverPartnerName = null;
  if (myRole === 'lover' && me.loverPartnerId) {
    const partner = ms.players.find(p => p.id === me.loverPartnerId);
    if (partner) loverPartnerName = partner.name;
  }

  return {
    phase: ms.phase,
    round: ms.round,
    timer: ms.timer,
    players: playersView,
    myId: playerId,
    myRole: myRole,
    myOriginalRole: me.role,
    myTeam: myTeam,
    isAlive: isAlive,
    announcements: ms.announcements || [],
    personalEvents,
    nightAction,
    nightActionDone,
    canChat,
    chatMessages: chatView,
    spyDeadRoles,
    votes: ms.votes,
    mySnipesLeft,
    loverPartnerName,
    sixPlayerFirstNight: ms.sixPlayerFirstNight && ms.round === 1,
  };
}

// ========================= HOST: PROCESS ACTIONS ==============

function mfProcessAction(senderId, data) {
  if (!state.isHost || !mfState) return;
  const ms = mfState;

  if (data.action === 'night-action') {
    if (ms.phase !== 'night') return;
    const player = ms.players.find(p => p.id === senderId && p.alive);
    if (!player) return;

    ms.nightActions[senderId] = {
      action: data.nightAction,   // 'kill', 'snipe', 'heal', 'investigate', etc.
      targetId: data.targetId,
    };

    // Check if all required night actions are submitted
    if (mfAllNightActionsDone()) {
      clearInterval(mfTimer);
      // Small delay to let last player see confirmation
      setTimeout(() => mfAdvancePhase(), 500);
    } else {
      // Send updated state to show action was received
      mfBroadcastState();
    }
  }
  else if (data.action === 'vote') {
    if (ms.phase !== 'day-vote') return;
    const player = ms.players.find(p => p.id === senderId && p.alive);
    if (!player) return;

    ms.votes[senderId] = data.targetId; // targetId or 'skip'

    // Check if all alive players voted
    const aliveCount = ms.players.filter(p => p.alive).length;
    if (Object.keys(ms.votes).length >= aliveCount) {
      clearInterval(mfTimer);
      setTimeout(() => mfAdvancePhase(), 500);
    } else {
      mfBroadcastState();
    }
  }
  else if (data.action === 'chat') {
    // Mafia team chat
    const player = ms.players.find(p => p.id === senderId);
    if (!player) return;
    const role = player.activeRole;
    const canChat = (role === 'mafia') || (role === 'spy' && player.spyFoundMafia);
    if (!canChat) return;

    ms.chatMessages.push({
      sender: senderId,
      senderName: player.name,
      text: data.text,
      round: ms.round,
    });

    mfBroadcastState();
  }
  else if (data.action === 'extend') {
    if (ms.phase !== 'day-discuss') return;
    if (ms.extensionUsed[senderId]) return;
    if (ms.extensionAdded) return; // only one extension per day phase

    ms.extensionUsed[senderId] = true;
    ms.extensionAdded = true;
    ms.timer += 60; // +1 minute
    mfBroadcastState();
    // Notify
    const player = ms.players.find(p => p.id === senderId);
    // Broadcast will update timer display
  }
}

function mfAllNightActionsDone() {
  const ms = mfState;
  const isFirstNight = ms.round === 1;
  const sixRestrict = ms.sixPlayerFirstNight && isFirstNight;

  let needed = 0;
  ms.players.forEach(p => {
    if (!p.alive) return;
    const role = p.activeRole;
    if (role === 'mafia' && !sixRestrict) needed++;
    else if (role === 'spy') needed++;
    else if (role === 'police' && !sixRestrict) needed++;
    else if (role === 'doctor') needed++;
    else if (role === 'reporter' && !sixRestrict) needed++;
    else if (role === 'undertaker') needed++;
    else if (role === 'detective' && !sixRestrict) needed++;
  });

  // Only count unique players who have acted
  let acted = 0;
  ms.players.forEach(p => {
    if (!p.alive) return;
    if (ms.nightActions[p.id]) {
      const role = p.activeRole;
      const hasAction = (role === 'mafia' && !sixRestrict) ||
                        role === 'spy' ||
                        (role === 'police' && !sixRestrict) ||
                        role === 'doctor' ||
                        (role === 'reporter' && !sixRestrict) ||
                        role === 'undertaker' ||
                        (role === 'detective' && !sixRestrict);
      if (hasAction) acted++;
    }
  });

  // For mafia: only 1 mafia needs to act (they coordinate)
  const mafiaAlive = ms.players.filter(p => p.alive && p.activeRole === 'mafia');
  const mafiaActed = mafiaAlive.filter(p => ms.nightActions[p.id]).length;
  // At least 1 mafia must act if not restricted
  const mafiaOk = sixRestrict ? true : (mafiaAlive.length === 0 || mafiaActed >= 1);

  // Other roles
  const otherRoles = ['spy', 'police', 'doctor', 'reporter', 'undertaker', 'detective'];
  let othersOk = true;
  for (const role of otherRoles) {
    if (sixRestrict && role !== 'doctor' && role !== 'spy') continue;
    const p = ms.players.find(pp => pp.alive && pp.activeRole === role);
    if (p && !ms.nightActions[p.id]) {
      othersOk = false;
      break;
    }
  }

  return mafiaOk && othersOk;
}

// ========================= CLIENT: HANDLE MESSAGES ============

function mfHandleState(msg) {
  mfView = msg;
  showScreen('mafiaGame');
  mfRenderView();
}

function mfHandleResult(msg) {
  clearInterval(mfTimer);
  const myRole = mfView?.myRole;
  const myTeam = mfView?.myTeam;
  const won = (msg.winner === myTeam);
  recordGame(won);

  // Show result overlay
  const overlay = document.getElementById('mfResultOverlay');
  const title = document.getElementById('mfResultTitle');
  const subtitle = document.getElementById('mfResultSubtitle');
  const rolesDiv = document.getElementById('mfResultRoles');

  title.textContent = won ? '승리!' : '패배...';
  title.className = 'mf-result-title ' + (won ? 'win' : 'lose');
  subtitle.textContent = msg.message;

  // Show all player roles
  if (mfView && mfView.players) {
    rolesDiv.innerHTML = mfView.players.map((p, i) => {
      const roleInfo = MF_ROLES[p.role] || MF_ROLES.citizen;
      const teamCls = (roleInfo.team === 'mafia') ? 'mafia-text' : 'citizen-text';
      const deadCls = !p.alive ? 'dead-result' : '';
      return `
        <div class="mf-result-player ${deadCls}">
          <div class="mf-result-player-avatar" style="background:${PLAYER_COLORS[i % PLAYER_COLORS.length]};">${p.avatar}</div>
          <div class="mf-result-player-name">${p.name}</div>
          <div class="mf-result-player-role ${teamCls}">${roleInfo.emoji} ${roleInfo.name}</div>
        </div>
      `;
    }).join('');
  }

  overlay.style.display = 'flex';
}

function mfCloseResult() {
  document.getElementById('mfResultOverlay').style.display = 'none';
  mfState = null;
  mfView = null;
  clearInterval(mfTimer);
  showScreen('lobby');
}

function mfLeaveGame() {
  clearInterval(mfTimer);
  mfState = null;
  mfView = null;
  leaveGame();
}

// ========================= RENDER =============================

function mfRenderView() {
  const v = mfView;
  if (!v) return;

  // --- Phase Badge ---
  const phaseInfo = MF_PHASE_LABELS[v.phase] || { icon: '❓', text: '알 수 없음', cls: 'day' };
  const phaseBadge = document.getElementById('mfPhaseBadge');
  document.getElementById('mfPhaseIcon').textContent = phaseInfo.icon;
  document.getElementById('mfPhaseText').textContent = phaseInfo.text;
  phaseBadge.className = 'mf-phase-badge ' + phaseInfo.cls;

  // Night mode on game screen
  const gameScreen = document.getElementById('mafiaGame');
  if (v.phase === 'night' || v.phase === 'role-reveal') {
    gameScreen.classList.add('night-mode');
  } else {
    gameScreen.classList.remove('night-mode');
  }

  // --- Day Counter ---
  document.getElementById('mfDayCounter').textContent = `${v.round}일차`;

  // --- Timer ---
  const timerEl = document.getElementById('mfTimer');
  timerEl.textContent = v.timer;
  const timerBox = document.getElementById('mfTimerBox');
  timerBox.classList.toggle('urgent', v.timer <= 10);

  // --- Role Banner ---
  const roleInfo = MF_ROLES[v.myRole] || MF_ROLES.citizen;
  const banner = document.getElementById('mfRoleBanner');
  banner.className = 'mf-role-banner ' + (roleInfo.team === 'mafia' ? 'team-mafia' : 'team-citizen');
  document.getElementById('mfRoleEmoji').textContent = roleInfo.emoji;
  document.getElementById('mfRoleName').textContent = roleInfo.name;
  document.getElementById('mfRoleName').className = 'mf-role-name ' + (roleInfo.team === 'mafia' ? 'mafia-color' : 'citizen-color');
  document.getElementById('mfRoleDesc').textContent = roleInfo.desc;

  // If baeksu inherited, show both
  if (v.myOriginalRole === 'baeksu' && v.myRole !== 'baeksu') {
    document.getElementById('mfRoleDesc').textContent = `백수에서 ${roleInfo.name}(으)로 전직! ${roleInfo.desc}`;
  }

  // --- Main Content ---
  const content = document.getElementById('mfContent');
  let html = '';

  // ============ ROLE REVEAL PHASE ============
  if (v.phase === 'role-reveal') {
    html += `
      <div style="text-align:center; padding:20px 0;">
        <div style="font-size:64px; margin-bottom:12px;">${roleInfo.emoji}</div>
        <div style="font-family:'Black Han Sans',sans-serif; font-size:28px; color:${roleInfo.team === 'mafia' ? '#ff4444' : '#4fc3f7'}; margin-bottom:8px;">${roleInfo.name}</div>
        <div style="font-size:14px; color:var(--text-dim); line-height:1.6;">${roleInfo.desc}</div>
      </div>
    `;

    // Mafia: show team members
    if (v.myRole === 'mafia') {
      const teammates = v.players.filter(p => p.role === 'mafia' && !p.isMe);
      if (teammates.length > 0) {
        html += `<div class="mf-section-label">동료 마피아</div>`;
        html += `<div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap;">`;
        teammates.forEach(t => {
          html += `
            <div style="display:flex; flex-direction:column; align-items:center; gap:4px;">
              <div class="mf-player-avatar" style="background:${PLAYER_COLORS[v.players.indexOf(t) % PLAYER_COLORS.length]};">${t.avatar}</div>
              <div style="font-size:12px; font-weight:700; color:#ff6b6b;">${t.name}</div>
            </div>
          `;
        });
        html += `</div>`;
      }
    }

    // Lover: show partner
    if (v.myRole === 'lover' && v.loverPartnerName) {
      html += `
        <div class="mf-lover-reveal">
          <div class="mf-lover-reveal-title">💕 당신의 연인</div>
          <div class="mf-lover-reveal-text">${v.loverPartnerName}님이 당신의 연인입니다!</div>
        </div>
      `;
    }
  }

  // ============ NIGHT PHASE ============
  else if (v.phase === 'night') {
    if (!v.isAlive) {
      html += `<div class="mf-spectator-bar">👻 당신은 사망했습니다. 관전 중...</div>`;
      html += mfRenderPlayerGrid(v, false);
    } else if (v.nightAction) {
      // Player has an action to take
      html += `
        <div class="mf-night-panel">
          <div class="mf-night-title">${roleInfo.emoji} ${roleInfo.name} 행동</div>
          <div class="mf-night-desc">${v.nightAction.label}</div>
        </div>
      `;

      // Undertaker: show dead players only
      if (v.nightAction.type === 'undertaker') {
        html += mfRenderPlayerGrid(v, true, 'dead-only');
      } else {
        html += mfRenderPlayerGrid(v, true);
      }
    } else {
      // Citizen / no action - waiting screen
      html += `
        <div class="mf-night-waiting">
          <div class="mf-night-waiting-icon">🌙</div>
          <div class="mf-night-waiting-text">밤이 깊었습니다...</div>
          <div style="font-size:12px; color:var(--text-dim); margin-top:4px;">다른 플레이어들이 행동 중입니다</div>
        </div>
      `;
      html += mfRenderPlayerGrid(v, false);
    }

    // Mafia/Spy Chat
    if (v.canChat) {
      html += mfRenderChat(v);
    }

    // Spy: dead player roles
    if (v.myRole === 'spy' && Object.keys(v.spyDeadRoles).length > 0) {
      html += `
        <div class="mf-spy-info">
          <div class="mf-spy-info-title">🕵️ 사망자 직업 정보</div>
          <div class="mf-spy-dead-roles">
      `;
      Object.entries(v.spyDeadRoles).forEach(([pid, roleName]) => {
        const p = v.players.find(pp => pp.id === pid);
        if (p) {
          html += `<div class="mf-spy-dead-tag">${p.name}: ${roleName}</div>`;
        }
      });
      html += `</div></div>`;
    }
  }

  // ============ DAY ANNOUNCE PHASE ============
  else if (v.phase === 'day-announce') {
    html += `<div class="mf-events-list">`;

    // Public announcements
    v.announcements.forEach(a => {
      html += `
        <div class="mf-event-item ${a.type}">
          <span class="mf-event-icon">${a.icon}</span>
          <span>${a.text}</span>
        </div>
      `;
    });

    // Personal events
    v.personalEvents.forEach(e => {
      html += `
        <div class="mf-event-item ${e.type}">
          <span class="mf-event-icon">${e.icon}</span>
          <span>${e.text}</span>
        </div>
      `;
    });

    html += `</div>`;
    html += mfRenderPlayerGrid(v, false);
  }

  // ============ DAY DISCUSS PHASE ============
  else if (v.phase === 'day-discuss') {
    if (!v.isAlive) {
      html += `<div class="mf-spectator-bar">👻 당신은 사망했습니다. 관전 중...</div>`;
    }
    html += mfRenderPlayerGrid(v, false);

    // Mafia/Spy Chat (even during day for coordination)
    if (v.canChat) {
      html += mfRenderChat(v);
    }

    // Spy: dead player roles
    if (v.myRole === 'spy' && Object.keys(v.spyDeadRoles).length > 0) {
      html += `
        <div class="mf-spy-info">
          <div class="mf-spy-info-title">🕵️ 사망자 직업 정보</div>
          <div class="mf-spy-dead-roles">
      `;
      Object.entries(v.spyDeadRoles).forEach(([pid, roleName]) => {
        const p = v.players.find(pp => pp.id === pid);
        if (p) {
          html += `<div class="mf-spy-dead-tag">${p.name}: ${roleName}</div>`;
        }
      });
      html += `</div></div>`;
    }
  }

  // ============ DAY VOTE PHASE ============
  else if (v.phase === 'day-vote') {
    if (!v.isAlive) {
      html += `<div class="mf-spectator-bar">👻 사망한 플레이어는 투표할 수 없습니다.</div>`;
    }
    html += mfRenderPlayerGrid(v, v.isAlive && !v.votes[v.myId]);

    // Vote status panel
    html += mfRenderVotePanel(v);
  }

  // ============ VOTE RESULT PHASE ============
  else if (v.phase === 'vote-result') {
    html += `<div class="mf-events-list">`;
    v.announcements.forEach(a => {
      html += `
        <div class="mf-event-item ${a.type}">
          <span class="mf-event-icon">${a.icon}</span>
          <span>${a.text}</span>
        </div>
      `;
    });
    html += `</div>`;
    html += mfRenderPlayerGrid(v, false);
  }

  // ============ RESULT PHASE ============
  else if (v.phase === 'result') {
    html += mfRenderPlayerGrid(v, false);
  }

  content.innerHTML = html;

  // --- Bottom Action Area ---
  mfRenderActionArea(v);

  // Attach event listeners for player cards
  mfAttachCardListeners(v);

  // Scroll chat to bottom
  const chatMsgs = document.querySelector('.mf-chat-messages');
  if (chatMsgs) chatMsgs.scrollTop = chatMsgs.scrollHeight;
}

// ========================= RENDER HELPERS =====================

function mfRenderPlayerGrid(v, selectable, mode) {
  const gridCls = v.players.length > 8 ? 'mf-player-grid three-col' : 'mf-player-grid';
  let html = `<div class="${gridCls}">`;

  v.players.forEach((p, i) => {
    // mode === 'dead-only': only show dead players as selectable
    const isSelectable = selectable && (mode === 'dead-only' ? !p.alive : (p.alive && !p.isMe));
    const isDeadCard = !p.alive;
    const classes = [
      'mf-player-card',
      isSelectable ? 'selectable' : '',
      isDeadCard ? 'dead' : '',
      p.isMe ? 'is-me' : '',
      p.voteCount > 0 ? 'voted-on' : '',
    ].filter(Boolean).join(' ');

    html += `<div class="${classes}" data-pid="${p.id}">`;

    // Host crown
    if (p.isHost) {
      html += `<span class="mf-host-crown">👑</span>`;
    }

    // Lover heart
    if (p.showLoverHeart) {
      html += `<span class="mf-lover-heart">💕</span>`;
    }

    // Vote count badge
    if (p.voteCount > 0) {
      html += `<span class="mf-vote-count-badge">${p.voteCount}</span>`;
    }

    // Dead overlay
    html += `<div class="mf-dead-overlay">💀</div>`;

    // Avatar
    html += `<div class="mf-player-avatar" style="background:${PLAYER_COLORS[i % PLAYER_COLORS.length]};">${p.avatar}</div>`;

    // Name
    html += `<div class="mf-player-name">${p.name}</div>`;

    // Role tag (if visible)
    if (p.role && (isDeadCard || p.isMe || v.phase === 'result' || p.role === 'mafia')) {
      const rInfo = MF_ROLES[p.role] || MF_ROLES.citizen;
      const tagCls = rInfo.team === 'mafia' ? 'mafia-tag' : 'citizen-tag';
      html += `<div class="mf-player-role-tag ${tagCls}">${rInfo.emoji} ${rInfo.name}</div>`;
    }

    // Soldier shield
    if (p.showSoldierShield) {
      html += `<span class="mf-soldier-shield">🛡️</span>`;
    }

    html += `</div>`;
  });

  html += `</div>`;
  return html;
}

function mfRenderChat(v) {
  let html = `
    <div class="mf-chat-panel">
      <div class="mf-chat-header">
        <span>🔪</span>
        <span>마피아 팀 채팅</span>
      </div>
      <div class="mf-chat-messages" id="mfChatMessages">
  `;

  v.chatMessages.forEach(m => {
    html += `
      <div class="mf-chat-msg">
        <span class="sender">${m.senderName}:</span>
        <span class="text"> ${m.text}</span>
      </div>
    `;
  });

  html += `
      </div>
      <div class="mf-chat-input-row">
        <input type="text" class="mf-chat-input" id="mfChatInput" placeholder="메시지 입력..." maxlength="100"
               onkeydown="if(event.key==='Enter')mfSendChat()">
        <button class="mf-chat-send-btn" onclick="mfSendChat()">전송</button>
      </div>
    </div>
  `;
  return html;
}

function mfRenderVotePanel(v) {
  // Count votes per target
  const counts = {};
  let skipCount = 0;
  Object.values(v.votes).forEach(t => {
    if (t === 'skip') { skipCount++; return; }
    counts[t] = (counts[t] || 0) + 1;
  });

  const alivePlayers = v.players.filter(p => p.alive);
  const totalVoters = alivePlayers.length;
  const votedCount = Object.keys(v.votes).length;

  let html = `
    <div class="mf-vote-panel">
      <div class="mf-vote-title">투표 현황 (${votedCount}/${totalVoters})</div>
      <div class="mf-vote-bars">
  `;

  // Sort by vote count
  const entries = Object.entries(counts).sort((a, b) => b[1] - a[1]);
  entries.forEach(([pid, count]) => {
    const p = v.players.find(pp => pp.id === pid);
    if (!p) return;
    const pct = totalVoters > 0 ? Math.round((count / totalVoters) * 100) : 0;
    html += `
      <div class="mf-vote-bar">
        <div class="mf-vote-bar-name">${p.name}</div>
        <div class="mf-vote-bar-track">
          <div class="mf-vote-bar-fill" style="width:${pct}%;">${count}</div>
        </div>
      </div>
    `;
  });

  html += `</div>`;

  if (skipCount > 0) {
    html += `<div class="mf-skip-count">건너뛰기: ${skipCount}표</div>`;
  }

  html += `</div>`;
  return html;
}

// ========================= ACTION AREA ========================

function mfRenderActionArea(v) {
  const msgBox = document.getElementById('mfMessageBox');
  const btnRow = document.getElementById('mfBtnRow');
  let msg = '';
  let btns = '';

  if (v.phase === 'role-reveal') {
    msg = '🎭 역할을 확인하세요! 잠시 후 밤이 시작됩니다.';
  }
  else if (v.phase === 'night') {
    if (!v.isAlive) {
      msg = '👻 관전 모드';
    } else if (v.nightActionDone) {
      msg = '✅ 행동 완료! 다른 플레이어를 기다리는 중...';
    } else if (v.nightAction) {
      msg = v.nightAction.label;

      if (v.nightAction.type === 'mafia') {
        btns += `<button class="mf-action-btn primary" id="mfConfirmBtn" onclick="mfConfirmNightAction()" disabled>🔪 제거</button>`;
        if (v.nightAction.canSnipe) {
          btns += `<button class="mf-action-btn snipe" id="mfSnipeBtn" onclick="mfToggleSnipe()">🎯 저격 (${v.mySnipesLeft}회)</button>`;
        }
      } else {
        const actionLabel = {
          spy: '🕵️ 조사',
          police: '🔍 조사',
          doctor: '💊 치료',
          reporter: '📰 조사',
          undertaker: '⚰️ 확인',
          detective: '🔎 추적',
        };
        btns += `<button class="mf-action-btn primary" id="mfConfirmBtn" onclick="mfConfirmNightAction()" disabled>${actionLabel[v.nightAction.type] || '확인'}</button>`;
      }
    } else {
      msg = '🌙 밤입니다... 기다리세요.';
    }
  }
  else if (v.phase === 'day-announce') {
    msg = '☀️ 밤이 지나고 아침이 밝았습니다...';
  }
  else if (v.phase === 'day-discuss') {
    if (!v.isAlive) {
      msg = '👻 관전 모드';
    } else {
      msg = '☀️ 의심되는 사람에 대해 토론하세요!';
      btns += `<button class="mf-action-btn extend" onclick="mfRequestExtend()">⏰ 연장 (+1분)</button>`;
    }
  }
  else if (v.phase === 'day-vote') {
    if (!v.isAlive) {
      msg = '👻 사망한 플레이어는 투표할 수 없습니다.';
    } else if (v.votes[v.myId]) {
      msg = '✅ 투표 완료! 결과를 기다리는 중...';
    } else {
      msg = '🗳️ 처형할 사람을 선택하고 투표하세요!';
      btns += `<button class="mf-action-btn primary" id="mfVoteBtn" onclick="mfConfirmVote()" disabled>🗳️ 투표</button>`;
      btns += `<button class="mf-action-btn secondary" onclick="mfSkipVote()">건너뛰기</button>`;
    }
  }
  else if (v.phase === 'vote-result') {
    msg = '⚖️ 투표 결과를 확인하세요.';
  }
  else if (v.phase === 'result') {
    msg = '';
  }

  msgBox.innerHTML = msg;
  btnRow.innerHTML = btns;
}

// ========================= UI INTERACTIONS ====================

function mfAttachCardListeners(v) {
  document.querySelectorAll('.mf-player-card.selectable').forEach(card => {
    card.addEventListener('click', () => {
      const pid = card.dataset.pid;
      if (!pid) return;

      // Deselect all
      document.querySelectorAll('.mf-player-card').forEach(c => {
        c.classList.remove('selected', 'selected-snipe');
      });

      mfSelectedTarget = pid;
      card.classList.add(mfUseSnipe ? 'selected-snipe' : 'selected');

      // Enable confirm button
      const confirmBtn = document.getElementById('mfConfirmBtn');
      const voteBtn = document.getElementById('mfVoteBtn');
      if (confirmBtn) confirmBtn.disabled = false;
      if (voteBtn) voteBtn.disabled = false;
    });
  });
}

function mfToggleSnipe() {
  mfUseSnipe = !mfUseSnipe;
  const snipeBtn = document.getElementById('mfSnipeBtn');
  if (snipeBtn) {
    if (mfUseSnipe) {
      snipeBtn.style.background = 'linear-gradient(135deg, #b71c1c, #880e0e)';
      snipeBtn.textContent = '🎯 저격 모드 ON';
    } else {
      snipeBtn.style.background = '';
      snipeBtn.textContent = `🎯 저격 (${mfView?.mySnipesLeft || 0}회)`;
    }
  }

  // Update selection visual if target already selected
  const selectedCard = document.querySelector('.mf-player-card.selected, .mf-player-card.selected-snipe');
  if (selectedCard) {
    selectedCard.classList.remove('selected', 'selected-snipe');
    selectedCard.classList.add(mfUseSnipe ? 'selected-snipe' : 'selected');
  }
}

function mfConfirmNightAction() {
  if (!mfSelectedTarget) { showToast('대상을 선택하세요'); return; }

  const actionType = mfView?.nightAction?.type;
  let nightAction = 'investigate';

  if (actionType === 'mafia') {
    nightAction = mfUseSnipe ? 'snipe' : 'kill';
  } else if (actionType === 'doctor') {
    nightAction = 'heal';
  } else if (actionType === 'detective') {
    nightAction = 'track';
  }

  const data = {
    type: 'mf-action',
    action: 'night-action',
    nightAction,
    targetId: mfSelectedTarget,
  };

  if (state.isHost) {
    mfProcessAction(state.myId, data);
  } else {
    const host = Object.values(state.connections)[0];
    if (host?.open) host.send(JSON.stringify(data));
  }

  showToast('행동 완료!');
  mfSelectedTarget = null;
  mfUseSnipe = false;

  // Disable buttons
  const confirmBtn = document.getElementById('mfConfirmBtn');
  if (confirmBtn) confirmBtn.disabled = true;
  const snipeBtn = document.getElementById('mfSnipeBtn');
  if (snipeBtn) snipeBtn.disabled = true;
}

function mfConfirmVote() {
  if (!mfSelectedTarget) { showToast('투표 대상을 선택하세요'); return; }

  const data = {
    type: 'mf-action',
    action: 'vote',
    targetId: mfSelectedTarget,
  };

  if (state.isHost) {
    mfProcessAction(state.myId, data);
  } else {
    const host = Object.values(state.connections)[0];
    if (host?.open) host.send(JSON.stringify(data));
  }

  showToast('투표 완료!');
  mfSelectedTarget = null;
}

function mfSkipVote() {
  const data = {
    type: 'mf-action',
    action: 'vote',
    targetId: 'skip',
  };

  if (state.isHost) {
    mfProcessAction(state.myId, data);
  } else {
    const host = Object.values(state.connections)[0];
    if (host?.open) host.send(JSON.stringify(data));
  }

  showToast('건너뛰기 투표 완료');
}

function mfSendChat() {
  const input = document.getElementById('mfChatInput');
  if (!input) return;
  const text = input.value.trim();
  if (!text) return;

  const data = {
    type: 'mf-action',
    action: 'chat',
    text,
  };

  if (state.isHost) {
    mfProcessAction(state.myId, data);
  } else {
    const host = Object.values(state.connections)[0];
    if (host?.open) host.send(JSON.stringify(data));
  }

  input.value = '';
}

function mfRequestExtend() {
  const data = {
    type: 'mf-action',
    action: 'extend',
  };

  if (state.isHost) {
    mfProcessAction(state.myId, data);
  } else {
    const host = Object.values(state.connections)[0];
    if (host?.open) host.send(JSON.stringify(data));
  }

  showToast('연장 요청!');
}

// ===== GAME STUBS =====
// startSutda, startRacing - 아래 엔진 코드에서 정의됨
// startECard, startYahtzee, startUpDown - 아래 엔진 코드에서 정의됨

// ===== TRUTH GAME ENGINE =====

// --- 호스트 상태 ---
let truthState = null;

function startTruthGame() {
  if (!state.isHost) return;
  if (state.players.length < 3) {
    showToast('진실게임은 3명 이상 필요합니다');
    return;
  }

  truthState = {
    round: 1,
    questionerIdx: 0,
    question: '',
    votes: {},
    votedSet: new Set(),
    phase: 'question',
    playerOrder: state.players.map(p => p.id),
    playerMap: {},
  };

  state.players.forEach((p, i) => {
    truthState.playerMap[p.id] = {
      id: p.id,
      name: p.name,
      avatar: p.avatar,
      colorIdx: i,
    };
  });

  const initView = buildTruthView(state.myId);
  showScreen('truthGame');
  renderTruthView(initView);

  state.players.forEach(p => {
    if (p.id !== state.myId) {
      const view = buildTruthView(p.id);
      sendTo(p.id, {
        type: 'game-start',
        game: 'truth',
        state: view,
      });
    }
  });
}

function buildTruthView(forPlayerId) {
  const ts = truthState;
  const questionerId = ts.playerOrder[ts.questionerIdx];
  const isQuestioner = (forPlayerId === questionerId);
  const totalPlayers = ts.playerOrder.length;

  const votedList = Array.from(ts.votedSet || []);
  const voteCount = votedList.length;

  let oCount = 0;
  let xCount = 0;
  if (ts.phase === 'result') {
    Object.values(ts.votes).forEach(v => {
      if (v === 'O') oCount++;
      else if (v === 'X') xCount++;
    });
  }

  const myVoted = ts.votedSet ? ts.votedSet.has(forPlayerId) : false;

  return {
    type: 'truth-state',
    round: ts.round,
    phase: ts.phase,
    questionerId: questionerId,
    questionerName: ts.playerMap[questionerId]?.name || '???',
    isQuestioner: isQuestioner,
    question: ts.phase !== 'question' ? ts.question : (isQuestioner ? '' : ''),
    totalPlayers: totalPlayers,
    voteCount: voteCount,
    votedList: votedList,
    myVoted: myVoted,
    oCount: oCount,
    xCount: xCount,
    players: ts.playerOrder.map(pid => ({
      id: pid,
      name: ts.playerMap[pid]?.name || '???',
      avatar: ts.playerMap[pid]?.avatar || '😎',
      colorIdx: ts.playerMap[pid]?.colorIdx || 0,
      isQuestioner: pid === questionerId,
      hasVoted: ts.votedSet ? ts.votedSet.has(pid) : false,
    })),
    isHost: forPlayerId === state.myId && state.isHost,
  };
}

function broadcastTruthState() {
  if (!truthState) return;
  const ts = truthState;

  ts.playerOrder.forEach(pid => {
    const view = buildTruthView(pid);
    if (pid === state.myId) {
      renderTruthView(view);
    } else {
      sendTo(pid, view);
    }
  });
}

function processTruthQuestion(peerId, question) {
  if (!truthState || truthState.phase !== 'question') return;
  const questionerId = truthState.playerOrder[truthState.questionerIdx];
  if (peerId !== questionerId) return;

  truthState.question = question;
  truthState.phase = 'voting';
  truthState.votes = {};
  truthState.votedSet = new Set();

  broadcastTruthState();
}

function processTruthVote(peerId, vote) {
  if (!truthState || truthState.phase !== 'voting') return;
  if (truthState.votedSet.has(peerId)) return;
  if (vote !== 'O' && vote !== 'X') return;

  truthState.votes[peerId] = vote;
  truthState.votedSet.add(peerId);

  if (truthState.votedSet.size >= truthState.playerOrder.length) {
    truthState.phase = 'result';
  }
  broadcastTruthState();
}

function processTruthNext() {
  if (!truthState) return;
  truthState.round++;
  truthState.questionerIdx = (truthState.questionerIdx + 1) % truthState.playerOrder.length;
  truthState.question = '';
  truthState.votes = {};
  truthState.votedSet = new Set();
  truthState.phase = 'question';

  broadcastTruthState();
}

function renderTruthView(view) {
  if (!view) return;

  document.getElementById('truthRoundBadge').textContent = 'ROUND ' + view.round;
  document.getElementById('truthQuestionerDisplay').textContent = '질문자: ' + view.questionerName;

  document.getElementById('truthQuestionInputArea').style.display = 'none';
  document.getElementById('truthWaitQuestionArea').style.display = 'none';
  document.getElementById('truthVotingArea').style.display = 'none';
  document.getElementById('truthResultArea').style.display = 'none';

  if (view.phase === 'question') {
    if (view.isQuestioner) {
      document.getElementById('truthQuestionInputArea').style.display = 'flex';
      document.getElementById('truthQuestionInput').value = '';
      document.getElementById('truthCharCount').textContent = '0';
    } else {
      document.getElementById('truthWaitQuestionArea').style.display = 'flex';
      document.getElementById('truthWaitingText').textContent = '질문을 기다리는 중...';
      document.getElementById('truthWaitingSubText').textContent =
        view.questionerName + '님이 질문을 작성하고 있습니다';
    }
  } else if (view.phase === 'voting') {
    document.getElementById('truthVotingArea').style.display = 'flex';
    document.getElementById('truthQuestionText').textContent = view.question;

    if (view.myVoted) {
      document.getElementById('truthVoteButtons').style.display = 'none';
      document.getElementById('truthVoteWaiting').style.display = 'block';
      const pct = Math.round((view.voteCount / view.totalPlayers) * 100);
      document.getElementById('truthProgressFill').style.width = pct + '%';
      document.getElementById('truthProgressText').textContent =
        '투표 중... (' + view.voteCount + '/' + view.totalPlayers + '명 완료)';
    } else {
      document.getElementById('truthVoteButtons').style.display = 'flex';
      document.getElementById('truthVoteWaiting').style.display = 'none';
      document.getElementById('truthBtnO').classList.remove('selected', 'disabled');
      document.getElementById('truthBtnX').classList.remove('selected', 'disabled');
    }
  } else if (view.phase === 'result') {
    document.getElementById('truthResultArea').style.display = 'flex';
    document.getElementById('truthResultQuestionText').textContent = view.question;
    document.getElementById('truthResultOCount').textContent = view.oCount + '명';
    document.getElementById('truthResultXCount').textContent = view.xCount + '명';
    document.getElementById('truthResultTotal').textContent =
      '총 ' + view.totalPlayers + '명 참여';

    const oDots = document.getElementById('truthResultODots');
    let oHTML = '';
    for (let i = 0; i < view.totalPlayers; i++) {
      const delay = (i * 0.08).toFixed(2);
      if (i < view.oCount) {
        oHTML += '<div class="truth-dot filled-o" style="animation-delay:' + delay + 's"></div>';
      } else {
        oHTML += '<div class="truth-dot empty"></div>';
      }
    }
    oDots.innerHTML = oHTML;

    const xDots = document.getElementById('truthResultXDots');
    let xHTML = '';
    for (let i = 0; i < view.totalPlayers; i++) {
      const delay = (i * 0.08).toFixed(2);
      if (i < view.xCount) {
        xHTML += '<div class="truth-dot filled-x" style="animation-delay:' + delay + 's"></div>';
      } else {
        xHTML += '<div class="truth-dot empty"></div>';
      }
    }
    xDots.innerHTML = xHTML;

    if (view.isHost) {
      document.getElementById('truthNextBtn').style.display = 'block';
      document.getElementById('truthNextWaiting').style.display = 'none';
    } else {
      document.getElementById('truthNextBtn').style.display = 'none';
      document.getElementById('truthNextWaiting').style.display = 'block';
    }
  }

  renderTruthPlayersBar(view.players);
}

function renderTruthPlayersBar(players) {
  const bar = document.getElementById('truthPlayersBar');
  bar.innerHTML = players.map(p => {
    const isMe = p.id === state.myId;
    const avatarClasses = [
      'truth-player-avatar',
      p.isQuestioner ? 'is-questioner' : '',
      p.hasVoted ? 'has-voted' : '',
    ].filter(Boolean).join(' ');

    const nameClass = p.isQuestioner ? 'truth-player-name active-name' : 'truth-player-name';

    return '<div class="truth-player-chip">' +
      '<div class="' + avatarClasses + '" style="background:' + PLAYER_COLORS[p.colorIdx % PLAYER_COLORS.length] + ';">' +
        p.avatar +
      '</div>' +
      '<div class="' + nameClass + '">' + (isMe ? '나' : p.name) + '</div>' +
    '</div>';
  }).join('');
}

function submitTruthQuestion() {
  const input = document.getElementById('truthQuestionInput');
  const question = input.value.trim();
  if (!question) {
    showToast('질문을 입력하세요');
    return;
  }
  if (question.length > 200) {
    showToast('질문이 너무 깁니다 (200자 이내)');
    return;
  }

  if (state.isHost) {
    processTruthQuestion(state.myId, question);
  } else {
    const hostConn = Object.values(state.connections)[0];
    if (hostConn?.open) {
      hostConn.send(JSON.stringify({
        type: 'truth-question',
        question: question,
      }));
    }
  }
}

function castTruthVote(vote) {
  const btnO = document.getElementById('truthBtnO');
  const btnX = document.getElementById('truthBtnX');

  if (vote === 'O') {
    btnO.classList.add('selected');
    btnX.classList.add('disabled');
  } else {
    btnX.classList.add('selected');
    btnO.classList.add('disabled');
  }

  setTimeout(() => {
    document.getElementById('truthVoteButtons').style.display = 'none';
    document.getElementById('truthVoteWaiting').style.display = 'block';
    document.getElementById('truthVotedBadge').textContent =
      vote === 'O' ? '⭕ 투표 완료' : '❌ 투표 완료';
  }, 400);

  if (state.isHost) {
    processTruthVote(state.myId, vote);
  } else {
    const hostConn = Object.values(state.connections)[0];
    if (hostConn?.open) {
      hostConn.send(JSON.stringify({
        type: 'truth-vote',
        vote: vote,
      }));
    }
  }
}

function truthNextRound() {
  if (state.isHost) {
    processTruthNext();
  } else {
    const hostConn = Object.values(state.connections)[0];
    if (hostConn?.open) {
      hostConn.send(JSON.stringify({
        type: 'truth-next',
      }));
    }
  }
}

document.addEventListener('input', function(e) {
  if (e.target && e.target.id === 'truthQuestionInput') {
    const cnt = document.getElementById('truthCharCount');
    if (cnt) cnt.textContent = e.target.value.length;
  }
});

// ===== QUICK DRAW ENGINE =====

let qdState = {
  phase: 'waiting',
  startTime: 0,
  results: {},
  roundNum: 1,
  countdownTimeout: null,
  fireTimeout: null,
};

function startQuickDraw() {
  if(!state.isHost) return;

  qdState = {
    phase: 'waiting',
    startTime: 0,
    results: {},
    roundNum: state.quickdraw?.roundNum || 1,
    countdownTimeout: null,
    fireTimeout: null,
  };

  state.quickdraw = qdState;

  broadcast({ type: 'game-start', game: 'quickdraw', state: qdState });
  showScreen('quickDrawGame');
  renderQuickDrawView(qdState);

  setTimeout(() => {
    qdState.phase = 'countdown';
    broadcastQDState();

    const delay = 2000 + Math.random() * 4000;
    qdState.countdownTimeout = setTimeout(() => {
      qdState.phase = 'fire';
      qdState.startTime = Date.now();
      broadcastQDState();

      if(navigator.vibrate) navigator.vibrate(200);

      qdState.fireTimeout = setTimeout(() => {
        resolveQD();
      }, 5000);
    }, delay);
  }, 3000);
}

function broadcastQDState() {
  const msg = {
    type: 'qd-state',
    phase: qdState.phase,
    startTime: qdState.startTime,
    results: qdState.results,
    roundNum: qdState.roundNum,
  };

  broadcast(msg);
  renderQuickDrawView(msg);
}

function renderQuickDrawView(qd) {
  if(!qd) return;

  const zone = document.getElementById('qdTapZone');
  const statusText = document.getElementById('qdStatusText');
  const reactionTime = document.getElementById('qdReactionTime');
  const roundNum = document.getElementById('qdRoundNum');

  roundNum.textContent = qd.roundNum;

  zone.className = 'qd-tap-zone ' + qd.phase;

  switch(qd.phase) {
    case 'waiting':
      statusText.textContent = '준비...';
      reactionTime.textContent = '';
      break;

    case 'countdown':
      statusText.textContent = '⏳';
      reactionTime.textContent = '';
      break;

    case 'fire':
      statusText.textContent = '발사!';
      reactionTime.textContent = '';

      if(navigator.vibrate) navigator.vibrate(200);
      break;

    case 'result':
      statusText.textContent = '결과';

      const myResult = qd.results[state.myId];
      if(myResult) {
        if(myResult.cheated) {
          reactionTime.textContent = '실격!';
          reactionTime.style.color = 'var(--danger)';
        } else {
          reactionTime.textContent = (myResult.time / 1000).toFixed(3) + '초';
          reactionTime.style.color = 'var(--accent2)';
        }
      } else {
        reactionTime.textContent = '미응답';
        reactionTime.style.color = 'var(--text-dim)';
      }

      document.getElementById('qdRestartBtn').style.display = state.isHost ? 'block' : 'none';
      break;
  }

  renderQDRankings(qd);
}

function renderQDRankings(qd) {
  const list = document.getElementById('qdRankingsList');

  if(qd.phase !== 'result' || Object.keys(qd.results).length === 0) {
    list.innerHTML = '<div style="text-align:center;color:var(--text-dim);font-size:13px;padding:20px;">대기 중...</div>';
    return;
  }

  const sorted = Object.entries(qd.results)
    .map(([id, r]) => ({ id, ...r }))
    .sort((a, b) => {
      if(a.cheated && !b.cheated) return 1;
      if(!a.cheated && b.cheated) return -1;
      if(a.cheated && b.cheated) return 0;
      return a.time - b.time;
    });

  list.innerHTML = sorted.map((r, i) => {
    const rank = r.cheated ? '❌' : (i + 1) + '위';
    const timeStr = r.cheated ? '너무 빨라요!' : (r.time / 1000).toFixed(3) + '초';
    const isWinner = !r.cheated && i === 0;
    const playerIdx = state.players.findIndex(p => p.id === r.id);

    return `
      <div class="qd-ranking-item ${isWinner ? 'winner' : ''}">
        <div class="qd-ranking-rank">${rank}</div>
        <div class="qd-ranking-avatar" style="background:${PLAYER_COLORS[playerIdx % PLAYER_COLORS.length]};">${r.avatar}</div>
        <div class="qd-ranking-name">${r.name}</div>
        <div class="qd-ranking-time ${r.cheated ? 'cheated' : ''}">${timeStr}</div>
      </div>
    `;
  }).join('');
}

function qdTap() {
  const qd = qdState;
  const now = Date.now();

  if(qd.results[state.myId]) return;

  if(qd.phase === 'waiting') {
    return;
  } else if(qd.phase === 'countdown') {
    sendQDAction({ cheated: true, time: 0 });

    qdState.results[state.myId] = {
      cheated: true,
      time: 0,
      name: state.myName,
      avatar: state.myAvatar,
    };

    const zone = document.getElementById('qdTapZone');
    const statusText = document.getElementById('qdStatusText');
    zone.className = 'qd-tap-zone cheated';
    statusText.textContent = '너무 빨라요!\n실격!';
    statusText.style.fontSize = '32px';

  } else if(qd.phase === 'fire') {
    const reactionTime = now - qd.startTime;
    sendQDAction({ cheated: false, time: reactionTime });

    qdState.results[state.myId] = {
      cheated: false,
      time: reactionTime,
      name: state.myName,
      avatar: state.myAvatar,
    };

    const zone = document.getElementById('qdTapZone');
    const statusText = document.getElementById('qdStatusText');
    const reactionTimeEl = document.getElementById('qdReactionTime');
    zone.className = 'qd-tap-zone done';
    statusText.textContent = '완료!';
    reactionTimeEl.textContent = (reactionTime / 1000).toFixed(3) + '초';
  }
}

function sendQDAction(action) {
  const msg = {
    type: 'qd-action',
    playerId: state.myId,
    name: state.myName,
    avatar: state.myAvatar,
    cheated: action.cheated,
    time: action.time,
  };

  if(state.isHost) {
    processQDAction(msg);
  } else {
    const host = Object.values(state.connections)[0];
    if(host?.open) host.send(JSON.stringify(msg));
  }
}

function processQDAction(msg) {
  if(!state.isHost) return;

  qdState.results[msg.playerId] = {
    cheated: msg.cheated,
    time: msg.time,
    name: msg.name,
    avatar: msg.avatar,
  };

  if(Object.keys(qdState.results).length >= state.players.length) {
    clearTimeout(qdState.fireTimeout);
    resolveQD();
  }
}

function resolveQD() {
  if(!state.isHost) return;

  qdState.phase = 'result';

  const valid = Object.entries(qdState.results)
    .filter(([id, r]) => !r.cheated)
    .sort((a, b) => a[1].time - b[1].time);

  let winnerId = null;
  let winnerName = '';
  if(valid.length > 0) {
    winnerId = valid[0][0];
    winnerName = valid[0][1].name;
  }

  const result = {
    type: 'qd-result',
    winnerId,
    winnerName,
    results: qdState.results,
    roundNum: qdState.roundNum,
  };

  broadcast(result);
  handleQDResult(result);
}

function handleQDResult(msg) {
  qdState.phase = 'result';
  qdState.results = msg.results;
  qdState.roundNum = msg.roundNum;

  renderQuickDrawView(qdState);

  const won = msg.winnerId === state.myId;
  if(msg.winnerId) {
    recordGame(won);
  }

  if(msg.winnerId === state.myId) {
    showToast('🏆 승리!');
  } else if(msg.winnerId) {
    showToast(`${msg.winnerName} 승리!`);
  }
}

function restartQuickDraw() {
  if(!state.isHost) return;
  qdState.roundNum++;
  startQuickDraw();
}

// ===== RUSSIAN ROULETTE ENGINE =====
let rrState = {
  bullets: 1,
  chambers: 6,
  cylinder: [],
  currentChamber: 0,
  turnIdx: 0,
  players: [],
  phase: 'setup',
  setupDone: false,
  lastResult: null,
};

function startRussianRoulette() {
  if(!state.isHost) return;

  rrState = {
    bullets: 1,
    chambers: 6,
    cylinder: [],
    currentChamber: 0,
    turnIdx: 0,
    players: state.players.map(p => ({
      id: p.id, name: p.name, avatar: p.avatar, alive: true
    })),
    phase: 'setup',
    setupDone: false,
    lastResult: null,
  };

  showScreen('rouletteGame');
  document.getElementById('rouletteSetup').style.display = 'block';

  document.getElementById('bulletsSlider').oninput = (e) => {
    document.getElementById('bulletsValue').textContent = e.target.value;
  };
  document.getElementById('chambersSlider').oninput = (e) => {
    document.getElementById('chambersValue').textContent = e.target.value;
  };
}

function confirmRouletteSetup() {
  const bullets = parseInt(document.getElementById('bulletsSlider').value);
  const chambers = parseInt(document.getElementById('chambersSlider').value);

  rrState.bullets = bullets;
  rrState.chambers = chambers;
  rrState.cylinder = new Array(chambers).fill(false);

  const positions = [];
  while(positions.length < bullets) {
    const pos = Math.floor(Math.random() * chambers);
    if(!positions.includes(pos)) positions.push(pos);
  }
  positions.forEach(p => rrState.cylinder[p] = true);

  rrState.currentChamber = Math.floor(Math.random() * chambers);
  rrState.phase = 'playing';
  rrState.setupDone = true;
  rrState.turnIdx = 0;

  document.getElementById('rouletteSetup').style.display = 'none';

  broadcastRRState();
  renderRouletteView();
}

function broadcastRRState() {
  const rs = rrState;

  rs.players.forEach(p => {
    const view = {
      type: 'roulette-state',
      players: rs.players.map(pp => ({
        id: pp.id, name: pp.name, avatar: pp.avatar, alive: pp.alive
      })),
      turnIdx: rs.turnIdx,
      phase: rs.phase,
      chambers: rs.chambers,
      bullets: rs.bullets,
      lastResult: rs.lastResult,
      showCylinder: false,
    };

    if(p.id === state.myId) renderRouletteView(view);
    else sendTo(p.id, view);
  });
}

function renderRouletteView(data) {
  const rs = data || {
    players: rrState.players,
    turnIdx: rrState.turnIdx,
    phase: rrState.phase,
    chambers: rrState.chambers,
    bullets: rrState.bullets,
    lastResult: rrState.lastResult,
  };

  const alive = rs.players.filter(p => p.alive).length;
  document.getElementById('rouletteSurvivors').textContent = alive;
  document.getElementById('rouletteTotalPlayers').textContent = rs.players.length;

  const currentPlayer = rs.players[rs.turnIdx];
  if(currentPlayer) {
    document.getElementById('currentTurnName').textContent = currentPlayer.name;
  }

  const cylinder = document.getElementById('cylinder');
  cylinder.innerHTML = '';
  const angleStep = 360 / rs.chambers;

  for(let i = 0; i < rs.chambers; i++) {
    const indicator = document.createElement('div');
    indicator.className = 'chamber-indicator empty';
    const angle = i * angleStep;
    const radius = 80;
    const x = 100 + radius * Math.cos((angle - 90) * Math.PI / 180);
    const y = 100 + radius * Math.sin((angle - 90) * Math.PI / 180);
    indicator.style.left = x + 'px';
    indicator.style.top = y + 'px';
    cylinder.appendChild(indicator);
  }

  const survivorsList = document.getElementById('survivorsList');
  survivorsList.innerHTML = rs.players.map((p, i) => `
    <div class="survivor-item ${!p.alive ? 'dead' : ''}">
      <div class="survivor-avatar-sm" style="background:${PLAYER_COLORS[i % PLAYER_COLORS.length]};">${p.avatar}</div>
      <div class="survivor-name">${p.name}</div>
    </div>
  `).join('');

  const isMyTurn = currentPlayer?.id === state.myId;
  const spinBtn = document.getElementById('spinBtn');
  const triggerBtn = document.getElementById('triggerBtn');
  const restartBtn = document.getElementById('restartBtn');
  const cylinderInfo = document.getElementById('cylinderInfo');

  spinBtn.style.display = 'none';
  triggerBtn.style.display = 'none';
  restartBtn.style.display = 'none';

  if(rs.phase === 'gameover') {
    cylinderInfo.textContent = '게임 종료!';
    if(state.isHost) {
      restartBtn.style.display = 'block';
    }
  } else if(isMyTurn && rs.phase === 'playing') {
    spinBtn.style.display = 'block';
    cylinderInfo.textContent = '실린더를 돌려주세요';
  } else if(isMyTurn && rs.phase === 'spinning') {
    triggerBtn.style.display = 'block';
    cylinderInfo.textContent = '방아쇠를 당기세요...';
  } else {
    cylinderInfo.textContent = currentPlayer ? `${currentPlayer.name}의 차례` : '대기 중...';
  }
}

function spinCylinder() {
  if(!state.isHost) {
    const host = Object.values(state.connections)[0];
    if(host?.open) host.send(JSON.stringify({ type: 'rr-action', action: 'spin' }));
    return;
  }

  rrState.phase = 'spinning';

  const cylinder = document.getElementById('cylinder');
  cylinder.classList.add('spinning');

  setTimeout(() => {
    cylinder.classList.remove('spinning');
    broadcastRRState();
  }, 3000);

  broadcastRRState();
}

function pullTrigger() {
  if(!state.isHost) {
    const host = Object.values(state.connections)[0];
    if(host?.open) host.send(JSON.stringify({ type: 'rr-action', action: 'trigger' }));
    return;
  }

  const currentPlayer = rrState.players[rrState.turnIdx];
  const isBullet = rrState.cylinder[rrState.currentChamber];

  if(isBullet) {
    currentPlayer.alive = false;
    rrState.lastResult = { playerId: currentPlayer.id, result: 'dead' };

    if(navigator.vibrate) navigator.vibrate([200, 100, 200]);

    showRouletteFlash('bang', '💥', '탕!');

    setTimeout(() => {
      rrState.currentChamber = (rrState.currentChamber + 1) % rrState.chambers;
      advanceRouletteTurn();
    }, 2000);

  } else {
    rrState.lastResult = { playerId: currentPlayer.id, result: 'safe' };

    showRouletteFlash('safe', '😮‍💨', '찰칵... 살았다!');

    setTimeout(() => {
      rrState.currentChamber = (rrState.currentChamber + 1) % rrState.chambers;
      advanceRouletteTurn();
    }, 2000);
  }

  broadcastRRState();
}

function showRouletteFlash(type, icon, text) {
  const flash = document.getElementById('rouletteFlash');
  const flashIcon = document.getElementById('flashIcon');
  const flashText = document.getElementById('flashText');

  flash.className = 'roulette-flash active ' + type;
  flashIcon.textContent = icon;
  flashText.textContent = text;

  setTimeout(() => {
    flash.classList.remove('active', type);
  }, 800);
}

function advanceRouletteTurn() {
  const alivePlayers = rrState.players.filter(p => p.alive);

  if(alivePlayers.length === 1) {
    rrState.phase = 'gameover';
    const winner = alivePlayers[0];

    const result = {
      type: 'rr-result',
      winnerId: winner.id,
      winnerName: winner.name,
      winnerAvatar: winner.avatar,
    };

    broadcast(result);
    handleRRResult(result);
    return;
  }

  if(alivePlayers.length === 0) {
    rrState.phase = 'gameover';
    broadcastRRState();
    return;
  }

  let nextIdx = (rrState.turnIdx + 1) % rrState.players.length;
  while(!rrState.players[nextIdx].alive) {
    nextIdx = (nextIdx + 1) % rrState.players.length;
  }

  rrState.turnIdx = nextIdx;
  rrState.phase = 'playing';
  broadcastRRState();
}

function handleRRResult(msg) {
  const won = msg.winnerId === state.myId;
  recordGame(won);

  document.getElementById('resultTitle').textContent = won ? '🏆 생존!' : '💀 탈락...';
  document.getElementById('resultTitle').style.color = won ? 'var(--success)' : 'var(--danger)';
  document.getElementById('winnerName').textContent = msg.winnerName + ' ' + msg.winnerAvatar + ' 승리!';
  document.getElementById('resultHand').textContent = '러시안 룰렛 최후의 생존자';
  document.getElementById('resultPot').textContent = '';
  document.getElementById('resultCards').innerHTML = '';
  document.getElementById('resultOverlay').classList.add('active');
}

function restartRoulette() {
  if(!state.isHost) return;
  startRussianRoulette();
}

function processRRAction(peerId, action) {
  const currentPlayer = rrState.players[rrState.turnIdx];
  if(!currentPlayer || currentPlayer.id !== peerId) return;

  if(action === 'spin') {
    spinCylinder();
  } else if(action === 'trigger') {
    pullTrigger();
  }
}

// ===== LOTTERY ROULETTE ENGINE =====

let lotteryState = {
  mode: 'lottery',
  items: [],
  grid: [],
  gridSize: 10,
  picked: [],
  spinning: false,
  resultAngle: 0,
  currentRotation: 0,
  phase: 'setup'
};

function startLottery() {
  if(!state.isHost) {
    showToast('호스트만 게임을 시작할 수 있습니다');
    return;
  }

  lotteryState.mode = 'lottery';
  lotteryState.phase = 'setup';

  broadcast({ type: 'game-start', game: 'lottery', state: lotteryState });
  showScreen('lotteryGame');
  renderLotterySetup();
}

function startLotteryGame() {
  if(!state.isHost) return;

  const itemsText = document.getElementById('lotteryItemsInput').value.trim();
  const gridSize = parseInt(document.getElementById('gridSizeSelect').value);

  if(!itemsText) {
    showToast('항목을 입력하세요');
    return;
  }

  const items = itemsText.split('\n').map(s => s.trim()).filter(s => s);

  if(items.length < 2) {
    showToast('최소 2개 항목 필요');
    return;
  }

  lotteryState.items = items;
  lotteryState.gridSize = gridSize;
  lotteryState.phase = 'playing';

  const totalCells = gridSize * gridSize;
  lotteryState.grid = [];

  for(let i = 0; i < totalCells; i++) {
    const item = items[Math.floor(Math.random() * items.length)];
    lotteryState.grid.push({
      index: i,
      item: item,
      revealed: false,
      revealedBy: null
    });
  }

  lotteryState.picked = [];

  const stateToSend = {
    mode: 'lottery',
    phase: 'playing',
    gridSize: gridSize,
    grid: lotteryState.grid.map(c => ({
      index: c.index,
      revealed: false,
      revealedBy: null
    })),
    items: items
  };

  broadcast({ type: 'lottery-state', state: stateToSend });
  renderLotteryGame(stateToSend);
}

function startRouletteGame() {
  if(!state.isHost) return;

  const itemsText = document.getElementById('rouletteItemsInput').value.trim();

  if(!itemsText) {
    showToast('항목을 입력하세요');
    return;
  }

  const items = itemsText.split('\n').map(s => s.trim()).filter(s => s);

  if(items.length < 2 || items.length > 12) {
    showToast('2~12개 항목 필요');
    return;
  }

  lotteryState.items = items;
  lotteryState.mode = 'roulette';
  lotteryState.phase = 'playing';
  lotteryState.currentRotation = 0;

  const stateToSend = {
    mode: 'roulette',
    phase: 'playing',
    items: items,
    currentRotation: 0
  };

  broadcast({ type: 'lottery-state', state: stateToSend });
  renderRouletteGame(stateToSend);
}

function pickLotteryCell(index) {
  if(lotteryState.phase !== 'playing') return;

  const cell = lotteryState.grid[index];
  if(!cell || cell.revealed) return;

  if(state.isHost) {
    cell.revealed = true;
    cell.revealedBy = state.myId;

    const update = {
      type: 'lottery-pick',
      index: index,
      item: cell.item,
      playerId: state.myId,
      playerName: state.myName
    };

    broadcast(update);
    handleLotteryPick(update);
  } else {
    const host = Object.values(state.connections)[0];
    if(host?.open) {
      host.send(JSON.stringify({
        type: 'lottery-pick-request',
        index: index,
        playerId: state.myId,
        playerName: state.myName
      }));
    }
  }
}

function handleLotteryPick(msg) {
  const cell = lotteryState.grid[msg.index];
  if(!cell) return;

  cell.revealed = true;
  cell.revealedBy = msg.playerId;
  cell.item = msg.item;

  lotteryState.picked.push({
    playerId: msg.playerId,
    playerName: msg.playerName,
    item: msg.item
  });

  const cellEl = document.querySelector(`[data-cell-index="${msg.index}"]`);
  if(cellEl) {
    cellEl.classList.add('revealed');
    cellEl.innerHTML = `<div class="cell-content">${msg.item}</div>`;
  }

  const pickedCount = lotteryState.grid.filter(c => c.revealed).length;

  if(document.getElementById('pickedCount')) {
    document.getElementById('pickedCount').textContent = pickedCount;
  }

  if(msg.playerId === state.myId) {
    updateMyLotteryResult();
  }

  showToast(`${msg.playerName}: ${msg.item}`);
}

function updateMyLotteryResult() {
  const myPicks = lotteryState.picked.filter(p => p.playerId === state.myId);

  if(myPicks.length > 0) {
    document.getElementById('myLotteryResult').style.display = 'block';
    const list = document.getElementById('myResultList');
    list.innerHTML = myPicks.map((p, i) =>
      `<div class="result-item">${i + 1}. ${p.item}</div>`
    ).join('');
  }
}

function spinRoulette() {
  if(lotteryState.spinning) return;

  const items = lotteryState.items;
  if(!items || items.length < 2) return;

  if(state.isHost) {
    const randomIndex = Math.floor(Math.random() * items.length);
    const resultItem = items[randomIndex];

    const anglePerItem = 360 / items.length;
    const targetAngle = randomIndex * anglePerItem;
    const fullRotations = 5 + Math.floor(Math.random() * 3);
    const totalRotation = lotteryState.currentRotation + (fullRotations * 360) + (360 - targetAngle);

    const spinData = {
      type: 'roulette-spin',
      resultItem: resultItem,
      resultIndex: randomIndex,
      totalRotation: totalRotation
    };

    broadcast(spinData);
    handleRouletteSpin(spinData);
  } else {
    const host = Object.values(state.connections)[0];
    if(host?.open) {
      host.send(JSON.stringify({
        type: 'roulette-spin-request',
        playerId: state.myId,
        playerName: state.myName
      }));
    }
  }
}

function handleRouletteSpin(msg) {
  lotteryState.spinning = true;
  lotteryState.currentRotation = msg.totalRotation;

  const wheel = document.getElementById('rouletteWheel');
  const btn = document.getElementById('rouletteSpinBtn');
  const resultDisplay = document.getElementById('rouletteResultDisplay');

  if(btn) btn.disabled = true;
  if(resultDisplay) resultDisplay.style.display = 'none';

  if(wheel) {
    wheel.style.transform = `rotate(${msg.totalRotation}deg)`;
  }

  setTimeout(() => {
    lotteryState.spinning = false;
    if(btn) btn.disabled = false;

    if(resultDisplay) {
      resultDisplay.style.display = 'block';
      document.getElementById('rouletteResultText').textContent = msg.resultItem;
    }

    showToast(`🎉 결과: ${msg.resultItem}`);
  }, 4000);
}

function switchLotteryMode(mode) {
  lotteryState.mode = mode;

  document.querySelectorAll('.mode-tab').forEach(tab => {
    tab.classList.remove('active');
  });

  document.querySelector(`[data-mode="${mode}"]`)?.classList.add('active');

  if(mode === 'lottery') {
    document.getElementById('lotteryModeContainer').style.display = 'flex';
    document.getElementById('rouletteModeContainer').style.display = 'none';

    if(state.isHost && lotteryState.phase === 'setup') {
      renderLotterySetup();
    }
  } else {
    document.getElementById('lotteryModeContainer').style.display = 'none';
    document.getElementById('rouletteModeContainer').style.display = 'flex';

    if(state.isHost && lotteryState.phase === 'setup') {
      renderRouletteSetup();
    }
  }
}

function renderLotterySetup() {
  const isHost = state.isHost;

  document.getElementById('lotterySetupPanel').style.display = isHost ? 'block' : 'none';
  document.getElementById('lotteryGridContainer').style.display = 'none';
  document.getElementById('myLotteryResult').style.display = 'none';

  if(!isHost) {
    document.getElementById('lotteryModeContainer').innerHTML = `
      <div style="flex:1;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:12px;">
        <div class="spinner"></div>
        <div style="color:var(--text-dim);font-size:14px;">호스트가 설정 중...</div>
      </div>
    `;
  }
}

function renderRouletteSetup() {
  const isHost = state.isHost;

  document.getElementById('rouletteSetupPanel').style.display = isHost ? 'block' : 'none';
  document.getElementById('rouletteDisplayContainer').style.display = 'none';

  if(!isHost) {
    document.getElementById('rouletteModeContainer').innerHTML = `
      <div style="flex:1;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:12px;">
        <div class="spinner"></div>
        <div style="color:var(--text-dim);font-size:14px;">호스트가 설정 중...</div>
      </div>
    `;
  }
}

function renderLotteryGame(stateData) {
  lotteryState.grid = stateData.grid;
  lotteryState.gridSize = stateData.gridSize;
  lotteryState.items = stateData.items;
  lotteryState.phase = 'playing';
  lotteryState.picked = [];

  document.getElementById('lotterySetupPanel').style.display = 'none';
  document.getElementById('lotteryGridContainer').style.display = 'flex';
  document.getElementById('myLotteryResult').style.display = 'none';

  const grid = document.getElementById('lotteryGrid');
  grid.style.gridTemplateColumns = `repeat(${stateData.gridSize}, 1fr)`;

  const totalCount = stateData.grid.length;
  document.getElementById('totalCount').textContent = totalCount;
  document.getElementById('pickedCount').textContent = '0';

  grid.innerHTML = stateData.grid.map((cell, i) => `
    <div class="lottery-cell" data-cell-index="${i}" onclick="pickLotteryCell(${i})">
      <div class="cell-content">?</div>
    </div>
  `).join('');
}

function renderRouletteGame(stateData) {
  lotteryState.items = stateData.items;
  lotteryState.phase = 'playing';
  lotteryState.currentRotation = stateData.currentRotation || 0;

  document.getElementById('rouletteSetupPanel').style.display = 'none';
  document.getElementById('rouletteDisplayContainer').style.display = 'flex';
  document.getElementById('rouletteResultDisplay').style.display = 'none';

  drawRouletteWheel(stateData.items);
}

function drawRouletteWheel(items) {
  const canvas = document.getElementById('rouletteCanvas');
  if(!canvas) return;

  const ctx = canvas.getContext('2d');
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const radius = canvas.width / 2 - 10;

  const anglePerItem = (2 * Math.PI) / items.length;

  const colors = [
    '#ff6b35', '#00e5ff', '#ff2d78', '#ffd700',
    '#76ff03', '#e040fb', '#ff6e40', '#18ffff',
    '#ffab40', '#69f0ae', '#ea80fc', '#ff80ab'
  ];

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  items.forEach((item, i) => {
    const startAngle = i * anglePerItem - Math.PI / 2;
    const endAngle = startAngle + anglePerItem;

    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
    ctx.closePath();

    ctx.fillStyle = colors[i % colors.length];
    ctx.fill();

    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.rotate(startAngle + anglePerItem / 2);
    ctx.textAlign = 'center';
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px "Noto Sans KR"';
    ctx.fillText(item, radius * 0.6, 5);
    ctx.restore();
  });

  ctx.beginPath();
  ctx.arc(centerX, centerY, 20, 0, 2 * Math.PI);
  ctx.fillStyle = '#1c1c3a';
  ctx.fill();
  ctx.strokeStyle = '#ff6b35';
  ctx.lineWidth = 3;
  ctx.stroke();
}

function handleLotteryMessage(peerId, msg) {
  if(msg.type === 'lottery-state') {
    showScreen('lotteryGame');

    if(msg.state.mode === 'lottery') {
      switchLotteryMode('lottery');
      renderLotteryGame(msg.state);
    } else {
      switchLotteryMode('roulette');
      renderRouletteGame(msg.state);
    }
  }
  else if(msg.type === 'lottery-pick-request') {
    if(state.isHost) {
      const cell = lotteryState.grid[msg.index];
      if(cell && !cell.revealed) {
        cell.revealed = true;
        cell.revealedBy = msg.playerId;

        const response = {
          type: 'lottery-pick',
          index: msg.index,
          item: cell.item,
          playerId: msg.playerId,
          playerName: msg.playerName
        };

        broadcast(response);
        handleLotteryPick(response);
      }
    }
  }
  else if(msg.type === 'lottery-pick') {
    handleLotteryPick(msg);
  }
  else if(msg.type === 'roulette-spin-request') {
    if(state.isHost && !lotteryState.spinning) {
      spinRoulette();
    }
  }
  else if(msg.type === 'roulette-spin') {
    handleRouletteSpin(msg);
  }
}

// ===== UP DOWN ENGINE =====

let udState = {
  deck: [],
  deckIdx: 0,
  currentCard: null,
  previousCard: null,
  turnIdx: 0,
  players: [],
  phase: 'playing',
  penalties: [],
  currentBet: null,
  specialData: null,
};

function startUpDown() {
  if(!state.isHost) return;

  const deck = [];
  const suits = ['\u2660','\u2665','\u2666','\u2663'];
  const ranks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];

  for(const suit of suits) {
    for(const rank of ranks) {
      deck.push({ rank, suit });
    }
  }

  for(let i = deck.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [deck[i], deck[j]] = [deck[j], deck[i]];
  }

  udState = {
    deck,
    deckIdx: 0,
    currentCard: deck[0],
    previousCard: null,
    turnIdx: 0,
    players: state.players.map(p => ({
      id: p.id,
      name: p.name,
      avatar: p.avatar,
    })),
    phase: 'playing',
    penalties: ['\uc18c\uc8fc 1\uc794', '\ub9c9\uac78\ub9ac 1\uc794', '\ud3ed\ud0c4\uc8fc 1\uc794'],
    currentBet: null,
    specialData: null,
  };

  udState.deckIdx = 1;

  broadcast({ type: 'game-start', game: 'updown', state: getUpDownView() });
  showScreen('updownGame');
  renderUpDownView(getUpDownView());
}

function getUpDownView() {
  return {
    currentCard: udState.currentCard,
    previousCard: udState.previousCard,
    deckRemaining: udState.deck.length - udState.deckIdx,
    turnIdx: udState.turnIdx,
    players: udState.players,
    phase: udState.phase,
    penalties: udState.penalties,
    currentBet: udState.currentBet,
    specialData: udState.specialData,
  };
}

function broadcastUpDownState() {
  const view = getUpDownView();
  broadcast({ type: 'ud-state', state: view });
  renderUpDownView(view);
}

function renderUpDownView(view) {
  if(!view) return;

  const currentPlayer = view.players[view.turnIdx];
  document.getElementById('updownTurnName').textContent =
    currentPlayer.id === state.myId ? '\ub0b4 \ucc28\ub840!' : currentPlayer.name + '\uc758 \ucc28\ub840';

  document.getElementById('updownDeckCount').textContent = '\ub0a8\uc740 \uce74\ub4dc: ' + view.deckRemaining;

  const prevSlot = document.getElementById('updownPrevCard');
  if(view.previousCard) {
    prevSlot.innerHTML =
      '<div class="updown-card-label">\uc774\uc804 \uce74\ub4dc</div>' +
      updownCardHTML(view.previousCard, false);
  } else {
    prevSlot.innerHTML =
      '<div class="updown-card-label">\uc774\uc804 \uce74\ub4dc</div>' +
      '<div class="updown-card-placeholder"></div>';
  }

  const currSlot = document.getElementById('updownCurrentCard');
  currSlot.innerHTML =
    '<div class="updown-card-label">\ud604\uc7ac \uce74\ub4dc</div>' +
    updownCardHTML(view.currentCard, true);

  setTimeout(() => {
    const card = currSlot.querySelector('.updown-card');
    if(card) card.classList.add('flipped');
  }, 100);

  const penaltyItems = document.getElementById('updownPenaltyItems');
  penaltyItems.innerHTML = view.penalties.slice(-5).map(p =>
    '<div class="updown-penalty-item">\ud83c\udf7a ' + p + '</div>'
  ).join('');

  const isMyTurn = currentPlayer.id === state.myId;
  const choiceButtons = document.getElementById('updownChoiceButtons').querySelectorAll('.updown-btn');
  choiceButtons.forEach(btn => btn.disabled = !isMyTurn || view.phase !== 'playing');

  document.getElementById('updownSpecialJQ').style.display = 'none';
  document.getElementById('updownSpecialK').style.display = 'none';

  if(isMyTurn && view.phase === 'special_jq') {
    showUpDownJQArea(view);
  } else if(isMyTurn && view.phase === 'special_k') {
    showUpDownKArea(view);
  }

  const resultDiv = document.getElementById('updownResult');
  if(view.phase === 'result' && view.specialData?.result) {
    resultDiv.textContent = view.specialData.result;
    resultDiv.style.color = view.specialData.correct ? 'var(--success)' : 'var(--danger)';
  } else {
    resultDiv.textContent = '';
  }
}

function updownCardHTML(card, isFlippable) {
  if(!card) return '<div class="updown-card-placeholder"></div>';

  const isRed = card.suit === '\u2665' || card.suit === '\u2666';
  const colorClass = isRed ? 'red' : 'black';

  if(isFlippable) {
    return '<div class="updown-card"><div class="updown-card-inner">' +
      '<div class="updown-card-front ' + colorClass + '">' +
      '<span class="updown-card-rank">' + card.rank + '</span>' +
      '<span class="updown-card-suit">' + card.suit + '</span></div>' +
      '<div class="updown-card-back-face">\ud83c\udfb4</div></div></div>';
  } else {
    return '<div class="updown-card flipped"><div class="updown-card-inner">' +
      '<div class="updown-card-front ' + colorClass + '">' +
      '<span class="updown-card-rank">' + card.rank + '</span>' +
      '<span class="updown-card-suit">' + card.suit + '</span></div>' +
      '<div class="updown-card-back-face">\ud83c\udfb4</div></div></div>';
  }
}

function udChoice(choice) {
  if(state.isHost) {
    processUpDownChoice(state.myId, choice);
  } else {
    const host = Object.values(state.connections)[0];
    if(host?.open) {
      host.send(JSON.stringify({ type: 'ud-choice', choice }));
    }
  }
}

function processUpDownChoice(playerId, choice) {
  if(!state.isHost || udState.phase !== 'playing') return;

  const playerIdx = udState.players.findIndex(p => p.id === playerId);
  if(playerIdx !== udState.turnIdx) return;

  if(udState.deckIdx >= udState.deck.length) {
    showToast('\uce74\ub4dc\uac00 \ubaa8\ub450 \uc18c\uc9c4\ub418\uc5c8\uc2b5\ub2c8\ub2e4!');
    return;
  }

  const nextCard = udState.deck[udState.deckIdx];
  const currentValue = getCardValue(udState.currentCard);
  const nextValue = getCardValue(nextCard);

  let correct = false;
  if(choice === 'up') {
    correct = nextValue > currentValue;
  } else if(choice === 'down') {
    correct = nextValue < currentValue;
  }

  if(nextValue === currentValue) correct = false;

  udState.previousCard = udState.currentCard;
  udState.currentCard = nextCard;
  udState.deckIdx++;

  if(correct) {
    udState.specialData = { result: '\uc815\ub2f5!', correct: true };
    udState.phase = 'result';
    broadcastUpDownState();

    setTimeout(() => {
      udState.turnIdx = (udState.turnIdx + 1) % udState.players.length;
      udState.phase = 'playing';
      udState.specialData = null;
      broadcastUpDownState();
    }, 1500);

  } else {
    udState.specialData = { result: '\ud2c0\ub838\ub2e4!', correct: false };

    const rank = nextCard.rank;
    if(rank === 'J' || rank === 'Q') {
      udState.phase = 'special_jq';
      udState.specialData.type = 'jq';
      udState.specialData.requesterId = playerId;
      broadcastUpDownState();
    } else if(rank === 'K') {
      udState.phase = 'special_k';
      udState.specialData.type = 'k';
      udState.specialData.kingId = playerId;
      broadcastUpDownState();
    } else {
      udState.phase = 'penalty';
      const penaltyText = udState.currentBet || udState.penalties[Math.floor(Math.random() * udState.penalties.length)];
      showUpDownPenalty(playerId, penaltyText);
    }
  }
}

function getCardValue(card) {
  const values = { 'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13 };
  return values[card.rank] || 0;
}

function udAddBet() {
  const input = document.getElementById('updownBetInput');
  const text = input.value.trim();
  if(!text) {
    showToast('\ubc8c\uce59 \ub0b4\uc6a9\uc744 \uc785\ub825\ud558\uc138\uc694');
    return;
  }

  if(state.isHost) {
    udState.penalties.push(text);
    udState.currentBet = text;
    input.value = '';
    showToast('\ubc8c\uce59\uc774 \ucd94\uac00\ub418\uc5c8\uc2b5\ub2c8\ub2e4!');
    broadcastUpDownState();
  } else {
    const host = Object.values(state.connections)[0];
    if(host?.open) {
      host.send(JSON.stringify({ type: 'ud-addbet', text }));
    }
    input.value = '';
    showToast('\ubc8c\uce59 \ucd94\uac00 \uc694\uccad!');
  }
}

function showUpDownJQArea(view) {
  const area = document.getElementById('updownSpecialJQ');
  area.style.display = 'block';

  const select = document.getElementById('updownJQPlayerSelect');
  select.innerHTML = view.players
    .filter(p => p.id !== state.myId)
    .map((p, i) =>
      '<div class="updown-player-option" data-pid="' + p.id + '" onclick="selectUpDownPlayer(\'' + p.id + '\', \'jq\')">' +
        '<div class="player-avatar-sm" style="background:' + PLAYER_COLORS[i % PLAYER_COLORS.length] + ';">' + p.avatar + '</div>' +
        '<div>' + p.name + '</div>' +
      '</div>'
    ).join('');
}

function showUpDownKArea(view) {
  const area = document.getElementById('updownSpecialK');
  area.style.display = 'block';

  const select = document.getElementById('updownKPlayerSelect');
  select.innerHTML = view.players
    .filter(p => p.id !== state.myId)
    .map((p, i) =>
      '<div class="updown-player-option" data-pid="' + p.id + '" onclick="selectUpDownPlayer(\'' + p.id + '\', \'k\')">' +
        '<div class="player-avatar-sm" style="background:' + PLAYER_COLORS[i % PLAYER_COLORS.length] + ';">' + p.avatar + '</div>' +
        '<div>' + p.name + '</div>' +
      '</div>'
    ).join('');
}

let selectedUpDownPlayers = [];

function selectUpDownPlayer(pid, type) {
  if(type === 'jq') {
    selectedUpDownPlayers = [pid];
    document.querySelectorAll('#updownJQPlayerSelect .updown-player-option').forEach(el => {
      el.classList.toggle('selected', el.dataset.pid === pid);
    });
  } else if(type === 'k') {
    if(selectedUpDownPlayers.includes(pid)) {
      selectedUpDownPlayers = selectedUpDownPlayers.filter(id => id !== pid);
    } else {
      if(selectedUpDownPlayers.length < 3) {
        selectedUpDownPlayers.push(pid);
      } else {
        showToast('\ucd5c\ub300 3\uba85\uae4c\uc9c0 \uc120\ud0dd \uac00\ub2a5');
        return;
      }
    }

    document.querySelectorAll('#updownKPlayerSelect .updown-player-option').forEach(el => {
      el.classList.toggle('selected', selectedUpDownPlayers.includes(el.dataset.pid));
    });
  }
}

function udBlackKnight() {
  if(selectedUpDownPlayers.length === 0) {
    showToast('\ub300\uc0c1\uc744 \uc120\ud0dd\ud558\uc138\uc694');
    return;
  }

  const targetId = selectedUpDownPlayers[0];

  if(state.isHost) {
    processBlackKnight(state.myId, targetId);
  } else {
    const host = Object.values(state.connections)[0];
    if(host?.open) {
      host.send(JSON.stringify({ type: 'ud-special', action: 'blackknight', targetId }));
    }
  }

  selectedUpDownPlayers = [];
}

function processBlackKnight(requesterId, targetId) {
  if(!state.isHost) return;

  const penaltyText = udState.currentBet || udState.penalties[Math.floor(Math.random() * udState.penalties.length)];
  const requester = udState.players.find(p => p.id === requesterId);

  udState.specialData = {
    type: 'bk_request',
    requesterId,
    targetId,
    penaltyText,
    requesterName: requester.name,
  };

  const msg = {
    type: 'ud-bk-request',
    requesterId,
    requesterName: requester.name,
    penaltyText,
  };

  if(targetId === state.myId) {
    showUpDownBKModal(msg);
  } else {
    sendTo(targetId, msg);
  }

  showToast('\ud751\uae30\uc0ac \uc694\uccad \uc804\uc1a1!');
}

function showUpDownBKModal(data) {
  const modal = document.getElementById('updownBKModal');
  document.getElementById('updownBKText').textContent = data.penaltyText;
  document.getElementById('updownBKWho').textContent = data.requesterName + '\ub2d8\uc758 \uc694\uccad';
  modal.classList.add('active');

  modal.dataset.requesterId = data.requesterId;
  modal.dataset.penaltyText = data.penaltyText;
}

function udAcceptBK() {
  const modal = document.getElementById('updownBKModal');
  const requesterId = modal.dataset.requesterId;
  const penaltyText = modal.dataset.penaltyText;

  modal.classList.remove('active');

  if(state.isHost) {
    resolveBKAccept(requesterId, state.myId, penaltyText);
  } else {
    const host = Object.values(state.connections)[0];
    if(host?.open) {
      host.send(JSON.stringify({
        type: 'ud-bk-response',
        accepted: true,
        requesterId
      }));
    }
  }
}

function udRejectBK() {
  const modal = document.getElementById('updownBKModal');
  const requesterId = modal.dataset.requesterId;
  const penaltyText = modal.dataset.penaltyText;

  modal.classList.remove('active');

  if(state.isHost) {
    resolveBKReject(requesterId, state.myId, penaltyText);
  } else {
    const host = Object.values(state.connections)[0];
    if(host?.open) {
      host.send(JSON.stringify({
        type: 'ud-bk-response',
        accepted: false,
        requesterId
      }));
    }
  }
}

function resolveBKAccept(requesterId, acceptorId, penaltyText) {
  showUpDownPenalty(acceptorId, penaltyText);
  showToast('\ud751\uae30\uc0ac\uac00 \ubc8c\uce59\uc744 \ubc1b\uc558\uc2b5\ub2c8\ub2e4!');
}

function resolveBKReject(requesterId, rejectId, penaltyText) {
  const targets = udState.players
    .filter(p => p.id !== requesterId && p.id !== rejectId)
    .map(p => p.id);

  targets.forEach(tid => {
    showUpDownPenalty(tid, penaltyText);
  });

  showToast('\uac70\uc808! \ub098\uba38\uc9c0 \ubaa8\ub450 \ubc8c\uce59!');
}

function udKingPenalty() {
  if(selectedUpDownPlayers.length === 0) {
    showToast('\ucd5c\uc18c 1\uba85\uc744 \uc120\ud0dd\ud558\uc138\uc694');
    return;
  }

  if(state.isHost) {
    processKingPenalty(state.myId, selectedUpDownPlayers);
  } else {
    const host = Object.values(state.connections)[0];
    if(host?.open) {
      host.send(JSON.stringify({
        type: 'ud-special',
        action: 'king',
        targets: selectedUpDownPlayers
      }));
    }
  }

  selectedUpDownPlayers = [];
}

function processKingPenalty(kingId, targets) {
  if(!state.isHost) return;

  const penaltyText = udState.currentBet || '\uc655\uc758 \uba85\ub839: ' + udState.penalties[Math.floor(Math.random() * udState.penalties.length)];

  targets.forEach(tid => {
    showUpDownPenalty(tid, penaltyText);
  });

  showToast('\uc655\uc758 \ubc8c\uce59\uc774 \ub0b4\ub824\uc84c\uc2b5\ub2c8\ub2e4!');

  setTimeout(() => {
    udState.turnIdx = (udState.turnIdx + 1) % udState.players.length;
    udState.phase = 'playing';
    udState.specialData = null;
    udState.currentBet = null;
    broadcastUpDownState();
  }, 2000);
}

function showUpDownPenalty(playerId, penaltyText) {
  const msg = {
    type: 'ud-penalty',
    playerId,
    penaltyText,
  };

  broadcast(msg);
  handleUpDownPenalty(msg);
}

function handleUpDownPenalty(data) {
  if(data.playerId !== state.myId) return;

  const modal = document.getElementById('updownPenaltyModal');
  document.getElementById('updownPenaltyText').textContent = data.penaltyText;
  document.getElementById('updownPenaltyWho').textContent = '\ub2f9\uc2e0\uc758 \ubc8c\uce59\uc785\ub2c8\ub2e4!';
  modal.classList.add('active');

  modal.dataset.penaltyText = data.penaltyText;
}

function udAcceptPenalty() {
  const modal = document.getElementById('updownPenaltyModal');
  modal.classList.remove('active');

  showToast('\ubc8c\uce59 \uc218\ud589!');

  if(state.isHost) {
    continueUpDown();
  } else {
    const host = Object.values(state.connections)[0];
    if(host?.open) {
      host.send(JSON.stringify({ type: 'ud-penalty-done' }));
    }
  }
}

function udRejectPenalty() {
  const modal = document.getElementById('updownPenaltyModal');
  modal.classList.remove('active');

  showToast('\uc220 \ub9c8\uc2dc\uae30\ub85c \ub300\uccb4!');

  if(state.isHost) {
    continueUpDown();
  } else {
    const host = Object.values(state.connections)[0];
    if(host?.open) {
      host.send(JSON.stringify({ type: 'ud-penalty-done' }));
    }
  }
}

function continueUpDown() {
  if(!state.isHost) return;

  udState.turnIdx = (udState.turnIdx + 1) % udState.players.length;
  udState.phase = 'playing';
  udState.specialData = null;
  udState.currentBet = null;
  broadcastUpDownState();
}

// ===== YAHTZEE ENGINE =====

let yahState = {
  players: [],
  turnIdx: 0,
  dice: [1, 1, 1, 1, 1],
  held: [false, false, false, false, false],
  rollsLeft: 3,
  turnNum: 1,
  maxTurns: 13,
  selectedCategory: null,
  phase: 'rolling',
};

const YAHTZEE_CATEGORIES = [
  'ones', 'twos', 'threes', 'fours', 'fives', 'sixes',
  'three-kind', 'four-kind', 'full-house', 'small-straight',
  'large-straight', 'yahtzee', 'chance'
];

function startYahtzee() {
  if(!state.isHost || state.players.length < 2) {
    showToast('\ucd5c\uc18c 2\uba85 \ud544\uc694');
    return;
  }

  yahState = {
    players: state.players.map(p => ({
      id: p.id,
      name: p.name,
      avatar: p.avatar,
      scores: {
        ones: null, twos: null, threes: null, fours: null, fives: null, sixes: null,
        'three-kind': null, 'four-kind': null, 'full-house': null,
        'small-straight': null, 'large-straight': null, yahtzee: null, chance: null
      },
      total: 0
    })),
    turnIdx: 0,
    dice: [1, 1, 1, 1, 1],
    held: [false, false, false, false, false],
    rollsLeft: 3,
    turnNum: 1,
    maxTurns: 13,
    selectedCategory: null,
    phase: 'rolling'
  };

  yahRollDice();

  broadcastYahtzeeState();
  showScreen('yahtzeeGame');
  broadcast({ type: 'game-start', game: 'yahtzee', state: createYahtzeeView() });
}

function yahRollDice() {
  if(yahState.rollsLeft <= 0) return;

  yahState.dice = yahState.dice.map((val, idx) =>
    yahState.held[idx] ? val : Math.floor(Math.random() * 6) + 1
  );

  yahState.rollsLeft--;
  yahState.phase = 'rolling';
  yahState.selectedCategory = null;
}

function yahRoll() {
  if(!state.isHost) {
    const host = Object.values(state.connections)[0];
    if(host?.open) {
      host.send(JSON.stringify({ type: 'yah-action', action: 'roll' }));
    }
    return;
  }

  if(yahState.players[yahState.turnIdx].id !== state.myId) {
    showToast('\ub2f9\uc2e0\uc758 \ucc28\ub840\uac00 \uc544\ub2d9\ub2c8\ub2e4');
    return;
  }

  if(yahState.rollsLeft <= 0) {
    showToast('\ub354 \uc774\uc0c1 \uad74\ub9b4 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4');
    return;
  }

  yahRollDice();
  broadcastYahtzeeState();
}

function yahToggleHold(idx) {
  if(!state.isHost) {
    const host = Object.values(state.connections)[0];
    if(host?.open) {
      host.send(JSON.stringify({ type: 'yah-action', action: 'hold', index: idx }));
    }
    return;
  }

  if(yahState.players[yahState.turnIdx].id !== state.myId) {
    return;
  }

  if(yahState.rollsLeft === 3) {
    showToast('\uba3c\uc800 \uc8fc\uc0ac\uc704\ub97c \uad74\ub9ac\uc138\uc694');
    return;
  }

  yahState.held[idx] = !yahState.held[idx];
  broadcastYahtzeeState();
}

function yahSelectCategory(cat) {
  if(!state.isHost) {
    const host = Object.values(state.connections)[0];
    if(host?.open) {
      host.send(JSON.stringify({ type: 'yah-action', action: 'select', category: cat }));
    }
    return;
  }

  if(yahState.players[yahState.turnIdx].id !== state.myId) {
    return;
  }

  const player = yahState.players[yahState.turnIdx];
  if(player.scores[cat] !== null) {
    showToast('\uc774\ubbf8 \uae30\ub85d\ub41c \uce74\ud14c\uace0\ub9ac\uc785\ub2c8\ub2e4');
    return;
  }

  yahState.selectedCategory = cat;
  yahState.phase = 'scoring';
  broadcastYahtzeeState();
}

function yahScore() {
  if(!state.isHost) {
    const host = Object.values(state.connections)[0];
    if(host?.open) {
      host.send(JSON.stringify({ type: 'yah-action', action: 'score' }));
    }
    return;
  }

  if(yahState.players[yahState.turnIdx].id !== state.myId) {
    return;
  }

  if(!yahState.selectedCategory) {
    showToast('\uce74\ud14c\uace0\ub9ac\ub97c \uc120\ud0dd\ud558\uc138\uc694');
    return;
  }

  const player = yahState.players[yahState.turnIdx];
  const score = calcYahtzeeScore(yahState.dice, yahState.selectedCategory);
  player.scores[yahState.selectedCategory] = score;

  player.total = calculatePlayerTotal(player);

  const allFinished = yahState.players.every(p =>
    YAHTZEE_CATEGORIES.every(cat => p.scores[cat] !== null)
  );

  if(allFinished) {
    yahState.phase = 'gameover';
    broadcastYahtzeeState();
    handleYahtzeeGameOver();
    return;
  }

  yahState.turnIdx = (yahState.turnIdx + 1) % yahState.players.length;

  if(yahState.turnIdx === 0) {
    yahState.turnNum++;
  }

  yahState.dice = [1, 1, 1, 1, 1];
  yahState.held = [false, false, false, false, false];
  yahState.rollsLeft = 3;
  yahState.selectedCategory = null;
  yahState.phase = 'rolling';

  yahRollDice();

  broadcastYahtzeeState();
}

function calculatePlayerTotal(player) {
  let total = 0;

  const upperCats = ['ones', 'twos', 'threes', 'fours', 'fives', 'sixes'];
  let upperSum = 0;
  upperCats.forEach(cat => {
    if(player.scores[cat] !== null) {
      upperSum += player.scores[cat];
    }
  });

  let bonus = 0;
  if(upperSum >= 63) {
    bonus = 35;
  }

  total = upperSum + bonus;

  const lowerCats = ['three-kind', 'four-kind', 'full-house', 'small-straight', 'large-straight', 'yahtzee', 'chance'];
  lowerCats.forEach(cat => {
    if(player.scores[cat] !== null) {
      total += player.scores[cat];
    }
  });

  return total;
}

function calcYahtzeeScore(dice, category) {
  const counts = {};
  dice.forEach(d => counts[d] = (counts[d] || 0) + 1);
  const sorted = [...dice].sort((a, b) => a - b);
  const sum = dice.reduce((a, b) => a + b, 0);

  switch(category) {
    case 'ones': return dice.filter(d => d === 1).length * 1;
    case 'twos': return dice.filter(d => d === 2).length * 2;
    case 'threes': return dice.filter(d => d === 3).length * 3;
    case 'fours': return dice.filter(d => d === 4).length * 4;
    case 'fives': return dice.filter(d => d === 5).length * 5;
    case 'sixes': return dice.filter(d => d === 6).length * 6;

    case 'three-kind':
      return Object.values(counts).some(c => c >= 3) ? sum : 0;

    case 'four-kind':
      return Object.values(counts).some(c => c >= 4) ? sum : 0;

    case 'full-house': {
      const vals = Object.values(counts).sort((a, b) => b - a);
      return (vals[0] === 3 && vals[1] === 2) ? 25 : 0;
    }

    case 'small-straight': {
      const unique = [...new Set(sorted)];
      const patterns = [[1,2,3,4], [2,3,4,5], [3,4,5,6]];
      return patterns.some(p => p.every(n => unique.includes(n))) ? 30 : 0;
    }

    case 'large-straight': {
      const str1 = [1,2,3,4,5];
      const str2 = [2,3,4,5,6];
      return (JSON.stringify(sorted) === JSON.stringify(str1) ||
              JSON.stringify(sorted) === JSON.stringify(str2)) ? 40 : 0;
    }

    case 'yahtzee':
      return Object.values(counts).some(c => c === 5) ? 50 : 0;

    case 'chance':
      return sum;

    default:
      return 0;
  }
}

function calcPossibleScores(dice) {
  const possible = {};
  YAHTZEE_CATEGORIES.forEach(cat => {
    possible[cat] = calcYahtzeeScore(dice, cat);
  });
  return possible;
}

function broadcastYahtzeeState() {
  const view = createYahtzeeView();
  broadcast({ type: 'yah-state', state: view });
  renderYahtzeeView(view);
}

function createYahtzeeView() {
  return {
    players: yahState.players.map(p => ({
      id: p.id,
      name: p.name,
      avatar: p.avatar,
      scores: p.scores,
      total: p.total
    })),
    turnIdx: yahState.turnIdx,
    dice: yahState.dice,
    held: yahState.held,
    rollsLeft: yahState.rollsLeft,
    turnNum: yahState.turnNum,
    maxTurns: yahState.maxTurns,
    selectedCategory: yahState.selectedCategory,
    phase: yahState.phase
  };
}

function renderYahtzeeView(view) {
  document.getElementById('yahTurnText').textContent = '\ud134 ' + view.turnNum + '/' + view.maxTurns;
  const currentPlayer = view.players[view.turnIdx];
  document.getElementById('yahCurrentPlayer').textContent =
    currentPlayer.id === state.myId ? '\ub0b4 \ucc28\ub840!' : currentPlayer.name + '\uc758 \ucc28\ub840';
  document.getElementById('yahRollsLeft').textContent = view.rollsLeft + ' left';

  const playersBar = document.getElementById('yahtzeePlayersBar');
  playersBar.innerHTML = view.players.map((p, idx) =>
    '<div class="yahtzee-player-mini ' + (idx === view.turnIdx ? 'active' : '') + '">' +
      '<div class="yahtzee-player-mini-avatar" style="background:' + PLAYER_COLORS[idx % PLAYER_COLORS.length] + ';">' +
        p.avatar +
      '</div>' +
      '<div class="yahtzee-player-mini-name">' + p.name + '</div>' +
      '<div class="yahtzee-player-mini-score">' + p.total + '</div>' +
    '</div>'
  ).join('');

  view.dice.forEach((val, idx) => {
    const die = document.querySelector('.yahtzee-die[data-idx="' + idx + '"]');
    const face = document.getElementById('yahdice' + idx);

    if(die.classList.contains('held') !== view.held[idx]) {
      if(view.held[idx]) die.classList.add('held');
      else die.classList.remove('held');
    }

    face.setAttribute('data-value', val);
    face.innerHTML = Array(val).fill('<span class="pip"></span>').join('');

    die.classList.remove('rolling');
    setTimeout(() => die.classList.add('rolling'), 10);
    setTimeout(() => die.classList.remove('rolling'), 500);
  });

  const rollBtn = document.getElementById('yahtzeeRollBtn');
  const isMyTurn = currentPlayer.id === state.myId;
  rollBtn.disabled = !isMyTurn || view.rollsLeft <= 0 || view.phase === 'gameover';

  const myPlayer = view.players.find(p => p.id === state.myId);
  if(myPlayer) {
    const possible = calcPossibleScores(view.dice);

    ['ones', 'twos', 'threes', 'fours', 'fives', 'sixes'].forEach(cat => {
      const cell = document.getElementById('yahcat-' + cat);
      const row = document.querySelector('.yahtzee-score-row[data-cat="' + cat + '"]');

      if(myPlayer.scores[cat] !== null) {
        cell.textContent = myPlayer.scores[cat];
        row.classList.add('filled');
        row.classList.remove('preview', 'selected');
        row.onclick = null;
      } else if(isMyTurn && view.rollsLeft < 3) {
        cell.textContent = possible[cat];
        row.classList.add('preview');
        row.classList.remove('filled');
        if(view.selectedCategory === cat) {
          row.classList.add('selected');
        } else {
          row.classList.remove('selected');
        }
        row.onclick = () => yahSelectCategory(cat);
      } else {
        cell.textContent = '-';
        row.classList.remove('preview', 'filled', 'selected');
        row.onclick = null;
      }
    });

    const upperCats = ['ones', 'twos', 'threes', 'fours', 'fives', 'sixes'];
    let upperSum = 0;
    upperCats.forEach(cat => {
      if(myPlayer.scores[cat] !== null) {
        upperSum += myPlayer.scores[cat];
      }
    });
    document.getElementById('yahcat-upper-subtotal').textContent = upperSum;

    const bonus = upperSum >= 63 ? 35 : 0;
    document.getElementById('yahcat-bonus').textContent = bonus;

    ['three-kind', 'four-kind', 'full-house', 'small-straight', 'large-straight', 'yahtzee', 'chance'].forEach(cat => {
      const cell = document.getElementById('yahcat-' + cat);
      const row = document.querySelector('.yahtzee-score-row[data-cat="' + cat + '"]');

      if(myPlayer.scores[cat] !== null) {
        cell.textContent = myPlayer.scores[cat];
        row.classList.add('filled');
        row.classList.remove('preview', 'selected');
        row.onclick = null;
      } else if(isMyTurn && view.rollsLeft < 3) {
        cell.textContent = possible[cat];
        row.classList.add('preview');
        row.classList.remove('filled');
        if(view.selectedCategory === cat) {
          row.classList.add('selected');
        } else {
          row.classList.remove('selected');
        }
        row.onclick = () => yahSelectCategory(cat);
      } else {
        cell.textContent = '-';
        row.classList.remove('preview', 'filled', 'selected');
        row.onclick = null;
      }
    });

    document.getElementById('yahcat-total').textContent = myPlayer.total;
  }

  const scoreBtn = document.getElementById('yahtzeeScoreBtn');
  scoreBtn.style.display = (isMyTurn && view.selectedCategory && view.phase === 'scoring') ? 'block' : 'none';

  if(view.phase === 'gameover') {
    showYahtzeeGameOver(view);
  }
}

function showYahtzeeGameOver(view) {
  const gameOverDiv = document.getElementById('yahtzeeGameOver');
  const rankings = document.getElementById('yahtzeeRankings');

  const sorted = [...view.players].sort((a, b) => b.total - a.total);

  rankings.innerHTML = sorted.map((p, idx) => {
    const rank = idx + 1;
    const rankClass = rank === 1 ? 'first' : rank === 2 ? 'second' : rank === 3 ? 'third' : '';
    const pIdx = view.players.findIndex(pp => pp.id === p.id);

    return '<div class="yahtzee-rank-item ' + rankClass + '">' +
      '<div class="yahtzee-rank-number">' + rank + '\uc704</div>' +
      '<div class="yahtzee-rank-avatar" style="background:' + PLAYER_COLORS[pIdx % PLAYER_COLORS.length] + ';">' +
        p.avatar +
      '</div>' +
      '<div class="yahtzee-rank-info">' +
        '<div class="yahtzee-rank-name">' + p.name + (p.id === state.myId ? ' (\ub098)' : '') + '</div>' +
      '</div>' +
      '<div class="yahtzee-rank-score">' + p.total + '\uc810</div>' +
    '</div>';
  }).join('');

  gameOverDiv.style.display = 'flex';

  const winner = sorted[0];
  const won = winner.id === state.myId;
  recordGame(won);
}

function handleYahtzeeGameOver() {
  const view = createYahtzeeView();
  broadcast({ type: 'yah-state', state: view });
  showYahtzeeGameOver(view);
}

function closeYahtzeeGame() {
  document.getElementById('yahtzeeGameOver').style.display = 'none';
  if(state.isHost) {
    showScreen('lobby');
  } else {
    leaveLobby();
  }
}

// ===== E CARD ENGINE =====
let ecState = {
  player1: { id: '', name: '', avatar: '', role: 'emperor', cards: [], played: null },
  player2: { id: '', name: '', avatar: '', role: 'slave', cards: [], played: null },
  round: 1,
  maxRounds: 5,
  score: { emperor: 0, slave: 0 },
  bet: 100,
  betProposed: null,
  betAccepted: false,
  phase: 'role-assign',
  selectedCard: null,
};

function startECard() {
  if (state.players.length !== 2) {
    showToast('E\uce74\ub4dc\ub294 \uc815\ud655\ud788 2\uba85\ub9cc \ud50c\ub808\uc774 \uac00\ub2a5\ud569\ub2c8\ub2e4');
    return;
  }

  const roles = ['emperor', 'slave'];
  const shuffled = roles.sort(() => Math.random() - 0.5);

  ecState = {
    player1: {
      id: state.players[0].id,
      name: state.players[0].name,
      avatar: state.players[0].avatar,
      role: shuffled[0],
      cards: shuffled[0] === 'emperor'
        ? ['emperor', 'citizen', 'citizen', 'citizen', 'citizen']
        : ['slave', 'dummy', 'citizen', 'citizen', 'citizen'],
      played: null,
    },
    player2: {
      id: state.players[1].id,
      name: state.players[1].name,
      avatar: state.players[1].avatar,
      role: shuffled[1],
      cards: shuffled[1] === 'emperor'
        ? ['emperor', 'citizen', 'citizen', 'citizen', 'citizen']
        : ['slave', 'dummy', 'citizen', 'citizen', 'citizen'],
      played: null,
    },
    round: 1,
    maxRounds: 5,
    score: { emperor: 0, slave: 0 },
    bet: 100,
    betProposed: null,
    betAccepted: false,
    phase: 'betting',
    selectedCard: null,
  };

  state.ecard = ecState;
  broadcastECardState();
  showScreen('ecardGame');
}

function broadcastECardState() {
  const ec = state.ecard;

  [ec.player1, ec.player2].forEach(p => {
    const opponent = p === ec.player1 ? ec.player2 : ec.player1;
    const view = {
      type: 'ec-state',
      myId: p.id,
      myRole: p.role,
      myCards: p.cards,
      myPlayed: p.played,
      myName: p.name,
      myAvatar: p.avatar,
      oppId: opponent.id,
      oppName: opponent.name,
      oppAvatar: opponent.avatar,
      oppRole: opponent.role,
      oppCardsCount: opponent.cards.length,
      oppPlayed: opponent.played,
      round: ec.round,
      maxRounds: ec.maxRounds,
      score: ec.score,
      bet: ec.bet,
      betProposed: ec.betProposed,
      betAccepted: ec.betAccepted,
      phase: ec.phase,
    };

    if (p.id === state.myId) {
      renderECardView(view);
    } else {
      sendTo(p.id, view);
    }
  });
}

function renderECardView(view) {
  state._ecardView = view;

  document.getElementById('ecardRound').textContent = view.round;
  document.getElementById('ecardScoreEmperor').textContent = view.score.emperor;
  document.getElementById('ecardScoreSlave').textContent = view.score.slave;

  const roleIcon = view.myRole === 'emperor' ? '\ud83d\udc51' : '\u26d3\ufe0f';
  const roleName = view.myRole === 'emperor' ? '\ud669\uc81c' : '\ub178\uc608';
  const roleColor = view.myRole === 'emperor' ? 'var(--gold)' : '#c0c0c0';

  document.getElementById('ecardRoleIcon').textContent = roleIcon;
  document.getElementById('ecardRoleName').textContent = roleName;
  document.getElementById('ecardRoleName').style.color = roleColor;

  const oppIndex = state.players.findIndex(p => p.id === view.oppId);
  document.getElementById('ecardOppAvatar').style.background = PLAYER_COLORS[oppIndex % PLAYER_COLORS.length];
  document.getElementById('ecardOppAvatar').textContent = view.oppAvatar;
  document.getElementById('ecardOppName').textContent = view.oppName;
  document.getElementById('ecardOppCardsCount').textContent = view.oppCardsCount;

  const oppPlayedEl = document.getElementById('ecardOppPlayedCard');
  if (view.phase === 'emperor-play' && view.myRole === 'emperor' && view.oppPlayed) {
    oppPlayedEl.innerHTML = '<div class="ecard-card ecard-card-back" style="width:70px;height:100px;"></div>';
  } else if (view.phase === 'reveal' && view.oppPlayed) {
    oppPlayedEl.innerHTML = ecardCardHTML(view.oppPlayed, false);
  } else {
    oppPlayedEl.innerHTML = '';
  }

  document.getElementById('ecardMyCardsCount').textContent = view.myCards.length;
  const myCardsEl = document.getElementById('ecardMyCards');
  myCardsEl.innerHTML = view.myCards.map((card, i) =>
    '<div class="ecard-card ecard-card-' + card + ' ' + (ecState.selectedCard === i ? 'selected' : '') + '"' +
          ' onclick="ecardSelectCard(' + i + ')" data-card-idx="' + i + '">' +
      '<div class="ecard-card-icon">' + ecardCardIcon(card) + '</div>' +
      '<div class="ecard-card-name">' + ecardCardName(card) + '</div>' +
    '</div>'
  ).join('');

  const battleArea = document.getElementById('ecardBattleArea');
  if (view.phase === 'reveal' && view.myPlayed && view.oppPlayed) {
    battleArea.style.display = 'flex';
    document.getElementById('ecardBattleOpp').innerHTML = ecardCardHTML(view.oppPlayed, false).replace('width:70px;height:100px;', 'width:80px;height:115px;');
    document.getElementById('ecardBattleMy').innerHTML = ecardCardHTML(view.myPlayed, false).replace('width:70px;height:100px;', 'width:80px;height:115px;');
  } else {
    battleArea.style.display = 'none';
  }

  const resultTextEl = document.getElementById('ecardResultText');
  if (view.phase === 'result') {
    const result = state.ecard._lastResult;
    if (result) {
      resultTextEl.textContent = result.message;
      resultTextEl.style.color = result.winner === view.myRole ? 'var(--gold)' : 'var(--text-dim)';
    }
  } else {
    resultTextEl.textContent = '';
  }

  const betArea = document.getElementById('ecardBetArea');
  const betResponse = document.getElementById('ecardBetResponse');
  const actionButtons = document.getElementById('ecardActionButtons');
  const waiting = document.getElementById('ecardWaiting');

  betArea.style.display = 'none';
  betResponse.style.display = 'none';
  actionButtons.style.display = 'none';
  waiting.style.display = 'none';

  if (view.phase === 'betting') {
    if (view.myRole === 'slave' && !view.betProposed) {
      betArea.style.display = 'block';
    } else if (view.myRole === 'emperor' && view.betProposed && !view.betAccepted) {
      betResponse.style.display = 'block';
      document.getElementById('ecardBetProposed').textContent = view.betProposed;
    } else {
      waiting.style.display = 'flex';
      document.getElementById('ecardWaitingText').textContent = '\ubc30\ud305 \ub300\uae30 \uc911...';
    }
  } else if (view.phase === 'slave-play') {
    if (view.myRole === 'slave') {
      actionButtons.style.display = 'flex';
      document.getElementById('ecardSubmitBtn').disabled = ecState.selectedCard === null;
    } else {
      waiting.style.display = 'flex';
      document.getElementById('ecardWaitingText').textContent = '\ub178\uc608\uac00 \uce74\ub4dc\ub97c \uc120\ud0dd \uc911...';
    }
  } else if (view.phase === 'emperor-play') {
    if (view.myRole === 'emperor') {
      actionButtons.style.display = 'flex';
      document.getElementById('ecardSubmitBtn').disabled = ecState.selectedCard === null;
    } else {
      waiting.style.display = 'flex';
      document.getElementById('ecardWaitingText').textContent = '\ud669\uc81c\uac00 \uce74\ub4dc\ub97c \uc120\ud0dd \uc911...';
    }
  }
}

function ecardCardIcon(card) {
  const icons = {
    emperor: '\ud83d\udc51',
    citizen: '\ud83e\udd35',
    slave: '\u26d3\ufe0f',
    dummy: '\u2753',
  };
  return icons[card] || '?';
}

function ecardCardName(card) {
  const names = {
    emperor: '\ud669\uc81c',
    citizen: '\uc2dc\ubbfc',
    slave: '\ub178\uc608',
    dummy: '\ub354\ubbf8',
  };
  return names[card] || '?';
}

function ecardCardHTML(card, isBack) {
  if (isBack) {
    return '<div class="ecard-card ecard-card-back" style="width:70px;height:100px;"></div>';
  }
  return '<div class="ecard-card ecard-card-' + card + '" style="width:70px;height:100px;">' +
    '<div class="ecard-card-icon">' + ecardCardIcon(card) + '</div>' +
    '<div class="ecard-card-name">' + ecardCardName(card) + '</div>' +
  '</div>';
}

function ecardSelectCard(idx) {
  const view = state._ecardView;
  if (!view) return;

  const canPlay = (view.phase === 'slave-play' && view.myRole === 'slave') ||
                  (view.phase === 'emperor-play' && view.myRole === 'emperor');

  if (!canPlay) return;

  ecState.selectedCard = idx;
  renderECardView(view);
}

document.getElementById('ecardBetSlider').addEventListener('input', function(e) {
  document.getElementById('ecardBetAmount').textContent = e.target.value;
});

function ecardSubmitBet() {
  const bet = parseInt(document.getElementById('ecardBetSlider').value);
  if (state.isHost) {
    processECardBet(state.myId, bet);
  } else {
    const host = Object.values(state.connections)[0];
    if (host?.open) host.send(JSON.stringify({ type: 'ec-bet', bet }));
  }
}

function ecardAcceptBet() {
  if (state.isHost) {
    processECardBetResponse(state.myId, true);
  } else {
    const host = Object.values(state.connections)[0];
    if (host?.open) host.send(JSON.stringify({ type: 'ec-bet-response', accept: true }));
  }
}

function ecardRejectBet() {
  if (state.isHost) {
    processECardBetResponse(state.myId, false);
  } else {
    const host = Object.values(state.connections)[0];
    if (host?.open) host.send(JSON.stringify({ type: 'ec-bet-response', accept: false }));
  }
}

function ecardSubmitCard() {
  if (ecState.selectedCard === null) {
    showToast('\uce74\ub4dc\ub97c \uc120\ud0dd\ud558\uc138\uc694');
    return;
  }

  const view = state._ecardView;
  const cardType = view.myCards[ecState.selectedCard];

  if (state.isHost) {
    processECardPlay(state.myId, cardType, ecState.selectedCard);
  } else {
    const host = Object.values(state.connections)[0];
    if (host?.open) host.send(JSON.stringify({ type: 'ec-play', cardType, cardIdx: ecState.selectedCard }));
  }

  ecState.selectedCard = null;
}

function processECardBet(playerId, bet) {
  if (!state.isHost) return;
  const ec = state.ecard;
  if (ec.phase !== 'betting') return;

  const player = ec.player1.id === playerId ? ec.player1 : ec.player2;
  if (player.role !== 'slave') return;

  ec.betProposed = bet;
  broadcastECardState();
}

function processECardBetResponse(playerId, accept) {
  if (!state.isHost) return;
  const ec = state.ecard;
  if (ec.phase !== 'betting') return;

  const player = ec.player1.id === playerId ? ec.player1 : ec.player2;
  if (player.role !== 'emperor') return;

  if (accept) {
    ec.bet = ec.betProposed;
    ec.betAccepted = true;
    ec.phase = 'slave-play';
    broadcastECardState();
  } else {
    ec.betProposed = null;
    broadcastECardState();
    showToast('\ud669\uc81c\uac00 \ubc30\ud305\uc744 \uac70\uc808\ud588\uc2b5\ub2c8\ub2e4. \ub2e4\uc2dc \uc81c\uc548\ud558\uc138\uc694.');
  }
}

function processECardPlay(playerId, cardType, cardIdx) {
  if (!state.isHost) return;
  const ec = state.ecard;

  const player = ec.player1.id === playerId ? ec.player1 : ec.player2;

  if (ec.phase === 'slave-play' && player.role === 'slave') {
    player.played = cardType;
    player.cards.splice(cardIdx, 1);
    ec.phase = 'emperor-play';
    broadcastECardState();
  } else if (ec.phase === 'emperor-play' && player.role === 'emperor') {
    player.played = cardType;
    player.cards.splice(cardIdx, 1);
    ec.phase = 'reveal';
    broadcastECardState();
    setTimeout(() => ecardReveal(), 1500);
  }
}

function ecardReveal() {
  if (!state.isHost) return;
  const ec = state.ecard;

  const card1 = ec.player1.played;
  const card2 = ec.player2.played;

  const result = ecardJudge(card1, card2);

  let winner = null;
  let message = '';

  if (result === 0) {
    message = '\ubb34\uc2b9\ubd80! (\ub354\ubbf8 \ub610\ub294 \uc2dc\ubbfc vs \uc2dc\ubbfc)';
  } else if (result === 1) {
    winner = ec.player1.role;
    message = ec.player1.name + ' \uc2b9\ub9ac!';
    if (ec.player1.role === 'emperor') ec.score.emperor++;
    else ec.score.slave++;
  } else {
    winner = ec.player2.role;
    message = ec.player2.name + ' \uc2b9\ub9ac!';
    if (ec.player2.role === 'emperor') ec.score.emperor++;
    else ec.score.slave++;
  }

  ec._lastResult = { winner, message };
  ec.phase = 'result';
  broadcastECardState();

  setTimeout(() => {
    if (ec.round >= ec.maxRounds) {
      ecardGameOver();
    } else {
      ecardNextRound();
    }
  }, 3000);
}

function ecardJudge(card1, card2) {
  if (card1 === 'dummy' || card2 === 'dummy') return 0;
  if (card1 === 'citizen' && card2 === 'citizen') return 0;
  if (card1 === 'emperor' && card2 === 'citizen') return 1;
  if (card1 === 'citizen' && card2 === 'emperor') return -1;
  if (card1 === 'citizen' && card2 === 'slave') return 1;
  if (card1 === 'slave' && card2 === 'citizen') return -1;
  if (card1 === 'slave' && card2 === 'emperor') return 1;
  if (card1 === 'emperor' && card2 === 'slave') return -1;
  return 0;
}

function ecardNextRound() {
  if (!state.isHost) return;
  const ec = state.ecard;

  ec.round++;
  ec.player1.played = null;
  ec.player2.played = null;
  ec.betProposed = null;
  ec.betAccepted = false;
  ec.phase = 'betting';
  ec._lastResult = null;

  broadcastECardState();
}

function ecardGameOver() {
  if (!state.isHost) return;
  const ec = state.ecard;

  const emperorScore = ec.score.emperor;
  const slaveScore = ec.score.slave;

  let winnerRole = null;
  let message = '';

  if (emperorScore > slaveScore) {
    winnerRole = 'emperor';
    message = '\ud669\uc81c \uc2b9\ub9ac!';
  } else if (slaveScore > emperorScore) {
    winnerRole = 'slave';
    message = '\ub178\uc608 \uc2b9\ub9ac! \ub300\uc5ed\uc804!';
  } else {
    message = '\ubb34\uc2b9\ubd80!';
  }

  const winner = ec.player1.role === winnerRole ? ec.player1 : (ec.player2.role === winnerRole ? ec.player2 : null);

  const result = {
    type: 'ec-result',
    winnerId: winner?.id,
    winnerName: winner?.name || '\ubb34\uc2b9\ubd80',
    winnerRole,
    message,
    score: ec.score,
  };

  broadcast(result);
  handleECardResult(result);
}

function handleECardResult(msg) {
  const won = msg.winnerId === state.myId;
  recordGame(won);

  document.getElementById('resultTitle').textContent = won ? '\uc2b9\ub9ac!' : (msg.winnerId ? '\ud328\ubc30...' : '\ubb34\uc2b9\ubd80');
  document.getElementById('resultTitle').style.color = won ? 'var(--gold)' : 'var(--text-dim)';
  document.getElementById('winnerName').textContent = msg.message;
  document.getElementById('resultHand').textContent = '\ucd5c\uc885 \uc810\uc218: \ud669\uc81c ' + msg.score.emperor + ' - ' + msg.score.slave + ' \ub178\uc608';
  document.getElementById('resultPot').textContent = '';
  document.getElementById('resultCards').innerHTML = '';
  document.getElementById('resultOverlay').classList.add('active');
}

// ===== SUTDA ENGINE =====

// --- 화투패 정의 ---
const HWATU_DECK = [];
(function buildHwatuDeck() {
  for (let i = 1; i <= 10; i++) {
    const isGwangMonth = [1, 3, 8].includes(i);
    // 광 또는 첫번째 패
    HWATU_DECK.push({ num: i, gwang: isGwangMonth, id: i + 'g' });
    // 비광 또는 두번째 패
    HWATU_DECK.push({ num: i, gwang: false, id: i + 'n' });
  }
})();

// 광 이름
const GWANG_NAMES = { 1: '송학', 3: '사쿠라', 8: '공산' };

// --- 호스트 상태 ---
let sutdaHost = null;

// --- 클라이언트 뷰 ---
let sutdaView = null;

// =========================
// 족보 판정 함수 (핵심!)
// =========================
function getSutdaRank(card1, card2) {
  const n1 = card1.num, n2 = card2.num;
  const g1 = card1.gwang, g2 = card2.gwang;

  // === 광땡 체크 (최상위) ===
  // 38광땡: 3광 + 8광
  if ((n1 === 3 && g1 && n2 === 8 && g2) || (n1 === 8 && g1 && n2 === 3 && g2)) {
    return { rank: 100, name: '38광땡', tier: 'gwangttaeng' };
  }
  // 18광땡: 1광 + 8광
  if ((n1 === 1 && g1 && n2 === 8 && g2) || (n1 === 8 && g1 && n2 === 1 && g2)) {
    return { rank: 99, name: '18광땡', tier: 'gwangttaeng' };
  }
  // 13광땡: 1광 + 3광
  if ((n1 === 1 && g1 && n2 === 3 && g2) || (n1 === 3 && g1 && n2 === 1 && g2)) {
    return { rank: 98, name: '13광땡', tier: 'gwangttaeng' };
  }

  // === 땡 (같은 숫자 2장) ===
  if (n1 === n2) {
    const ttRank = 80 + n1; // 1땡=81, ... 10땡(장땡)=90
    const ttName = n1 === 10 ? '장땡' : n1 + '땡';
    return { rank: ttRank, name: ttName, tier: 'ttaeng' };
  }

  // === 특수패 체크 ===
  // 암행어사 (4+7): 13광땡, 18광땡만 잡음
  if ((n1 === 4 && n2 === 7) || (n1 === 7 && n2 === 4)) {
    return { rank: 75, name: '암행어사', tier: 'special', special: '47' };
  }
  // 땡잡이 (3+7): 모든 땡을 잡음, 일반패에겐 짐
  if ((n1 === 3 && n2 === 7) || (n1 === 7 && n2 === 3)) {
    return { rank: 74, name: '땡잡이', tier: 'special', special: '37' };
  }
  // 세륙 (6+4): 특수 기능
  if ((n1 === 6 && n2 === 4) || (n1 === 4 && n2 === 6)) {
    return { rank: 73, name: '세륙', tier: 'special', special: '64' };
  }

  // === 끗 (두 수의 합의 일의 자리) ===
  const kkut = (n1 + n2) % 10;
  const mult = n1 * n2; // 같은 끗일 때 곱으로 비교

  if (kkut === 9) {
    return { rank: 60, name: '갑오', tier: 'kkut', kkut: 9, mult: mult };
  }
  if (kkut === 0) {
    return { rank: 50, name: '망통', tier: 'kkut', kkut: 0, mult: mult };
  }
  // 1끗~8끗
  return { rank: 50 + kkut, name: kkut + '끗', tier: 'kkut', kkut: kkut, mult: mult };
}

// =========================
// 대결 판정 함수
// =========================
function sutdaCompare(r1, r2) {
  // 38광땡은 무적 (암행어사도 못 잡음)
  if (r1.rank === 100) return 1;
  if (r2.rank === 100) return -1;

  // 암행어사: 13광땡(98), 18광땡(99)만 잡음
  if (r1.special === '47' && (r2.rank === 99 || r2.rank === 98)) return 1;
  if (r2.special === '47' && (r1.rank === 99 || r1.rank === 98)) return -1;

  // 암행어사 vs 일반패: 암행어사는 일반 끗수로 계산 (4+7=1끗)
  // 이미 rank가 75로 설정되어 있으므로, 특수 잡기 실패 시 끗수로 재계산
  if (r1.special === '47' && r2.rank < 98) {
    const r1asKkut = { rank: 51, name: '1끗', tier: 'kkut', kkut: 1, mult: 28 };
    return sutdaCompare(r1asKkut, r2);
  }
  if (r2.special === '47' && r1.rank < 98) {
    const r2asKkut = { rank: 51, name: '1끗', tier: 'kkut', kkut: 1, mult: 28 };
    return sutdaCompare(r1, r2asKkut);
  }

  // 땡잡이: 모든 땡(rank 81~90)을 잡음
  if (r1.special === '37' && r2.tier === 'ttaeng') return 1;
  if (r2.special === '37' && r1.tier === 'ttaeng') return -1;

  // 땡잡이 vs 일반패: 땡잡이는 일반 끗수로 계산 (3+7=0끗=망통)
  if (r1.special === '37' && r2.tier !== 'ttaeng') {
    const r1asKkut = { rank: 50, name: '망통', tier: 'kkut', kkut: 0, mult: 21 };
    return sutdaCompare(r1asKkut, r2);
  }
  if (r2.special === '37' && r1.tier !== 'ttaeng') {
    const r2asKkut = { rank: 50, name: '망통', tier: 'kkut', kkut: 0, mult: 21 };
    return sutdaCompare(r1, r2asKkut);
  }

  // 세륙은 선택 후 rank가 변환됨 (밀기=10끗, 깽판=재분배)
  // 여기선 이미 변환된 상태로 들어옴

  // 같은 끗일 때: 곱으로 비교 (무승부 없음)
  if (r1.rank === r2.rank && r1.tier === 'kkut' && r2.tier === 'kkut') {
    if (r1.mult !== r2.mult) return r1.mult > r2.mult ? 1 : -1;
    // 극히 드물게 곱도 같으면 (불가능하지만 안전장치)
    return 0;
  }

  // 일반 rank 비교
  return r1.rank > r2.rank ? 1 : r1.rank < r2.rank ? -1 : 0;
}

// =========================
// 화투패 HTML 렌더링
// =========================
function hwatuCardHTML(card, big) {
  if (!card) {
    const cls = big ? 'hwatu-card hwatu-card-big back' : 'hwatu-card back';
    return '<div class="' + cls + '"></div>';
  }
  const sizeClass = big ? 'hwatu-card hwatu-card-big' : 'hwatu-card';
  const typeClass = card.gwang ? 'gwang' : 'normal';
  const monthClass = 'm' + card.num;
  const gwangText = card.gwang ? '<span class="hwatu-gwang-text">' + (GWANG_NAMES[card.num] || '광') + '</span>' : '';
  const monthLabel = card.num + '월';
  return '<div class="' + sizeClass + ' ' + typeClass + ' ' + monthClass + '">' +
    '<span class="hwatu-num">' + card.num + '</span>' +
    '<span class="hwatu-month">' + monthLabel + '</span>' +
    gwangText +
    '</div>';
}

// =========================
// 덱 셔플
// =========================
function shuffleHwatu() {
  const deck = HWATU_DECK.map(c => ({ num: c.num, gwang: c.gwang, id: c.id }));
  for (let i = deck.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [deck[i], deck[j]] = [deck[j], deck[i]];
  }
  return deck;
}

// =========================
// 게임 시작 (호스트)
// =========================
function startSutda() {
  if (!state.isHost) return;
  if (state.players.length < 2 || state.players.length > 6) {
    showToast('섯다는 2~6인 플레이입니다');
    return;
  }

  const deck = shuffleHwatu();
  let deckIdx = 0;

  const prevHost = sutdaHost;
  const n = state.players.length;

  sutdaHost = {
    deck: deck,
    players: state.players.map((p, i) => ({
      id: p.id,
      name: p.name,
      avatar: p.avatar,
      cards: [deck[deckIdx++], deck[deckIdx++]],
      chips: prevHost ? (prevHost.players.find(pp => pp.id === p.id)?.chips || 500000) : 500000,
      bet: 0,
      totalBet: 0,
      died: false,
      allIn: false,
      seatIdx: i,
      acted: false,
      rank: null,
      seryukChoice: null, // 'push' or 'chaos' or null
    })),
    pot: 0,
    currentBet: 0,
    phase: 'betting', // betting, seryuk_choice, showdown
    turnIdx: 0,
    dealerIdx: prevHost ? (prevHost.dealerIdx + 1) % n : 0,
    baseBet: 10000, // 기본 판돈
    roundNum: prevHost ? (prevHost.roundNum || 0) + 1 : 1,
    bettingRound: 0,
    lastRaiser: -1,
    seryukPlayerId: null,
    seryukCanChaos: false,
  };

  // 기본 판돈 차감
  sutdaHost.players.forEach(p => {
    const ante = Math.min(sutdaHost.baseBet, p.chips);
    p.chips -= ante;
    p.totalBet += ante;
    sutdaHost.pot += ante;
  });

  // 족보 계산
  sutdaHost.players.forEach(p => {
    p.rank = getSutdaRank(p.cards[0], p.cards[1]);
  });

  // 세륙 체크 - 세륙을 가진 플레이어가 있는지
  const seryukPlayer = sutdaHost.players.find(p => p.rank.special === '64');
  if (seryukPlayer) {
    // 세륙 플레이어가 있으면, 나중에 콜을 먼저 받았을 때 선택
    sutdaHost.seryukPlayerId = seryukPlayer.id;
    // 9땡 이하인 상대가 있어야 깽판 가능
    const others = sutdaHost.players.filter(p => p.id !== seryukPlayer.id);
    sutdaHost.seryukCanChaos = others.some(p => p.rank.rank <= 89);
  }

  // 딜러 다음 사람부터 시작
  sutdaHost.turnIdx = (sutdaHost.dealerIdx + 1) % n;
  // 턴 플레이어 찾기
  sutdaHost.turnIdx = findNextSutdaActive(sutdaHost, sutdaHost.turnIdx);

  broadcastSutdaState();

  // 호스트 자신도 게임 화면 표시
  showScreen('sutdaGame');

  // 다른 플레이어에게 game-start 전송
  state.players.forEach(p => {
    if (p.id !== state.myId) {
      sendTo(p.id, {
        type: 'game-start',
        game: 'sutda',
        state: buildSutdaView(p.id),
      });
    }
  });
}

// =========================
// 다음 활성 플레이어 찾기
// =========================
function findNextSutdaActive(gs, from) {
  let idx = from;
  for (let i = 0; i < gs.players.length; i++) {
    const p = gs.players[idx];
    if (!p.died && !p.allIn) return idx;
    idx = (idx + 1) % gs.players.length;
  }
  return from;
}

// =========================
// 뷰 빌드 (각 플레이어별)
// =========================
function buildSutdaView(forPlayerId) {
  const gs = sutdaHost;
  const isShowdown = gs.phase === 'showdown';

  return {
    type: 'sutda-state',
    players: gs.players.map(p => ({
      id: p.id,
      name: p.name,
      avatar: p.avatar,
      chips: p.chips,
      bet: p.bet,
      totalBet: p.totalBet,
      died: p.died,
      allIn: p.allIn,
      seatIdx: p.seatIdx,
      // 자기 패만 보임, showdown이면 전원 공개 (죽은 사람도)
      cards: (p.id === forPlayerId || isShowdown) ? p.cards : null,
      rank: (p.id === forPlayerId || isShowdown) ? p.rank : null,
      seryukChoice: p.seryukChoice,
    })),
    pot: gs.pot,
    currentBet: gs.currentBet,
    phase: gs.phase,
    turnIdx: gs.turnIdx,
    dealerIdx: gs.dealerIdx,
    roundNum: gs.roundNum,
    baseBet: gs.baseBet,
    seryukPlayerId: gs.seryukPlayerId,
    seryukCanChaos: gs.seryukCanChaos,
  };
}

// =========================
// 상태 브로드캐스트
// =========================
function broadcastSutdaState() {
  const gs = sutdaHost;
  gs.players.forEach(p => {
    const view = buildSutdaView(p.id);
    if (p.id === state.myId) {
      sutdaView = view;
      renderSutdaView(view);
    } else {
      sendTo(p.id, view);
    }
  });
}

// =========================
// 뷰 렌더링 (클라이언트)
// =========================
function renderSutdaView(vs) {
  sutdaView = vs;
  showScreen('sutdaGame');

  const me = vs.players.find(p => p.id === state.myId);
  const isMyTurn = vs.players[vs.turnIdx]?.id === state.myId && vs.phase === 'betting' && !me?.died;

  // 상단
  document.getElementById('sutdaPotBadge').textContent = formatChips(vs.pot);
  document.getElementById('sutdaMyBalance').textContent = formatChips(me?.chips || 0);

  // 판돈
  document.getElementById('sutdaPotAmount').textContent = formatChips(vs.pot);

  // 턴 표시
  const turnPlayer = vs.players[vs.turnIdx];
  if (vs.phase === 'betting' && turnPlayer && !turnPlayer.died) {
    document.getElementById('sutdaTurnIndicator').textContent =
      turnPlayer.id === state.myId ? '내 차례' : turnPlayer.name + '의 차례';
  } else if (vs.phase === 'seryuk_choice') {
    document.getElementById('sutdaTurnIndicator').textContent = '세륙 선택 중...';
  } else if (vs.phase === 'showdown') {
    document.getElementById('sutdaTurnIndicator').textContent = '결과 공개!';
  } else {
    document.getElementById('sutdaTurnIndicator').textContent = '';
  }

  // 상대방
  const oppArea = document.getElementById('sutdaOpponents');
  const ops = vs.players.filter(p => p.id !== state.myId);
  oppArea.innerHTML = ops.map(p => {
    const isTurn = vs.players[vs.turnIdx]?.id === p.id && vs.phase === 'betting';
    const pIdx = vs.players.findIndex(pp => pp.id === p.id);
    let statusText = '';
    let statusClass = 'waiting';
    if (p.died) { statusText = '다이'; statusClass = 'die'; }
    else if (p.allIn) { statusText = '올인'; statusClass = 'bet'; }
    else if (p.bet > 0) { statusText = formatChips(p.bet); statusClass = 'bet'; }

    const cardsHTML = p.cards
      ? p.cards.map(c => hwatuCardHTML(c, false)).join('')
      : hwatuCardHTML(null, false) + hwatuCardHTML(null, false);

    return '<div class="sutda-opp-slot' + (p.died ? ' died' : '') + '">' +
      '<div class="sutda-opp-avatar' + (isTurn ? ' active-turn' : '') + '" style="background:' + PLAYER_COLORS[pIdx % PLAYER_COLORS.length] + ';">' + p.avatar + '</div>' +
      '<div class="sutda-opp-name">' + p.name + '</div>' +
      '<div class="sutda-opp-chips">' + formatChips(p.chips) + '</div>' +
      '<div class="sutda-opp-status ' + statusClass + '">' + statusText + '</div>' +
      '<div class="sutda-opp-cards">' + cardsHTML + '</div>' +
      (p.rank && vs.phase === 'showdown' ? '<div style="font-size:11px;color:#ff1744;font-weight:700;margin-top:2px;">' + p.rank.name + '</div>' : '') +
      '</div>';
  }).join('');

  // 내 패
  const myCardsEl = document.getElementById('sutdaMyCards');
  if (me?.cards) {
    myCardsEl.innerHTML = me.cards.map(c => hwatuCardHTML(c, true)).join('');
  } else {
    myCardsEl.innerHTML = hwatuCardHTML(null, true) + hwatuCardHTML(null, true);
  }

  // 내 칩
  document.getElementById('sutdaMyChips').textContent = formatChips(me?.chips || 0);
  document.getElementById('sutdaMyName').textContent = me?.name || '나';

  // 족보 표시
  const rankEl = document.getElementById('sutdaMyRank');
  if (me?.rank) {
    rankEl.textContent = me.rank.name;
  } else {
    rankEl.textContent = '';
  }

  // 세륙 패널
  const seryukPanel = document.getElementById('sutdaSeryukPanel');
  if (vs.phase === 'seryuk_choice' && vs.seryukPlayerId === state.myId) {
    seryukPanel.style.display = 'flex';
  } else {
    seryukPanel.style.display = 'none';
  }

  // 배팅 버튼
  const actionBar = document.getElementById('sutdaActionBar');
  const allBtns = actionBar.querySelectorAll('.sutda-bet-btn');

  if (isMyTurn && vs.phase === 'betting') {
    allBtns.forEach(b => b.disabled = false);

    // 콜 금액 계산
    const toCall = vs.currentBet - (me?.bet || 0);
    const callBtn = document.getElementById('sutdaBtnCall');
    if (toCall > 0) {
      callBtn.textContent = '콜 ' + formatChips(toCall);
    } else {
      callBtn.textContent = '콜';
    }

    // 칩이 부족하면 레이즈 비활성화
    if (me && me.chips <= 0) {
      document.getElementById('sutdaBtn10k').disabled = true;
      document.getElementById('sutdaBtn50k').disabled = true;
      document.getElementById('sutdaBtn100k').disabled = true;
    }
    if (me && me.chips < 10000) document.getElementById('sutdaBtn10k').disabled = true;
    if (me && me.chips < 50000) document.getElementById('sutdaBtn50k').disabled = true;
    if (me && me.chips < 100000) document.getElementById('sutdaBtn100k').disabled = true;
  } else {
    allBtns.forEach(b => b.disabled = true);
  }
}

// =========================
// 칩 포맷
// =========================
function formatChips(n) {
  if (n >= 10000) {
    const man = Math.floor(n / 10000);
    const rest = n % 10000;
    if (rest === 0) return man + '만';
    return man + '만' + rest.toLocaleString();
  }
  return n.toLocaleString();
}

// =========================
// 배팅 액션 (클라이언트)
// =========================
function sutdaBet(action, amount) {
  if (state.isHost) {
    processSutdaAction(state.myId, action, amount);
  } else {
    const hostConn = Object.values(state.connections)[0];
    if (hostConn?.open) {
      hostConn.send(JSON.stringify({
        type: 'sutda-bet',
        action: action,
        amount: amount,
      }));
    }
  }
}

// =========================
// 세륙 선택 (클라이언트)
// =========================
function sutdaSeryukChoice(choice) {
  document.getElementById('sutdaSeryukPanel').style.display = 'none';
  if (state.isHost) {
    processSutdaSeryuk(state.myId, choice);
  } else {
    const hostConn = Object.values(state.connections)[0];
    if (hostConn?.open) {
      hostConn.send(JSON.stringify({
        type: 'sutda-seryuk',
        choice: choice,
      }));
    }
  }
}

// =========================
// 배팅 처리 (호스트)
// =========================
function processSutdaAction(playerId, action, amount) {
  const gs = sutdaHost;
  if (!gs || gs.phase !== 'betting') return;

  const pIdx = gs.players.findIndex(p => p.id === playerId);
  if (pIdx !== gs.turnIdx) return;

  const player = gs.players[pIdx];
  if (player.died || player.allIn) return;

  const toCall = gs.currentBet - player.bet;

  switch (action) {
    case 'die':
      player.died = true;
      break;

    case 'call': {
      const a = Math.min(toCall, player.chips);
      player.chips -= a;
      player.bet += a;
      player.totalBet += a;
      gs.pot += a;
      if (player.chips === 0) player.allIn = true;
      break;
    }

    case 'raise': {
      // 먼저 콜 금액 + 추가 레이즈
      const raiseTotal = toCall + (amount || 10000);
      const a = Math.min(raiseTotal, player.chips);
      player.chips -= a;
      player.bet += a;
      player.totalBet += a;
      gs.pot += a;
      if (player.bet > gs.currentBet) {
        gs.currentBet = player.bet;
        gs.lastRaiser = pIdx;
      }
      if (player.chips === 0) player.allIn = true;
      // 다른 사람들 acted 리셋
      gs.players.forEach((p, i) => {
        if (i !== pIdx && !p.died && !p.allIn) p.acted = false;
      });
      break;
    }

    case 'allin': {
      const a = player.chips;
      player.bet += a;
      player.totalBet += a;
      gs.pot += a;
      player.chips = 0;
      player.allIn = true;
      if (player.bet > gs.currentBet) {
        gs.currentBet = player.bet;
        gs.lastRaiser = pIdx;
        gs.players.forEach((p, i) => {
          if (i !== pIdx && !p.died && !p.allIn) p.acted = false;
        });
      }
      break;
    }
  }

  player.acted = true;

  // 살아있는 플레이어 수 체크
  const alive = gs.players.filter(p => !p.died);
  if (alive.length === 1) {
    // 혼자 남으면 즉시 승리
    endSutdaRound(alive[0]);
    return;
  }

  // 세륙 체크: 세륙 플레이어가 살아있고, 콜을 받았을 때 (첫 번째 배팅 라운드 종료 시)
  // 세륙 선택은 모든 사람이 한 번씩 배팅을 마친 후 트리거
  const canAct = gs.players.filter(p => !p.died && !p.allIn);
  const allActed = canAct.every(p => p.acted && p.bet >= gs.currentBet);

  if (canAct.length === 0 || allActed) {
    // 세륙 플레이어가 있고, 아직 선택을 안 했으면
    const seryukP = gs.players.find(p => p.id === gs.seryukPlayerId && !p.died);
    if (seryukP && seryukP.seryukChoice === null && gs.phase === 'betting') {
      gs.phase = 'seryuk_choice';
      broadcastSutdaState();
      return;
    }

    // 쇼다운
    resolveSutdaShowdown();
    return;
  }

  // 다음 턴
  gs.turnIdx = findNextSutdaActive(gs, (gs.turnIdx + 1) % gs.players.length);
  broadcastSutdaState();
}

// =========================
// 세륙 처리 (호스트)
// =========================
function processSutdaSeryuk(playerId, choice) {
  const gs = sutdaHost;
  if (!gs || gs.phase !== 'seryuk_choice') return;
  if (playerId !== gs.seryukPlayerId) return;

  const seryukP = gs.players.find(p => p.id === playerId);
  if (!seryukP) return;

  seryukP.seryukChoice = choice;

  if (choice === 'push') {
    // 밀기: 세륙을 망통(0끗) 대신 갑오(9끗) 급으로 취급? 아니, 10끗으로 계산
    // 끗수에서 10끗은 0끗이지만, 여기서는 특별히 "밀기"로 갑오(9끗)와 동급 또는 그 위로 계산
    // 규칙상 "10끗" = 합 10의 일의 자리 = 0이지만, 밀기는 "갑오(9끗) 바로 아래"로 적용하는 것이 일반적
    // 더 정확히는: 밀기 = 갑오(9끗)와 동일한 등급으로 "세륙밀기"
    seryukP.rank = { rank: 59, name: '세륙밀기', tier: 'kkut', kkut: 10, mult: 24, special: null };
    gs.phase = 'betting';
    // 배팅 계속 (추가 라운드 없이 바로 showdown)
    resolveSutdaShowdown();
  } else if (choice === 'chaos') {
    // 깽판: 9땡 이하인 경우만 가능
    // 살아있는 유저 전원 패 재분배
    const alive = gs.players.filter(p => !p.died);
    // 9땡 이상이면 깽판 불가 (38광땡, 18광땡, 13광땡, 장땡)
    const hasHighHand = alive.some(p => p.id !== playerId && p.rank.rank >= 90);
    if (hasHighHand) {
      // 깽판 실패 - 밀기로 강제 전환
      seryukP.rank = { rank: 59, name: '세륙밀기', tier: 'kkut', kkut: 10, mult: 24, special: null };
      showToast('상대에게 장땡 이상이 있어 깽판 실패!');
    } else {
      // 패 재분배
      const newDeck = shuffleHwatu();
      let newIdx = 0;
      alive.forEach(p => {
        p.cards = [newDeck[newIdx++], newDeck[newIdx++]];
        p.rank = getSutdaRank(p.cards[0], p.cards[1]);
        p.seryukChoice = null;
      });
      // 세륙 상태 리셋
      gs.seryukPlayerId = null;
      // 새로운 패에서 세륙이 또 나올 수 있음
      const newSeryuk = alive.find(p => p.rank.special === '64');
      if (newSeryuk) {
        gs.seryukPlayerId = newSeryuk.id;
        gs.seryukCanChaos = alive.some(p => p.id !== newSeryuk.id && p.rank.rank <= 89);
        // 다시 세륙 선택
        gs.phase = 'seryuk_choice';
        broadcastSutdaState();
        return;
      }
    }
    gs.phase = 'betting';
    resolveSutdaShowdown();
  }
}

// =========================
// 쇼다운 (결과 판정)
// =========================
function resolveSutdaShowdown() {
  const gs = sutdaHost;
  gs.phase = 'showdown';

  const alive = gs.players.filter(p => !p.died);

  if (alive.length === 0) return;
  if (alive.length === 1) {
    endSutdaRound(alive[0]);
    return;
  }

  // 가장 강한 패 찾기
  let bestPlayer = alive[0];
  for (let i = 1; i < alive.length; i++) {
    const cmp = sutdaCompare(alive[i].rank, bestPlayer.rank);
    if (cmp > 0) bestPlayer = alive[i];
  }

  endSutdaRound(bestPlayer);
}

// =========================
// 라운드 종료
// =========================
function endSutdaRound(winner) {
  const gs = sutdaHost;
  winner.chips += gs.pot;
  gs.phase = 'showdown';

  // 먼저 showdown 뷰를 브로드캐스트
  broadcastSutdaState();

  // 결과 메시지 전송
  const result = {
    type: 'sutda-result',
    winnerId: winner.id,
    winnerName: winner.name,
    winnerAvatar: winner.avatar,
    winnerCards: winner.cards,
    winnerRank: winner.rank,
    pot: gs.pot,
    allHands: gs.players.map(p => ({
      id: p.id,
      name: p.name,
      avatar: p.avatar,
      cards: p.cards,
      rank: p.rank,
      died: p.died,
      seatIdx: p.seatIdx,
    })),
  };

  setTimeout(() => {
    broadcast(result);
    handleSutdaResult(result);
  }, 1200);
}

// =========================
// 결과 표시 (클라이언트)
// =========================
function handleSutdaResult(msg) {
  const won = msg.winnerId === state.myId;
  recordGame(won);

  const overlay = document.getElementById('sutdaResultOverlay');
  document.getElementById('sutdaResultTitle').textContent = won ? '승리!' : '패배...';
  document.getElementById('sutdaResultTitle').style.color = won ? 'var(--gold)' : 'var(--text-dim)';
  document.getElementById('sutdaResultWinner').textContent = msg.winnerName + ' ' + msg.winnerAvatar;
  document.getElementById('sutdaResultRank').textContent = msg.winnerRank ? msg.winnerRank.name : '';
  document.getElementById('sutdaResultCards').innerHTML = msg.winnerCards
    ? msg.winnerCards.map(c => hwatuCardHTML(c, true)).join('')
    : '';
  document.getElementById('sutdaResultPot').textContent = formatChips(msg.pot);

  // 전체 결과 표시
  const allEl = document.getElementById('sutdaResultAllHands');
  allEl.innerHTML = msg.allHands.map(h => {
    const isWinner = h.id === msg.winnerId;
    const isDied = h.died;
    const rowClass = 'sutda-result-hand-row' + (isWinner ? ' winner-row' : '') + (isDied ? ' died-row' : '');
    const pIdx = h.seatIdx;
    return '<div class="' + rowClass + '">' +
      '<div class="sutda-result-hand-avatar" style="background:' + PLAYER_COLORS[pIdx % PLAYER_COLORS.length] + ';">' + h.avatar + '</div>' +
      '<div class="sutda-result-hand-name">' + h.name + (isWinner ? ' (승)' : '') + (isDied ? ' (다이)' : '') + '</div>' +
      '<div class="sutda-result-hand-rank">' + (h.rank ? h.rank.name : '-') + '</div>' +
      '<div class="sutda-result-hand-cards">' + (h.cards ? h.cards.map(c => hwatuCardHTML(c, false)).join('') : '') + '</div>' +
      '</div>';
  }).join('');

  overlay.classList.add('active');
}

// =========================
// 결과 닫기
// =========================
function closeSutdaResult() {
  document.getElementById('sutdaResultOverlay').classList.remove('active');
  if (state.isHost) {
    // 다음 라운드 시작
    setTimeout(() => startSutda(), 500);
  }
}

// ===== RACING ENGINE =====

let racingState = {
  mode: 'survival', // 'survival' or 'race'
  speed: 30, // km/h
  maxSpeed: 30,
  distance: 0, // meters
  lanePos: 1, // 0=left, 1=center, 2=right
  targetLane: 1,
  obstacles: [], // [{id, lane, y, type: 'car'|'truck'}]
  alive: true,
  players: {}, // {playerId: {distance, alive, maxSpeed}}
  phase: 'menu', // 'menu', 'playing', 'gameover'
  startTime: 0,
  gyroEnabled: false,
  nextObstacleId: 0,
};

let racingLoop = null;
let racingAnimationFrame = null;

function startRacing() {
  if(!state.isHost) return;

  // 멀티플레이어 모드는 기본 구현
  broadcast({ type: 'game-start', game: 'racing', state: {} });
  showScreen('racingGame');
  document.getElementById('racingModeSelect').style.display = 'flex';
}

function selectRacingMode(mode) {
  racingState.mode = mode;
  racingState.phase = 'permission';

  // iOS 체크
  const needsPermission = typeof DeviceOrientationEvent !== 'undefined' &&
                         typeof DeviceOrientationEvent.requestPermission === 'function';

  if(needsPermission) {
    document.getElementById('racingGyroPermission').style.display = 'flex';
  } else {
    // 안드로이드나 데스크톱: 바로 시작
    startRacingGame();
  }
}

function requestGyroPermission() {
  if(typeof DeviceOrientationEvent !== 'undefined' &&
     typeof DeviceOrientationEvent.requestPermission === 'function') {
    DeviceOrientationEvent.requestPermission()
      .then(response => {
        if(response === 'granted') {
          racingState.gyroEnabled = true;
          startRacingGame();
        } else {
          showToast('기울기 권한이 필요합니다');
          // 터치 컨트롤 사용
          startRacingGame();
        }
      })
      .catch(err => {
        console.error('Gyro permission error:', err);
        showToast('터치 컨트롤을 사용합니다');
        startRacingGame();
      });
  } else {
    racingState.gyroEnabled = true;
    startRacingGame();
  }
}

function startRacingGame() {
  // 초기화
  racingState = {
    mode: racingState.mode,
    speed: 30,
    maxSpeed: 30,
    distance: 0,
    lanePos: 1,
    targetLane: 1,
    obstacles: [],
    alive: true,
    players: {},
    phase: 'playing',
    startTime: Date.now(),
    gyroEnabled: racingState.gyroEnabled,
    nextObstacleId: 0,
  };

  // UI 전환
  document.getElementById('racingModeSelect').style.display = 'none';
  document.getElementById('racingGameArea').style.display = 'block';

  // 건물 생성
  generateBuildings();

  // 차선 점선 생성
  generateDashes();

  // 자이로스코프 또는 터치 컨트롤
  if(racingState.gyroEnabled) {
    window.addEventListener('deviceorientation', handleRacingTilt);
  } else {
    document.getElementById('racingTouchControls').style.display = 'flex';
  }

  // 게임 루프 시작
  racingLoop = setInterval(racingTick, 50); // 20 FPS
}

function generateBuildings() {
  const container = document.getElementById('racingBuildings');
  container.innerHTML = '';

  for(let i = 0; i < 15; i++) {
    const building = document.createElement('div');
    building.className = 'racing-building';
    building.style.left = (Math.random() * 100) + '%';
    building.style.width = (30 + Math.random() * 40) + 'px';
    building.style.height = (50 + Math.random() * 100) + 'px';
    building.style.bottom = '0';
    container.appendChild(building);
  }
}

function generateDashes() {
  const container = document.getElementById('racingDashes');
  container.innerHTML = '';

  // 각 차선마다 점선 생성
  const lanes = [16.66, 50, 83.33]; // 각 차선 중앙

  lanes.forEach((lanePercent, laneIdx) => {
    for(let i = 0; i < 8; i++) {
      const dash = document.createElement('div');
      dash.className = 'racing-dash';
      dash.style.left = lanePercent + '%';
      dash.style.top = (i * 100) + 'px';
      dash.style.animationDelay = (-i * 0.125) + 's';
      container.appendChild(dash);
    }
  });
}

function handleRacingTilt(e) {
  if(racingState.phase !== 'playing' || !racingState.alive) return;

  const gamma = e.gamma || 0; // -90 (left) to 90 (right)

  if(gamma < -15) {
    racingState.targetLane = 0;
  } else if(gamma > 15) {
    racingState.targetLane = 2;
  } else {
    racingState.targetLane = 1;
  }
}

function racingMoveLane(lane) {
  if(racingState.phase !== 'playing' || !racingState.alive) return;
  racingState.targetLane = lane;
}

function racingStopMove() {
  // 필요시 구현
}

function racingTick() {
  if(racingState.phase !== 'playing' || !racingState.alive) return;

  const dt = 0.05; // 50ms

  // 속도 증가 (서바이벌 모드)
  if(racingState.mode === 'survival') {
    racingState.speed += 0.1 * dt * 20; // 점진적 증가
    if(racingState.speed > 150) racingState.speed = 150; // 최대 속도
  } else {
    // 레이스 모드: 고정 속도
    racingState.speed = 80;
  }

  racingState.maxSpeed = Math.max(racingState.maxSpeed, racingState.speed);

  // 거리 업데이트
  const distanceDelta = (racingState.speed / 3.6) * dt; // m/s * dt
  racingState.distance += distanceDelta;

  // 레이스 모드: 목표 도달 체크
  if(racingState.mode === 'race' && racingState.distance >= 1000) {
    racingGameOver(true); // 완주
    return;
  }

  // 차선 이동
  racingState.lanePos += (racingState.targetLane - racingState.lanePos) * 0.15;

  // 장애물 생성
  if(Math.random() < 0.02 * (racingState.speed / 30)) { // 속도에 비례
    spawnObstacle();
  }

  // 장애물 이동
  const speedFactor = racingState.speed / 30;
  racingState.obstacles.forEach(obs => {
    obs.y += 5 * speedFactor;
  });

  // 장애물 제거 (화면 밖)
  racingState.obstacles = racingState.obstacles.filter(obs => obs.y < window.innerHeight + 100);

  // 충돌 체크
  checkRacingCollision();

  // UI 업데이트
  updateRacingUI();

  // P2P: 내 위치 전송 (멀티플레이어)
  if(state.isHost && state.players.length > 1) {
    racingState.players[state.myId] = {
      distance: racingState.distance,
      alive: racingState.alive,
      maxSpeed: racingState.maxSpeed,
      name: state.myName,
      avatar: state.myAvatar,
    };

    // 주기적으로 순위 브로드캐스트
    if(Math.random() < 0.1) {
      broadcast({
        type: 'race-position',
        playerId: state.myId,
        distance: racingState.distance,
        alive: racingState.alive,
        maxSpeed: racingState.maxSpeed,
      });
    }
  } else if(!state.isHost) {
    // 게스트: 호스트에게 내 위치 전송
    if(Math.random() < 0.1) {
      sendToHost({
        type: 'race-position',
        playerId: state.myId,
        distance: racingState.distance,
        alive: racingState.alive,
        maxSpeed: racingState.maxSpeed,
        name: state.myName,
        avatar: state.myAvatar,
      });
    }
  }
}

function spawnObstacle() {
  const lane = Math.floor(Math.random() * 3);
  const type = Math.random() < 0.7 ? 'car' : 'truck';

  racingState.obstacles.push({
    id: racingState.nextObstacleId++,
    lane: lane,
    y: -100,
    type: type,
  });
}

function checkRacingCollision() {
  const bikeBottomY = window.innerHeight - 120; // 오토바이 위치
  const bikeLane = Math.round(racingState.lanePos);

  racingState.obstacles.forEach(obs => {
    const obsLane = obs.lane;
    const obsY = obs.y;
    const obsHeight = obs.type === 'truck' ? 80 : 60;

    // 충돌 체크
    if(bikeLane === obsLane &&
       obsY < bikeBottomY + 60 &&
       obsY + obsHeight > bikeBottomY) {
      // 충돌!
      handleRacingCrash();
    }
  });
}

function handleRacingCrash() {
  racingState.alive = false;
  racingState.phase = 'gameover';

  // 효과
  const overlay = document.getElementById('racingCrashOverlay');
  overlay.classList.add('active');

  if(navigator.vibrate) navigator.vibrate([200, 100, 200]);

  setTimeout(() => {
    overlay.classList.remove('active');
    racingGameOver(false);
  }, 500);
}

function updateRacingUI() {
  // 속도
  document.getElementById('racingSpeed').textContent = Math.round(racingState.speed);

  // 거리
  document.getElementById('racingDistance').textContent = Math.round(racingState.distance);

  // 오토바이 위치
  const bike = document.getElementById('racingBike');
  const lanePositions = [10, 36, 62]; // %
  bike.style.left = lanePositions[Math.round(racingState.lanePos)] + '%';

  // 장애물 렌더링
  const container = document.getElementById('racingObstacles');
  const existingIds = Array.from(container.children).map(el => el.dataset.obsId);
  const currentIds = racingState.obstacles.map(obs => obs.id.toString());

  // 제거할 장애물
  existingIds.forEach(id => {
    if(!currentIds.includes(id)) {
      const el = container.querySelector(`[data-obs-id="${id}"]`);
      if(el) el.remove();
    }
  });

  // 추가/업데이트할 장애물
  racingState.obstacles.forEach(obs => {
    let el = container.querySelector(`[data-obs-id="${obs.id}"]`);

    if(!el) {
      el = document.createElement('div');
      el.className = 'racing-obstacle';
      el.dataset.obsId = obs.id;

      const body = document.createElement('div');
      body.className = obs.type === 'truck' ? 'racing-obstacle-truck' : 'racing-obstacle-car';
      el.appendChild(body);

      container.appendChild(el);
    }

    const lanePositions = [10, 36, 62]; // %
    el.style.left = lanePositions[obs.lane] + '%';
    el.style.top = obs.y + 'px';
  });

  // 순위 (멀티플레이어)
  if(state.players.length > 1) {
    const rankEl = document.getElementById('racingRank');
    rankEl.style.display = 'block';

    const allPlayers = Object.values(racingState.players).filter(p => p.alive);
    allPlayers.sort((a, b) => b.distance - a.distance);

    const myRank = allPlayers.findIndex(p => p.distance === racingState.distance) + 1;
    document.getElementById('racingRankValue').textContent = myRank + '위/' + allPlayers.length + '명';
  }
}

function racingGameOver(completed) {
  // 게임 종료
  if(racingLoop) {
    clearInterval(racingLoop);
    racingLoop = null;
  }

  window.removeEventListener('deviceorientation', handleRacingTilt);

  // 결과 전송 (멀티플레이어)
  if(state.isHost && state.players.length > 1) {
    racingState.players[state.myId] = {
      distance: racingState.distance,
      alive: racingState.alive,
      maxSpeed: racingState.maxSpeed,
      time: (Date.now() - racingState.startTime) / 1000,
      name: state.myName,
      avatar: state.myAvatar,
    };

    broadcast({
      type: 'race-result',
      playerId: state.myId,
      distance: racingState.distance,
      maxSpeed: racingState.maxSpeed,
      time: (Date.now() - racingState.startTime) / 1000,
      completed: completed,
    });

    // 모든 결과 대기 후 결과 화면
    setTimeout(() => {
      showRacingResults();
    }, 2000);

  } else if(!state.isHost) {
    // 게스트: 호스트에게 결과 전송
    sendToHost({
      type: 'race-result',
      playerId: state.myId,
      distance: racingState.distance,
      maxSpeed: racingState.maxSpeed,
      time: (Date.now() - racingState.startTime) / 1000,
      completed: completed,
      name: state.myName,
      avatar: state.myAvatar,
    });

    // 결과 대기
    setTimeout(() => {
      showRacingResults();
    }, 2000);

  } else {
    // 싱글플레이어: 바로 결과
    showRacingResults();
  }
}

function showRacingResults() {
  document.getElementById('racingGameArea').style.display = 'none';
  document.getElementById('racingResultScreen').style.display = 'flex';

  // 제목
  const title = document.getElementById('racingResultTitle');
  const subtitle = document.getElementById('racingResultSubtitle');

  if(racingState.mode === 'race' && racingState.distance >= 1000) {
    title.textContent = '완주!';
    subtitle.textContent = '목표 지점에 도달했습니다!';
  } else {
    title.textContent = '게임 오버';
    subtitle.textContent = racingState.alive ? '잘했어요!' : '충돌!';
  }

  // 통계
  document.getElementById('racingResultDistance').textContent = Math.round(racingState.distance) + 'm';
  document.getElementById('racingResultMaxSpeed').textContent = Math.round(racingState.maxSpeed) + ' km/h';
  document.getElementById('racingResultTime').textContent =
    ((Date.now() - racingState.startTime) / 1000).toFixed(1) + '초';

  // 순위 (멀티플레이어)
  if(state.players.length > 1) {
    const list = document.getElementById('racingResultRankingsList');
    const allPlayers = Object.values(racingState.players);
    allPlayers.sort((a, b) => b.distance - a.distance);

    list.innerHTML = allPlayers.map((p, i) => {
      const playerIdx = state.players.findIndex(sp => sp.name === p.name);
      const color = PLAYER_COLORS[playerIdx % PLAYER_COLORS.length];

      return `
        <div class="racing-result-ranking-item ${i === 0 ? 'first' : ''}">
          <div class="racing-result-ranking-rank">${i + 1}위</div>
          <div class="racing-result-ranking-avatar" style="background:${color};">${p.avatar}</div>
          <div class="racing-result-ranking-name">${p.name}</div>
          <div class="racing-result-ranking-distance">${Math.round(p.distance)}m</div>
        </div>
      `;
    }).join('');

    document.getElementById('racingResultRankings').style.display = 'block';
  } else {
    document.getElementById('racingResultRankings').style.display = 'none';
  }
}

function restartRacing() {
  document.getElementById('racingResultScreen').style.display = 'none';
  document.getElementById('racingModeSelect').style.display = 'flex';
  document.getElementById('racingGyroPermission').style.display = 'none';

  racingState.phase = 'menu';
}

function sendToHost(msg) {
  const hostId = state.players.find(p => p.isHost)?.id;
  if(hostId) sendTo(hostId, msg);
}

function handleRacePosition(peerId, msg) {
  if(!racingState.players) racingState.players = {};

  racingState.players[msg.playerId] = {
    distance: msg.distance,
    alive: msg.alive,
    maxSpeed: msg.maxSpeed,
    name: msg.name,
    avatar: msg.avatar,
  };
}

function handleRaceResult(msg) {
  if(!racingState.players) racingState.players = {};

  racingState.players[msg.playerId] = {
    distance: msg.distance,
    maxSpeed: msg.maxSpeed,
    time: msg.time,
    completed: msg.completed,
    name: msg.name,
    avatar: msg.avatar,
  };
}

// ===== EVENTS =====
document.getElementById('nameInput').addEventListener('change', saveProfile);
document.getElementById('nameInput').addEventListener('blur', saveProfile);

// ===== START =====
init();
</script>
</body>
</html>
